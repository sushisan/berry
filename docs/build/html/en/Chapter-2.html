<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. Types and Variables &mdash; berry 1.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. Expression" href="Chapter-3.html" />
    <link rel="prev" title="Basic Information" href="Chapter-1.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> berry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="Home.html">English</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="Reference.html">The Berry Script Language Reference Manual</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="Reference.html#preface">Preface</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="Chapter-1.html">Chapter 1 — Basic Information</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Chapter 2 — Types and Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="Chapter-3.html">Chapter 3 — Expression</a></li>
<li class="toctree-l4"><a class="reference internal" href="Chapter-4.html">Chapter 4 — Statement</a></li>
<li class="toctree-l4"><a class="reference internal" href="Chapter-5.html">Chapter 5 — Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="Chapter-6.html">Chapter 6 — Object Oriented Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="Chapter-7.html">Chapter 7 — Libraries and Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="Chapter-8.html">Chapter 8 — Advanced features</a></li>
<li class="toctree-l4"><a class="reference internal" href="Chapter-9.html">Chapter 9 — Language Interactive Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="Appendix-A.html">Appendix A — Grammar Definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="Appendix-B.html">Appendix B — Compiler Interpreter</a></li>
<li class="toctree-l4"><a class="reference internal" href="Appendix-C.html">Appendix C — Porting Guide</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="FFI-Example.html">Making a Native Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="FFI-Example.html#instantiate-a-list-object-in-a-native-function">Instantiate a <code class="docutils literal notranslate"><span class="pre">list</span></code> object in a native function</a></li>
<li class="toctree-l2"><a class="reference internal" href="Roadmap.html">Roadmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Requirements.html">Memory Requirements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../es/Home.html">Spanish</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">Berry API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">berry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="Home.html">Welcome to the berry wiki!</a> &raquo;</li>
          <li><a href="Reference.html">The Berry Script Language Reference Manual</a> &raquo;</li>
      <li>2. Types and Variables</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/en/Chapter-2.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="types-and-variables">
<h1>2. Types and Variables<a class="headerlink" href="#types-and-variables" title="Permalink to this headline">¶</a></h1>
<p><strong>Type</strong> is an attribute of data, which defines the meaning of the
data and the operations that can be performed on the data. Types can be
divided into built-in types and user-defined types. Built-in types refer
to some basic types built into the Berry language, among which types
that are not based on class definitions are called <strong>Simple type</strong>.
Types based on class definitions are called <strong>Class type</strong>, some of the
built-in types are class types, and user-defined types are also class
types.</p>
<section id="built-in-type">
<h2>2.1 Built-in type<a class="headerlink" href="#built-in-type" title="Permalink to this headline">¶</a></h2>
<section id="simple-type">
<h3>2.1.1 Simple Type<a class="headerlink" href="#simple-type" title="Permalink to this headline">¶</a></h3>
<section id="nil">
<h4><code class="docutils literal notranslate"><span class="pre">nil</span></code><a class="headerlink" href="#nil" title="Permalink to this headline">¶</a></h4>
<p>The Nil type is the null type, which means that the object has an
invalid value, or it can be said that the object has no meaningful
value. This is a very special type. Although we might say that a
variable is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, in fact the nil type has no value, so what we are
talking about here is that the type of the variable is nil (not a
value).</p>
<p>The default value of a variable before assignment is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. This type
can be used in logic operations. In logic operations, <code class="docutils literal notranslate"><span class="pre">nil</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</section>
<section id="integer-type">
<h4>Integer type<a class="headerlink" href="#integer-type" title="Permalink to this headline">¶</a></h4>
<p>The integer type (integer) represents a signed integer, referred to as
an integer. The number of bits of the integer represented by this type
depends on the specific implementation, and usually consists of a 32-bit
signed integer on a 32-bit platform. Integer is an arithmetic type and
supports all arithmetic operations. Pay attention to the value range of
integers when using this type. The typical value range of 32-bit signed
integers is between  −2147483648 and 2147483647.</p>
<p>Any value can be converted to <code class="docutils literal notranslate"><span class="pre">int</span></code> using the <code class="docutils literal notranslate"><span class="pre">int()</span></code> function; however
<code class="docutils literal notranslate"><span class="pre">int(nil)</span> <span class="pre">==</span> <span class="pre">nil</span></code>. If the argument is an instance and if it contains a
member <code class="docutils literal notranslate"><span class="pre">toint()</span></code> it we be called and the return value converted to <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</section>
<section id="real-number-type">
<h4>Real Number Type<a class="headerlink" href="#real-number-type" title="Permalink to this headline">¶</a></h4>
<p>The real type (real), to be precise, is a floating-point type. Real
number types are usually implemented as single-precision floating-point
numbers or double-precision floating-point numbers. The real number type
is also an arithmetic type. Compared with the integer type, the real
number type has higher precision and a larger value range, so this type
is more suitable for mathematical calculations. It should be noted that
the real number type is actually a floating point number, so there are
still precision problems. For example, it is not recommended to compare
two values of type <code class="docutils literal notranslate"><span class="pre">real</span></code> for equality.</p>
<p>When integers and real numbers participate in operations at the same
time, the integers are usually converted to real numbers.</p>
</section>
<section id="boolean-type">
<h4>Boolean type<a class="headerlink" href="#boolean-type" title="Permalink to this headline">¶</a></h4>
<p>The Boolean type (boolean) is used for logical operations. It has two
values <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>, which represent the two true values (true and
false) in logic and Boolean algebra. The Boolean type is mainly used for
conditional judgment. The operands and return values of logical
expressions and relational expressions are all boolean types, and
statements such as <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> all use boolean types as conditional
checks.</p>
<p>In many cases, non-boolean values can also be used as boolean types.
This is because the interpreter will implicitly convert the parameters.
This is also the reason that conditional check expressions such as <code class="docutils literal notranslate"><span class="pre">if</span></code>
statements can use any type of parameters. The rules for converting
various types to Boolean types are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nil</span></code>: converted to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><strong>Integer</strong>: when the value is <code class="docutils literal notranslate"><span class="pre">0</span></code>, it is converted to <code class="docutils literal notranslate"><span class="pre">false</span></code>,
otherwise it is converted to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p><strong>Real number</strong>: when the value is <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, it is converted to <code class="docutils literal notranslate"><span class="pre">false</span></code>,
otherwise it is converted to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p><strong>String</strong>: when the value is “” (empty string) it is concerted to <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise it is converted to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p><strong>Comobj</strong> and <strong>Comptr</strong>: when the internal pointer is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> it is
converted to <code class="docutils literal notranslate"><span class="pre">false</span></code>, otherwise it is converted to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p><strong>Instance</strong>: if the instance contains a method <code class="docutils literal notranslate"><span class="pre">tobool()</span></code>,
the return value of the method will be used,
otherwise it will be converted to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p>All other types: convert to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
</ul>
<p>Any value can be converted to <code class="docutils literal notranslate"><span class="pre">bool</span></code> using <code class="docutils literal notranslate"><span class="pre">bool()</span></code> function.</p>
</section>
<section id="string">
<h4>String<a class="headerlink" href="#string" title="Permalink to this headline">¶</a></h4>
<p>A string is a sequence of characters. In terms of storage, Berry divides
strings into long strings and short strings. There is only one instance
of the same short character string in memory, and all short character
strings are linked in a hash table. This design helps to improve the
performance of string equality comparison and can reduce memory usage.
Since the use frequency of long strings is low, and the overhead of hash
operation is quite high, they are not linked to the hash table, so there
may be multiple identical instances in the memory. The string is
read-only after it is created. Therefore, “modifying” the string will
generate a new string, and the original string will not be modified.</p>
<p>Berry does not care about the format or encoding of characters. For
example, the string <code class="docutils literal notranslate"><span class="pre">’abc’</span></code> is actually the ASCII code of the characters
<code class="docutils literal notranslate"><span class="pre">’a’</span></code>, <code class="docutils literal notranslate"><span class="pre">’b’</span></code> and <code class="docutils literal notranslate"><span class="pre">’c’</span></code>. Therefore, if there are wide characters in the
string (the character length is greater than 1 byte), the number of
characters in the string cannot be directly counted. In fact, using the
<code class="docutils literal notranslate"><span class="pre">size()</span></code> function can only get the number of bytes in the string. In
addition, in order to facilitate interaction with the C language,
Berry’s string always ends with <code class="docutils literal notranslate"><span class="pre">’\0’</span></code> characters. This feature is
transparent to the Berry program.</p>
<p>The string type can be compared in size, so it can be used in relational
operations.</p>
</section>
<section id="function">
<h4>Function<a class="headerlink" href="#function" title="Permalink to this headline">¶</a></h4>
<p>A function is a piece of code that is encapsulated and available for
call, generally used to implement a specific function. Function is
actually a big category, which includes several subtypes such as
closures, native functions, and native closures. For Berry code, all
function subtypes have the same behavior. Functions belong to the first
type of value in Berry, so they can be passed as values. In addition, it
can be directly used in expressions through the “literal” form of
“anonymous functions”.</p>
<p>A function is a read-only object and cannot be modified once defined.
You can compare whether two functions are equal (whether they are the
same function), but the function type cannot be compared.<strong>Native
function</strong> (native function) and <strong>Native closure</strong> (native closure)
refer to functions and closures implemented in C language. One of the
main purposes of native functions and native closures is to provide
functions that the Berry language does not provide, such as IO
operations and low-level operations. If a piece of code is used
frequently and has performance requirements, it is also recommended to
rewrite it as a native function or native closure.</p>
</section>
<section id="class">
<h4>Class<a class="headerlink" href="#class" title="Permalink to this headline">¶</a></h4>
<p>In object-oriented programming, a class is an extensible program code
template. Classes are used to create instance objects, so the class can
be said to be the “type” of the instance. All instance objects are of
type <code class="docutils literal notranslate"><span class="pre">instance</span></code> and they all have a corresponding class, which is called
instance <strong>Class type</strong>. To put it simply, a class is a value
representing the type of an instance object, and a class is an
abstraction of the characteristics of an instance. A class is also a
read-only object, once defined, it cannot be modified.</p>
<p>Classes can only compare equals and unequals, but cannot compare sizes.</p>
</section>
<section id="examples">
<h4>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h4>
<p>An instance is a materialized object generated by a class, and the
process of generating an instance from a class is called <code class="docutils literal notranslate"><span class="pre">Instantiate</span></code>.
In object-oriented programming, “instance” is usually synonymous with
“object”. However, in order to distinguish from non-instance objects, we
do not use the term “object” alone, but use “instance” or “instance
object”. Berry instances are always allocated dynamically and need to be
used with a garbage collector. In addition to memory allocation, the
process of instantiation also needs to initialize the instance, this
process is completed by <code class="docutils literal notranslate"><span class="pre">Constructor</span></code>. In addition, you can complete the
destruction of the object through <code class="docutils literal notranslate"><span class="pre">Destructor</span></code> before reclaiming the
object’s memory.</p>
<p>In the internal implementation, the instance will contain a reference to
the class, and the instance itself only stores member variables and not
methods.</p>
</section>
</section>
<section id="class-type">
<h3>2.1.2 Class Type<a class="headerlink" href="#class-type" title="Permalink to this headline">¶</a></h3>
<p>Some of the built-in types are class types, they are <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">map</span></code> and
<code class="docutils literal notranslate"><span class="pre">range</span></code>. Unlike custom types, built-in class types can be constructed
using literals, for example <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> is a literal of type <code class="docutils literal notranslate"><span class="pre">list</span></code>.</p>
<section id="list">
<h4>List<a class="headerlink" href="#list" title="Permalink to this headline">¶</a></h4>
<p>The List class is a container that provides support for list data types.
Berry’s list is an ordered collection of elements, and each element in
the list has a unique integer index, and each element can be accessed
directly according to the index. List supports inserting or deleting
elements at any position, and the element can be of any type. In
addition to using indexes, you can also use iterators to access elements
in the list.</p>
<p>The implementation of List is a dynamic array, and this data structure
has good random access performance. The efficiency of adding and
deleting elements at the end of the list is very high, but the
efficiency of adding and deleting elements in the middle of the list is
low.</p>
<p>The literal initialization method of the List container is to use a list
of objects surrounded by square brackets, and multiple objects are
separated by commas, for example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="p">[]</span><span class="w"></span>
<span class="p">[</span><span class="s1">&#39;string&#39;</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;list&#39;</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Operations: see chapter 7.</p>
</section>
<section id="map">
<h4>Map<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h4>
<p>Map is also a kind of container, map is a collection of key-value pairs,
and each possible key appears at most once in the collection. The Map
container provides the following basic operations:</p>
<ul class="simple">
<li><p>Add key-value pairs to the collection</p></li>
<li><p>Remove key-value pairs from the collection</p></li>
<li><p>Modify the value corresponding to an existing key</p></li>
<li><p>Find the corresponding value by key</p></li>
</ul>
<p>Map is implemented using a hash table and has high search efficiency.
The operation of adding and deleting key-value pairs will consume more
time if “re-hashing” occurs.</p>
<p>The Map container can also be initialized using literal values, written
in curly braces to enclose a list of key-value pairs, separated by
colons between keys and values, and separated by commas between
key-value pairs. E.g:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="p">{}</span><span class="w"></span>
<span class="p">{</span><span class="s1">&#39;str&#39;</span><span class="o">:</span><span class="s1">&#39;hello&#39;</span><span class="p">}</span><span class="w"></span>
<span class="p">{</span><span class="s1">&#39;str&#39;</span><span class="o">:</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span><span class="s1">&#39;int&#39;</span><span class="o">:</span><span class="w"> </span><span class="mi">45</span><span class="p">,</span><span class="w"> </span><span class="mi">78</span><span class="o">:</span><span class="w"> </span><span class="kc">nil</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Operations: see chapter 7.</p>
</section>
<section id="range">
<h4>Range<a class="headerlink" href="#range" title="Permalink to this headline">¶</a></h4>
<p>The Range container represents an integer range, which is usually used
to iterate in an integer range. This type has a <code class="docutils literal notranslate"><span class="pre">__lower__</span></code> member and
<code class="docutils literal notranslate"><span class="pre">__upper__</span></code> member, which represent the lower and upper bounds of the
range, respectively. The literal value of Range is a pair of integers
connected using the <code class="docutils literal notranslate"><span class="pre">..</span></code> operator:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="mi">-5</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
</pre></div>
</div>
<p>When the Range class is used for iteration, the elements of the
iteration are all integer values from the lower bound to the upper
bound, including boundary values. For example, the iteration result of
<code class="docutils literal notranslate"><span class="pre">0..5</span></code> is:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
</pre></div>
</div>
<p>Therefore, it should be noted that for a range of <em>x</em> .. (<em>x</em>+<em>n</em>), the
number of iterations is <em>n</em> + 1. A common construct to iterate through elements of a list by item is:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="ow">for</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="nb">size</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="mi">-1</span><span class="w"></span>
</pre></div>
</div>
<p>Open range: if you omit the last range, it is implicitly replaced with MAXINT.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="o">..</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="nf">r</span><span class="w"></span>
<span class="p">(</span><span class="mi">10</span><span class="o">..</span><span class="mi">9223372036854775807</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="bytes">
<h4>Bytes<a class="headerlink" href="#bytes" title="Permalink to this headline">¶</a></h4>
<p>Bytes object denote a bytes buffer which can be used to manipulate bytes
buffers or to read/write some C memory areas or structures.</p>
<p>See Chapter 7.</p>
</section>
</section>
</section>
<section id="variables">
<h2>2.2 Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h2>
<p>A variable is a storage space with a name, and the data or information
stored in the storage space is called the value of the variable.
Variable names are used to refer to variables in source code. In
different scopes, a variable name can bind multiple independent
variables, but variables have no aliases. The value of the variable can
be accessed or changed at any time during the running of the program.
Berry is a dynamically typed language, so the type of variable value is
determined at runtime, and the variable can store any type of value.</p>
<section id="define-variables">
<h3>2.2.1 define variables<a class="headerlink" href="#define-variables" title="Permalink to this headline">¶</a></h3>
<p>The first way to define a variable is to use an assignment statement to
assign a value to a new variable name:</p>
<div class="algorithm">
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>’var’ = expression
</pre></div>
</div>
</div>
<p><strong>variable</strong> is the name of the variable,
and the variable name is an identifier (see section
identifier).
<strong>expression</strong> is the expression to
initialize the variable.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;str&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>However, this method of defining variables has some limitations. Take
the following code as an example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="ow">do</span><span class="w"></span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 1</span>
<span class="ow">end</span><span class="w"></span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 1</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">do</span></code> statement in the routine constitutes the inner scope. We
modified the value of the variable <code class="docutils literal notranslate"><span class="pre">i</span></code> at line 3, and the value of <code class="docutils literal notranslate"><span class="pre">i</span></code>
is still <code class="docutils literal notranslate"><span class="pre">1</span></code> after leaving the inner scope at line 6 . If we want the
variable <code class="docutils literal notranslate"><span class="pre">i</span></code> of the inner scope to be an independent variable, the
method of defining the variable by directly assigning to the new
variable name cannot meet the requirement, because the identifier <code class="docutils literal notranslate"><span class="pre">i</span></code>
already exists in the outer scope. In this case, the variable can be
defined by the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword:</p>
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>’var’ variable
’var’ variable = expression
</pre></div>
</div>
<p>There are two ways of using <code class="docutils literal notranslate"><span class="pre">var</span></code> to define a variable: The first is to
follow the variable name <strong>variable</strong> after
the keyword <code class="docutils literal notranslate"><span class="pre">var</span></code>, in this case the variable will be initialized to
<code class="docutils literal notranslate"><span class="pre">nil</span></code>, and the other is written in The variable is initialized at the
same time as the variable is defined. In this case, an initial value
expression <strong>expression</strong> is
required. Using <code class="docutils literal notranslate"><span class="pre">var</span></code> to define a variable has two possible results: if
the current scope does not define the variable of
<strong>variable</strong>, define and initialize the
variable, otherwise it is equivalent to reinitialize the variable.
Therefore, the variable defined with <code class="docutils literal notranslate"><span class="pre">var</span></code> will shield the variable with
the same name in the outer scope.</p>
<p>Now we change the previous example to use the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword to define
variables:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="ow">do</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 1</span>
<span class="ow">end</span><span class="w"></span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 0</span>
</pre></div>
</div>
<p>From the modified routine, it can be found that the value of the
variable <code class="docutils literal notranslate"><span class="pre">i</span></code> in the inner scope is <code class="docutils literal notranslate"><span class="pre">1</span></code>, and its value in the outer scope
is <code class="docutils literal notranslate"><span class="pre">0</span></code>. This proves that after using the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword, a new variable
<code class="docutils literal notranslate"><span class="pre">i</span></code> is defined in the inner scope and the variable with the same name in
the outer scope is blocked. After the inner scope ends, the identifier
<code class="docutils literal notranslate"><span class="pre">i</span></code> is once again bound to the variable <code class="docutils literal notranslate"><span class="pre">i</span></code> in the outer scope.</p>
<p>When using the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword to define a variable, you can also use a
list of multiple variable names, separated by commas. You can also
initialize one or more variables when defining variables:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;test&#39;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="scope-and-life-cycle">
<h3>2.2.2 Scope and Life Cycle<a class="headerlink" href="#scope-and-life-cycle" title="Permalink to this headline">¶</a></h3>
<p>As mentioned earlier, variable names can be bound to multiple variable
entities (storage spaces), and variable names are bound to only one
entity at each position. The entity bound by the variable name needs to
be determined according to the position where the variable name appears.</p>
<p><strong>Scope</strong> refers to the code area where the name and the entity
are uniquely bound. Outside the scope, the name may be bound to other
entities, or not bound to any entity. The entity is only visible in the
scope bound to the name, that is, the variable is only valid in its
scope.A code block (see block)
is a scope. A variable is only available inside the block, and names in
different blocks may bind different variable entities. The following
example demonstrates the scope of variables:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="ow">do</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;str&#39;</span><span class="w"></span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="c1"># 0 str</span>
<span class="ow">end</span><span class="w"></span>
<span class="c1"># The variable j is not available here</span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 0</span>
</pre></div>
</div>
<p>The names <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> are defined in this routine. The name <code class="docutils literal notranslate"><span class="pre">i</span></code> is
defined outside the <code class="docutils literal notranslate"><span class="pre">do</span></code> sentence, and the name defined in the outermost
block has <strong>Global scope</strong> (global scope). The name with global scope is
available in the entire program after customization. The name <code class="docutils literal notranslate"><span class="pre">j</span></code> is
defined in the block in the <code class="docutils literal notranslate"><span class="pre">do</span></code> sentence, and the name of this type of
definition in the non-outermost block has <strong>Local scope</strong> (local scope).
A name with a local scope cannot be accessed outside the scope.</p>
<p>Berry has some built-in objects, which are all in the global scope.
However, built-in objects and global variables defined in scripts are
not in the same global scope. Built-in objects actually belong to
<strong>Built-in scope</strong> (built-in scope). The scope is globally visible as
the ordinary global scope, but can be covered by the ordinary global
scope. Built-in objects include functions and classes in the standard
library. These objects include <code class="docutils literal notranslate"><span class="pre">print</span></code> functions, <code class="docutils literal notranslate"><span class="pre">type</span></code> functions, and
<code class="docutils literal notranslate"><span class="pre">map</span></code> classes. Different from other scopes, the variables in the
built-in scope are read-only, so “assignment” to the variables in the
built-in scope actually defines a variable with the same name in the
global scope, which overrides The symbols in the built-in scope.</p>
<section id="nested-scope">
<h4>nested scope<a class="headerlink" href="#nested-scope" title="Permalink to this headline">¶</a></h4>
<p>Nested scope means that the scope contains another scope. We call the
contained scope <strong>Inner scope</strong>, and the scope that contains the inner
scope <strong>Outer scope</strong>. The name defined in the outer scope can be
accessed in all inner scopes. The inner scope can also rebind the name
already defined in the outer scope. The previous example using <code class="docutils literal notranslate"><span class="pre">var</span></code> to
define variables describes this scenario.</p>
</section>
<section id="variable-life-cycle">
<h4>Variable Life Cycle<a class="headerlink" href="#variable-life-cycle" title="Permalink to this headline">¶</a></h4>
<p>There is no concept of variable names when the program is running, and
variables exist in the form of entities at this time. The “validity
period” of a variable during program execution is the variable’s <strong>Life
cycle</strong>. Variables at runtime are only valid within the scope. After
leaving the scope, the variables will be destroyed to reclaim resources.</p>
<p>Variables defined in the global scope are called <strong>Global variable</strong> and
have <strong>Static life cycle</strong>. Such variables can be accessed during the
entire program running and will not be destroyed. Variables defined in
the local scope are called <strong>Local variable</strong> and have <strong>Dynamic life
cycle</strong>. Such variables cannot be accessed after leaving the scope and
will be destroyed.</p>
<p>Due to the different life cycles, local variables and global variables
use different ways to allocate storage space. Local variables are
allocated on a structure called <strong>Stack</strong> (stack), and objects allocated
based on the stack can be quickly reclaimed at the end of the scope.
Global variables are allocated in <strong>Global table</strong> (global table).
Objects in the global table will not be recycled once they are created,
and the table can be accessed anywhere in the program.</p>
</section>
</section>
<section id="type-of-variable">
<h3>2.2.3 Type of variable<a class="headerlink" href="#type-of-variable" title="Permalink to this headline">¶</a></h3>
<p>Berry determines the type of the variable at runtime. In other words,
the variable can store any type of value. Therefore Berry is a <strong>Dynamic
typing</strong> language. The interpreter does not deduce the type of the
variable at compile time, which may cause some errors to be exposed at
runtime. For example, the error generated by executing the expression
<code class="docutils literal notranslate"><span class="pre">’1’</span> <span class="pre">+</span> <span class="pre">1</span></code> is a runtime error rather than a compiler error. The advantage
of using dynamic types is that many designs can be simplified, and the
program will be more flexible, not to mention the need to design a
complex type inference system.</p>
<p>Due to the lack of type checking by the interpreter, user code may need
to determine the type of value by itself, and this feature can also be
used to implement some special operations. This feature also makes
overloaded functions unnecessary. For example, the native function
<code class="docutils literal notranslate"><span class="pre">type</span></code> accepts any type of parameter and returns a string describing the
parameter type.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Chapter-1.html" class="btn btn-neutral float-left" title="Basic Information" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Chapter-3.html" class="btn btn-neutral float-right" title="3. Expression" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Guan Wenliang &amp; Stephan Hadinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9. FFI &mdash; berry 1.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> berry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">9. FFI</a><ul>
<li><a class="reference internal" href="#basics">9.1 Basics</a><ul>
<li><a class="reference internal" href="#virtual-machine">9.1.1 Virtual Machine</a></li>
<li><a class="reference internal" href="#virtual-stack">9.1.2 Virtual Stack</a></li>
<li><a class="reference internal" href="#operate-virtual-stack">Operate Virtual Stack</a><ul>
<li><a class="reference internal" href="#index-and-stack-size">Index and stack size</a></li>
<li><a class="reference internal" href="#get-value-from-stack">Get value from stack</a></li>
</ul>
</li>
<li><a class="reference internal" href="#native-function">Native function</a><ul>
<li><a class="reference internal" href="#define-native-function">Define native function</a></li>
<li><a class="reference internal" href="#use-native-function">Use native function</a></li>
<li><a class="reference internal" href="#complete-example">Complete example</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#types-and-functions">Types and Functions</a><ul>
<li><a class="reference internal" href="#type">Type</a></li>
<li><a class="reference internal" href="#functions-and-macros">Functions and Macros</a></li>
<li><a class="reference internal" href="#compile-time-construction-technology">Compile-time construction technology</a><ul>
<li><a class="reference internal" href="#use-command">Use command</a></li>
<li><a class="reference internal" href="#output-path">output path</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compile-time-string-table">Compile-time string table</a><ul>
<li><a class="reference internal" href="#use-constant-string">Use constant string</a></li>
</ul>
</li>
<li><a class="reference internal" href="#construct-object-at-compile-time">Construct object at compile time</a><ul>
<li><a class="reference internal" href="#construct-map-at-compile-time">Construct Map at Compile Time</a></li>
<li><a class="reference internal" href="#compile-time-construction-class">Compile-time construction class</a></li>
<li><a class="reference internal" href="#building-module-at-compile-time">Building Module at Compile Time</a></li>
<li><a class="reference internal" href="#construct-built-in-domain-at-compile-time">Construct Built-in Domain at Compile Time</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">berry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>9. FFI</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/en/Chapter-9.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ffi">
<h1>9. FFI<a class="headerlink" href="#ffi" title="Permalink to this headline">¶</a></h1>
<p><strong>Foreign Function Interface</strong> (FFI) is an interface for interaction
between different languages. Berry provides a set of FFI to realize the
interaction with C language, this set of interfaces is also very easy to
use in C++. Most of the FFI interfaces are functions, and their
declarations are placed in the <em>berry.h</em> file. In order to reduce the
amount of RAM used, FFI also provides a mechanism for generating a fixed
hash table during C compilation. This mechanism must use external tools
to generate C code.</p>
<section id="basics">
<h2>9.1 Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h2>
<p>The most important interactive function in FFI should be the function of
calling Berry code and C function mutually. In order to realize that two
languages call each other’s functions, we must first understand the
parameter passing mechanism of the Berry function.</p>
<section id="virtual-machine">
<h3>9.1.1 Virtual Machine<a class="headerlink" href="#virtual-machine" title="Permalink to this headline">¶</a></h3>
<p>Unlike compiled languages, Berry language cannot run directly on a
physical machine, but in a specific software environment, which is
<strong>Virtual Machine</strong> (VM). Similar to a real computer, the source code in
text form cannot be executed in a virtual machine, but must be converted
into “bytecode” by a compiler. The Berry virtual machine is defined as a
C structure <code class="docutils literal notranslate"><span class="pre">bvm</span></code>, the content of this structure is invisible to FFI.
Through some FFI functions, we can create and initialize a virtual
machine. We introduce the use of virtual machines through a simple
example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">berry_test</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_vm_new</span><span class="p">();</span><span class="w"> </span><span class="c1">// Construct a VM</span>
<span class="w">    </span><span class="n">be_loadstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;print(&#39;Hello Berry&#39;)&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Compile test code</span>
<span class="w">    </span><span class="n">be_pcall</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Call function</span>
<span class="w">    </span><span class="n">be_vm_delete</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Destroy the VM</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This code gives a complete example of using a virtual machine. First,
call the function <code class="docutils literal notranslate"><span class="pre">be_vm_new</span></code> to construct a new virtual machine, and
then all operations are completed in this virtual machine object.
<code class="docutils literal notranslate"><span class="pre">be_vm_new</span></code> The function will automatically link the standard library
when creating a virtual machine. The function of lines 4 to 5 is to
compile the source code in a string into a Berry function and then call
it. Finally, call the <code class="docutils literal notranslate"><span class="pre">be_vm_delete</span></code> function on line 6 to destroy the
virtual machine. Executing this function will get a line of output in
the terminal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Hello</span> <span class="n">Berry</span>
</pre></div>
</div>
<p>In all scenarios, the virtual machine construction, library loading and
destruction process are the same as the 3rd, 4th and 6th lines in the
above example. If necessary, the way to compile or load the source code
may be different. For example, for the source code in the form of a
file, it can be compiled through the <code class="docutils literal notranslate"><span class="pre">be_loadfile</span></code> function. The source
code will be compiled into a Berry function, and the function will be
stored on the top of the stack. The Berry function can be executed by
calling the FFI function <code class="docutils literal notranslate"><span class="pre">be_pcall</span></code> or <code class="docutils literal notranslate"><span class="pre">be_call</span></code>. You can also use the
REPL through the <code class="docutils literal notranslate"><span class="pre">be_repl</span></code> function. The interface of the REPL will be
described in the relevant chapters.</p>
</section>
<section id="virtual-stack">
<h3>9.1.2 Virtual Stack<a class="headerlink" href="#virtual-stack" title="Permalink to this headline">¶</a></h3>
<p>Berry uses a virtual stack and native functions written in C to pass
values. Each element in the stack is a Berry value. When Berry code
calls a native function, it always creates a new stack and pushes all
the parameters onto the stack. This virtual stack can also be used in C
code to store data, and the value stored in the stack will not be
reclaimed by the garbage collector.</p>
<p><img alt="Virtual_Stack" src="https://user-images.githubusercontent.com/49731213/135971121-059e665c-7f65-4a6a-bbe4-da9acf4cf8b5.png" /></p>
<p>The virtual stack used by Berry is shown in Figure above.</p>
<p>The virtual stack grows from left to right. When Berry code calls a
native function, it will get an initial stack. The position of the first
value of the stack is called <strong>base</strong>, and the last position is called
<strong>top</strong>, the native function Only the value from the bottom of the stack
to the position before the top of the stack can be accessed. The
position of the bottom of the stack is fixed, while the position of the
top of the stack can be moved, and the top of the stack is always empty.
The reason for this property is that after the new value is pushed into
the virtual stack, the original position of the top of the stack will be
written The new value, the top pointer of the stack will move forward to
the next position; conversely, if the value at the top of the virtual
stack is popped, the top pointer of the stack will decrease 1. At this
time, although the position of the top pointer of the stack is
objectively Value, but this value is invalid and may be cleared at any
time, so the pointer position on the top of the stack is still empty.
When the virtual stack is empty, the bottom pointer <code class="docutils literal notranslate"><span class="pre">base</span></code> is equal to
the top pointer <code class="docutils literal notranslate"><span class="pre">top</span></code>. The virtual stack does not strictly follow the
operating rules of the stack: in addition to push and pop, the virtual
stack can also be accessed by index, and even insert or delete values at
any position. There are two ways to index elements in the stack: one is
based on the bottom of the stack <strong>Absolute index</strong>, the absolute index
value is a positive integer starting from 1; the other is based on the
top of the stack <strong>Relative index</strong>, The relative index value is a
negative integer starting from  − 1. Take Figure above
as an example, the index value 1, 2…8 is an absolute index, and the
absolute index of an element is the distance from the element to the
bottom of the stack. The index value  − 1,  − 2… − 8 is a relative
index, and the relative index value of an element is the negative number
of the distance from the element to the top of the stack. If an index
value <em>index</em> is valid, then the element it refers to should be
between the bottom of the stack and the top of the stack, which means
that the expression</p>
<p><code class="docutils literal notranslate"><span class="pre">1 ≤ abs(*index*) ≤ *top*</span> <span class="pre">− *base* + 1</span></code> is satisfied.</p>
<p>For convenience, we stipulate that the stack bottom pointer <code class="docutils literal notranslate"><span class="pre">base</span></code> is
used as a reference, and its absolute index 1, and the previous value of
<code class="docutils literal notranslate"><span class="pre">base</span></code> is not considered (usually, <code class="docutils literal notranslate"><span class="pre">base</span></code> is not the bottom position of
the entire stack). For example, when a native function returns, the
location where the return value is stored is just before <code class="docutils literal notranslate"><span class="pre">base</span></code>, and
these locations are usually not accessible by the native function.</p>
</section>
<section id="operate-virtual-stack">
<h3>Operate Virtual Stack<a class="headerlink" href="#operate-virtual-stack" title="Permalink to this headline">¶</a></h3>
<section id="index-and-stack-size">
<h4>Index and stack size<a class="headerlink" href="#index-and-stack-size" title="Permalink to this headline">¶</a></h4>
<p>As mentioned earlier, two indexing methods can be used to access the
virtual stack, and the index value must be valid. At the same time, in
many cases it is also necessary to push new values onto the stack. In
this case, the programmer must ensure that the stack will not overflow.
By default, Berry guarantees <code class="docutils literal notranslate"><span class="pre">BE_STACK_FREE_MIN</span></code> space for native
functions to use. This value can be modified in the file <em>berry.h</em>. Its
default value is usually 10, which should be sufficient in most cases.
If you really need to expand the stack, you can call the FFI function
<code class="docutils literal notranslate"><span class="pre">be_stack_require</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_stack_require</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">count</span></code> is the amount of space needed. When the remaining
space in the virtual stack is insufficient, the stack capacity will be
expanded, otherwise this function will do nothing.</p>
<p><strong>caveat</strong>: If a stack overflow occurs, or if an invalid index is used
to access the stack, the program will crash. You can turn on the
debugging switch <code class="docutils literal notranslate"><span class="pre">BE_DEBUG</span></code> (section
<a href="#section::BE_DEBUG" data-reference-type="ref" data-reference="section::BE_DEBUG">[section::BE_DEBUG]</a>),
which will turn on the assertion function, and you can get some
debugging information at runtime to catch errors such as stack overflow
or invalid index.</p>
</section>
<section id="get-value-from-stack">
<h4>Get value from stack<a class="headerlink" href="#get-value-from-stack" title="Permalink to this headline">¶</a></h4>
<p>There is a set of functions in FFI to get values from the virtual stack.
These functions usually convert the values in the stack into simple
values supported by the C language and then return. The following are
commonly used FFIs to get values from the stack:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bint</span><span class="w"> </span><span class="nf">be_toint</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="n">breal</span><span class="w"> </span><span class="nf">be_toreal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">be_tobool</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tostring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tocomptr</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter form of these functions is the same, but the return value
is different. The first four functions are easy to understand. Just like
their names, the function of <code class="docutils literal notranslate"><span class="pre">be_toint</span></code> is to convert the values in the
virtual stack to C integer values (<code class="docutils literal notranslate"><span class="pre">bint</span></code> is usually an alias of type
<code class="docutils literal notranslate"><span class="pre">int</span></code>) and return. The function of the last function <code class="docutils literal notranslate"><span class="pre">be_tocomptr</span></code> is to
take out a pointer value of a general type from the virtual stack. The
specific meaning of this pointer is explained by the C program itself.</p>
<p>These functions use the same way to interpret the parameters: the
parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance; <code class="docutils literal notranslate"><span class="pre">index</span></code>
is the index of the element to be retrieved, which can be a relative
index or an absolute index. You cannot use FFI to remove Berry’s complex
data types from the virtual stack, so you cannot remove a <code class="docutils literal notranslate"><span class="pre">map</span></code> type or
<code class="docutils literal notranslate"><span class="pre">class</span></code> type from the stack. One of the benefits of this design is that
there is no need to consider garbage collection in native functions.</p>
</section>
</section>
<section id="native-function">
<h3>Native function<a class="headerlink" href="#native-function" title="Permalink to this headline">¶</a></h3>
<p><strong>Native function</strong> It is implemented by C language and can be called by
Berry code. The native function can be an ordinary function. In this
case, calling the native function will not generate any dynamically
allocated space, just like a normal C function call. Native functions
can also be closures, and space needs to be allocated for free variables
when creating native closures. Under normal circumstances, simple native
functions are sufficient to meet the needs. They save resources than
native closures and are easier to use.</p>
<section id="define-native-function">
<h4>Define native function<a class="headerlink" href="#define-native-function" title="Permalink to this headline">¶</a></h4>
<p>The native function itself is a C function, but they all have a specific
form. The definition of the native function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">a_native_function</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// do something ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The native function must be a C function whose parameter is a pointer to
<code class="docutils literal notranslate"><span class="pre">bvm</span></code> and the return value is <code class="docutils literal notranslate"><span class="pre">int</span></code>. Berry’s functions must return a
value, and native functions are no exception. Unlike the return value of
the C language, the return value of the native function is not the value
carried by the C <code class="docutils literal notranslate"><span class="pre">return</span></code> statement. You can use these FFIs to return
the value of the native function, and they also make the C function
return:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_return</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
<span class="n">be_return_nil</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>These FFIs are actually two macros, and there is no need to use the C
<code class="docutils literal notranslate"><span class="pre">return</span></code> statement when using them. <code class="docutils literal notranslate"><span class="pre">be_return</span></code> Will put the top of the
virtual stack</p>
</section>
<section id="use-native-function">
<h4>Use native function<a class="headerlink" href="#use-native-function" title="Permalink to this headline">¶</a></h4>
<p>After the native function is defined, it must be added to the
interpreter in some way before it can be called in Berry code. One of
the easiest ways is to add native functions to Berry’s built-in object
table. The process of setting native objects as Berry built-in objects
is called <strong>registered</strong>. The FFI of the registered native function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_regfunc</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">bntvfunc</span><span class="w"> </span><span class="n">f</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">vm</span></code> is the current virtual machine instance, <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of the
native function, and <code class="docutils literal notranslate"><span class="pre">f</span></code> is the pointer of the native function. The
specific behavior of this function is related to the value of the
<code class="docutils literal notranslate"><span class="pre">BE_USE_PRECOMPILED_OBJECT</span></code> macro (although the FFI is still available
when using the compile-time construction technique, it cannot
dynamically register the built-in variables. In this case, please refer
to the method of registering the built-in objects.
<a href="#section::precompiled_build" data-reference-type="ref" data-reference="section::precompiled_build">1.3</a>).
The definition of native function type <code class="docutils literal notranslate"><span class="pre">bntvfunc</span></code> is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">bntvfunc</span><span class="p">)(</span><span class="n">bvm</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In fact, the <code class="docutils literal notranslate"><span class="pre">bntvfunc</span></code> type is the function pointer type with the
parameter <code class="docutils literal notranslate"><span class="pre">bvm</span></code> and the return value type <code class="docutils literal notranslate"><span class="pre">int</span></code>. <code class="docutils literal notranslate"><span class="pre">be_regfunc</span></code> The
function should be called before parsing the Berry source code.</p>
<p>You can also push the native function into the virtual stack, and then
use an FFI function <code class="docutils literal notranslate"><span class="pre">be_call</span></code> to call it. A more common usage is to use
the native function object in the virtual stack as the return value.</p>
</section>
<section id="complete-example">
<h4>Complete example<a class="headerlink" href="#complete-example" title="Permalink to this headline">¶</a></h4>
<p>We end this section with a simple example. Here, we are going to
implement a <code class="docutils literal notranslate"><span class="pre">add</span></code> function that adds two numbers and returns the result
of the calculation. First, we define a native function to implement this
function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">l_add</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_top</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Get the number of arguments</span>
<span class="w">    </span><span class="cm">/* Verify the number and type of arguments */</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">be_isnumber</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">be_isnumber</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">breal</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_toreal</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Get the first argument</span>
<span class="w">        </span><span class="n">breal</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_toreal</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// Get the second argument</span>
<span class="w">        </span><span class="n">be_pushreal</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// Push the result onto the stack</span>
<span class="w">        </span><span class="n">be_return</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Return the value at the top of the stack</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">be_return_nil</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Return nil when something goes wrong</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Native functions usually do not need to be used outside the C file, so
they are generally declared as <code class="docutils literal notranslate"><span class="pre">static</span></code> types. Use the <code class="docutils literal notranslate"><span class="pre">be_top</span></code> function
to get the absolute index of the top of the virtual stack (<code class="docutils literal notranslate"><span class="pre">top</span></code> value),
which is the capacity of the stack. We can call <code class="docutils literal notranslate"><span class="pre">be_top</span></code> before the
native function performs the virtual stack operation, at this time the
virtual stack capacity is equal to the real parameter amount. For the
<code class="docutils literal notranslate"><span class="pre">add</span></code> function, we need two parameters to participate in the operation,
so check whether the number of parameters is 2 in the fourth line
(<code class="docutils literal notranslate"><span class="pre">top</span> <span class="pre">==</span> <span class="pre">2</span></code>). And we need to check whether the two parameters are both
numeric types, so we need to call the <code class="docutils literal notranslate"><span class="pre">be_isnumber</span></code> function to check.
If everything is correct, the parameters will be taken out of the
virtual stack, then the calculation result will be pushed onto the
stack, and finally returned using <code class="docutils literal notranslate"><span class="pre">be_return</span></code>. If the parameter
verification fails, <code class="docutils literal notranslate"><span class="pre">be_return_nil</span></code> will be called to return the value
of <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>Next, register this native function to the built-in object table. For
simplicity, we register it after loading the library:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_vm_new</span><span class="p">();</span><span class="w"> </span><span class="c1">// Construct a VM</span>
<span class="n">be_regfunc</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;myadd&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">l_add</span><span class="p">);</span><span class="w"> </span><span class="c1">// Register the native function &quot;myadd&quot;</span>
</pre></div>
</div>
<p>The second line is where the native function is registered, and we named
it <code class="docutils literal notranslate"><span class="pre">myadd</span></code>. At this point, the definition and registration of the native
function is complete. As a verification, you can compile the
interpreter, then enter the REPL and run some tests. You should get
results like this:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="n">myadd</span><span class="w"></span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">:</span><span class="w"> </span><span class="mh">0x562a210f0f90</span><span class="o">&gt;</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="nf">myadd</span><span class="p">(</span><span class="mi">1</span><span class="mf">.0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="mf">.5</span><span class="p">)</span><span class="w"></span>
<span class="mi">3</span><span class="mf">.5</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="nf">myadd</span><span class="p">(</span><span class="mi">2</span><span class="mf">.5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="mi">4</span><span class="mf">.5</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="nf">myadd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="mi">3</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="types-and-functions">
<h2>Types and Functions<a class="headerlink" href="#types-and-functions" title="Permalink to this headline">¶</a></h2>
<section id="type">
<h3>Type<a class="headerlink" href="#type" title="Permalink to this headline">¶</a></h3>
<p>This section will introduce some types that need to be used in FFI.
These types are generally used by FFI functions. Generally, the types
and declarations in FFI can be found in the <em>berry.h</em> file. Unless
otherwise specified in this section, the definition or declaration is
provided in <em>berry.h</em> by default.</p>
<p><code class="docutils literal notranslate"><span class="pre">bvm</span></code> Type is used to store the state information of the Berry virtual
machine. Details of this type are not visible to external programs.
Therefore, this definition can only be found in the <em>berry.h</em> file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">bvm</span><span class="w"> </span><span class="n">bvm</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Most FFI functions use the <code class="docutils literal notranslate"><span class="pre">bvm</span></code> type as the first parameter, because
they all operate on the virtual machine internally. Hiding the internal
implementation of <code class="docutils literal notranslate"><span class="pre">bvm</span></code> helps reduce the coupling between the FFI
standard and the VM. Outside the interpreter, usually only <code class="docutils literal notranslate"><span class="pre">bvm</span></code>
pointers are used. To create a new <code class="docutils literal notranslate"><span class="pre">bvm</span></code> object, use the <code class="docutils literal notranslate"><span class="pre">be_vm_new</span></code>
function, and destroy the <code class="docutils literal notranslate"><span class="pre">bvm</span></code> object using the <code class="docutils literal notranslate"><span class="pre">be_vm_delete</span></code>
function.</p>
<p>Native function type. The definition of this type is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">bntvfunc</span><span class="p">)(</span><span class="n">bvm</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This type is a native function pointer, and some FFIs that register or
add native functions to the virtual machine use parameters of this type.
Variables or parameters of this type need to be initialized with a
function name whose parameter is of type <code class="docutils literal notranslate"><span class="pre">bvm</span></code> and whose return value is
of type <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<p>This type is used when registering native functions in batches or
building native classes. It is defined as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="c1">// The name of the function or object</span>
<span class="w">    </span><span class="n">bntvfunc</span><span class="w"> </span><span class="n">function</span><span class="p">;</span><span class="w"> </span><span class="c1">// The function pointer</span>
<span class="p">}</span><span class="w"> </span><span class="n">bnfuncinfo</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> member of <code class="docutils literal notranslate"><span class="pre">bnfuncinfo</span></code> represents the name of a function or
object, and the <code class="docutils literal notranslate"><span class="pre">function</span></code> member is a native function pointer.</p>
<p>This type is a built-in integer type of Berry. It is defined in the
<em>berry.h</em> document. By default, <code class="docutils literal notranslate"><span class="pre">bint</span></code> is implemented using the
<code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> type, and the implementation of <code class="docutils literal notranslate"><span class="pre">bint</span></code> can be modified by
modifying the configuration file.</p>
<p>This is Berry’s built-in real number type, which is actually the
floating point type in C language. <code class="docutils literal notranslate"><span class="pre">breal</span></code> is defined as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#if BE_SINGLE_FLOAT != 0</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">breal</span><span class="p">;</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">breal</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>You can use the macro <code class="docutils literal notranslate"><span class="pre">BE_SINGLE_FLOAT</span></code> to control the specific
implementation of <code class="docutils literal notranslate"><span class="pre">breal</span></code>: when the value of <code class="docutils literal notranslate"><span class="pre">BE_SINGLE_FLOAT</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code>,
the <code class="docutils literal notranslate"><span class="pre">double</span></code> type implementation <code class="docutils literal notranslate"><span class="pre">breal</span></code> will be used, otherwise the
<code class="docutils literal notranslate"><span class="pre">float</span></code> type implementation <code class="docutils literal notranslate"><span class="pre">breal</span></code> will be used.</p>
<p><span id="section::errorcode"
label="section::errorcode">[section::errorcode]</span></p>
<p>This enumeration type is used in some FFI return values. The definition
of this type is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">berrorcode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_OK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_IO_ERROR</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_SYNTAX_ERROR</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_EXEC_ERROR</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_MALLOC_FAIL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_EXIT</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The meaning of these enumeration values are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BE_OK</span></code>: There is no error, the function is executed successfully.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_IO_ERROR</span></code>: A file reading error occurred when the interpreter
was reading the source file. The error is generally caused by the
absence of the file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_SYNTAX_ERROR</span></code>: A syntax error occurred when the interpreter was
compiling the source code. After this error occurs, the interpreter
will not generate bytecode, so it cannot continue to execute
bytecode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_EXEC_ERROR</span></code>: Runtime error. When this error occurs, execution of
Berry code is stopped and the environment is restored to the most
recent recovery point.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_MALLOC_FAIL</span></code>: Memory allocation failed. This error is caused by
insufficient heap space.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_EXIT</span></code>: Indicates that the program exits and the enumeration
value is not an error. Executing Berry’s <code class="docutils literal notranslate"><span class="pre">exit</span></code> function causes the
interpreter to return this value.</p></li>
</ul>
<p>It should be noted that when a <code class="docutils literal notranslate"><span class="pre">BE_MALLOC_FAIL</span></code> error occurs, dynamic
memory allocation can no longer be performed, which means that string
objects can no longer be allocated, so the function that returns this
error usually does not give more detailed error information.</p>
</section>
<section id="functions-and-macros">
<h3>Functions and Macros<a class="headerlink" href="#functions-and-macros" title="Permalink to this headline">¶</a></h3>
<p>This function is used to create a new virtual machine instance. The
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bvm</span><span class="o">*</span><span class="w"> </span><span class="nf">be_vm_new</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The return value of the function is a pointer to the virtual machine
instance. <code class="docutils literal notranslate"><span class="pre">be_vm_new</span></code> The number is the first function called when the
Berry interpreter is created. This function will do a lot of work: apply
for memory for the virtual machine, initialize the state and attributes
of the virtual machine, initialize the GC (garbage collector), and The
standard library is loaded into the virtual machine instance, etc.</p>
<p>This function is used to destroy a virtual machine instance, the
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_vm_delete</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine object to be
destroyed. Destroying the virtual machine will release all the objects
in the virtual machine, including the values in the stack and the
objects managed by the GC. The virtual machine pointer after destruction
will be an invalid value, and it can no longer be referenced.</p>
<p>This function is used to load a piece of source code from the buffer and
compile it into bytecode. The prototype of the function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_loadbuffer</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the virtual machine pointer. <code class="docutils literal notranslate"><span class="pre">name</span></code> is a string,
which is usually used to mark the source of the source code. For
example, the source code input from the standard input device can pass
the string <code class="docutils literal notranslate"><span class="pre">&quot;stdin&quot;</span></code> to this parameter, and the source code input from
the file can be The file name is passed to this parameter. <code class="docutils literal notranslate"><span class="pre">buffer</span></code> The
parameter is the buffer for storing the source code. The organization of
this buffer is very similar to the string of C. It is a continuous
sequence of characters, but the buffer pointed to by <code class="docutils literal notranslate"><span class="pre">buffer</span></code> does not
require <code class="docutils literal notranslate"><span class="pre">’\0’</span></code> characters as Terminator. <code class="docutils literal notranslate"><span class="pre">length</span></code> The parameter
indicates the length of the buffer. This length refers to the number of
bytes of source code text in the buffer.</p>
<p>To give a simple example, if we want to use the <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> function
to compile a string, the general usage is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;print(&#39;Hello Berry&#39;)&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">be_loadbuffer</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;string&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>Here we use the string <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> to represent the source code, you can
also modify it to any value. Note that the C standard library function
<code class="docutils literal notranslate"><span class="pre">strlen</span></code> function is used here to get the length of the string buffer
(actually the number of bytes in the string).</p>
<p>If the compilation is successful, <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> will compile the
source code into a Berry function and place it on the top of the virtual
stack. If the compilation encounters an error, <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> will
return an error value of type <code class="docutils literal notranslate"><span class="pre">berrorcode</span></code> (Section
errorcode,
and if possible, will store the specific error message string at the top
of the virtual stack.</p>
<p><code class="docutils literal notranslate"><span class="pre">be_loadstring</span></code> is a macro defined as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define be_loadstring(vm, str) be_loadbuffer((vm), &quot;string&quot;, (str), strlen(str))</span>
</pre></div>
</div>
<p>This macro is just a simple wrapper for the <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> function.
<code class="docutils literal notranslate"><span class="pre">vm</span></code> The parameter is a pointer to the virtual machine instance, and the
<code class="docutils literal notranslate"><span class="pre">str</span></code> parameter is a pointer to the source code string. It is very
convenient to use <code class="docutils literal notranslate"><span class="pre">be_loadstring</span></code> to compile strings, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_loadstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;print(&#39;Hello Berry&#39;)&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This way of writing is more concise than using <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code>, but you
must ensure that the string ends with a <code class="docutils literal notranslate"><span class="pre">’\0’</span></code> character.</p>
<p>This function is used to compile a source code file. The function
prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_loadfile</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The function of this function is similar to the <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code>
function, except that the function will be compiled by reading the
source code file. The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual
machine instance, and the parameter <code class="docutils literal notranslate"><span class="pre">name</span></code> is the file name of the
source file. This function will call the file interface, and by default
it will use functions such as <code class="docutils literal notranslate"><span class="pre">fopen</span></code> in the C standard library to
manipulate files.</p>
<p>If you use the file interface of the C standard library, you can use
relative path or absolute path file names. If the file does not exist,
<code class="docutils literal notranslate"><span class="pre">be_loadfile</span></code> will return a <code class="docutils literal notranslate"><span class="pre">BE_IO_ERROR</span></code> error (section
errorcode)
and push the error message onto the top of the stack. Other error
messages are the same as the <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> function. It is recommended
to use the <code class="docutils literal notranslate"><span class="pre">be_loadfile</span></code> function to compile the source file, instead of
reading all the source files into a buffer, and then call the
<code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> function to compile the source code. The former will
read the source file in segments and only create a small read buffer in
the memory, thus saving more memory.</p>
<p>This function returns the absolute index value of the top element in the
virtual stack. This value is also the number of elements in the virtual
stack (the capacity of the virtual stack). Call this function before
adding or subtracting elements in the virtual stack to get the number of
parameters of the native function. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_top</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This function is usually used to obtain the number of parameters of a
native function. When used for this purpose, it is recommended to call
<code class="docutils literal notranslate"><span class="pre">be_top</span></code> at the top of the native function body. E.g:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">native_function_example</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_top</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Get the number of arguments</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This function converts the type of the Berry object into a string and
returns it. For example, it returns <code class="docutils literal notranslate"><span class="pre">&quot;int&quot;</span></code> for an integer object, and
<code class="docutils literal notranslate"><span class="pre">&quot;function&quot;</span></code> for a function object. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_typename</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the object to be operated. The <code class="docutils literal notranslate"><span class="pre">type</span></code> function
in the Berry standard library is implemented by calling <code class="docutils literal notranslate"><span class="pre">be_typename</span></code>.
Please refer to section
baselib_type
for the return string corresponding to the parameter type.</p>
<p>This function is used to get the class name of an object or class. The
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_classname</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the object to be operated. If the value at
<code class="docutils literal notranslate"><span class="pre">index</span></code> is an instance, the <code class="docutils literal notranslate"><span class="pre">be_classname</span></code> function will return the
class name string to which the instance belongs, and if the value at
<code class="docutils literal notranslate"><span class="pre">index</span></code> is a class, it will directly return the class name string. In
other cases <code class="docutils literal notranslate"><span class="pre">be_classname</span></code> will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>This function returns the length of the specified Berry string. The
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_strlen</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the object to be operated. This function returns
the number of bytes in the string at <code class="docutils literal notranslate"><span class="pre">index</span></code> (the <code class="docutils literal notranslate"><span class="pre">’\0’</span></code> characters at
the end of the Berry string are not counted). If the value of the
<code class="docutils literal notranslate"><span class="pre">index</span></code> position is not a string, the <code class="docutils literal notranslate"><span class="pre">be_strlen</span></code> function will return
<code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Although the <code class="docutils literal notranslate"><span class="pre">Berry</span></code> string is compatible with the C string format, it
is not recommended to use the <code class="docutils literal notranslate"><span class="pre">strlen</span></code> function of the C standard
library to measure the length of the Berry string. For Berry strings,
<code class="docutils literal notranslate"><span class="pre">be_strlen</span></code> is faster than <code class="docutils literal notranslate"><span class="pre">strlen</span></code> and has better compatibility.</p>
<p>This function is used to splice two Berry strings. The function
prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_strconcat</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance. This
function will concatenate the string at the parameter position of
<code class="docutils literal notranslate"><span class="pre">index</span></code> with the string at the top position of the stack, and then put
the resulting string into the position indexed by <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<p>This function pops the value at the top of the stack. The function
prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pop</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
the parameter <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of values to be popped from the stack.
Note that the value of <code class="docutils literal notranslate"><span class="pre">n</span></code> cannot exceed the capacity of the stack.</p>
<p>This function will remove a value from the stack. The function prototype
is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_remove</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the object to be removed. After
the value at <code class="docutils literal notranslate"><span class="pre">index</span></code> is moved out, the following values will be filled
forward, and the stack capacity will be reduced by one. The value of
<code class="docutils literal notranslate"><span class="pre">index</span></code> cannot exceed the capacity of the stack.</p>
<p>This function returns the absolute index value of a given index value,
and its function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_absindex</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code> is the input index value. If <code class="docutils literal notranslate"><span class="pre">index</span></code> is positive,
the return value of <code class="docutils literal notranslate"><span class="pre">be_absindex</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">index</span></code>. If <code class="docutils literal notranslate"><span class="pre">index</span></code> is
negative, the return value of textttbe_absindex is the absolute index
value corresponding to <code class="docutils literal notranslate"><span class="pre">index</span></code>. When <code class="docutils literal notranslate"><span class="pre">index</span></code> is a negative value
(relative index), its index position cannot be lower than the bottom of
the stack.</p>
<p>This function creates a new <code class="docutils literal notranslate"><span class="pre">list</span></code> value, and its function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_newlist</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance. After
this function is successfully called, the new <code class="docutils literal notranslate"><span class="pre">list</span></code> value will be
pushed onto the top of the stack. <code class="docutils literal notranslate"><span class="pre">list</span></code> value is an internal representation of a list, not to be confused with an instance of the <code class="docutils literal notranslate"><span class="pre">list</span></code> class.</p>
<p>This function creates a new <code class="docutils literal notranslate"><span class="pre">map</span></code> value, and its function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_newmap</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance. After
this function is successfully called, the new <code class="docutils literal notranslate"><span class="pre">map</span></code> value will be pushed
onto the top of the stack. <code class="docutils literal notranslate"><span class="pre">map</span></code> value is an internal representation of a list, not to be confused with an instance of the <code class="docutils literal notranslate"><span class="pre">map</span></code> class.</p>
<p>This function pushes the global variable with the specified name onto
the stack. Its function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getglobal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
the parameter <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of the global variable. After this
function is called, the global variable named <code class="docutils literal notranslate"><span class="pre">name</span></code> will be pushed onto
the top of the virtual stack.</p>
<p>This function is used to set the value of the member variable of the
instance object class. The function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_setmember</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, the
parameter <code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the instance object, and the parameter
<code class="docutils literal notranslate"><span class="pre">k</span></code> is the name of the member. This function will copy the value at the
top of the stack to the member <code class="docutils literal notranslate"><span class="pre">k</span></code> of the index position instance. Note
that the top element of the stack will not pop up automatically.</p>
<p>This function is used to get the value of the member variable of the
instance object class. The function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getmember</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, the
parameter <code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the instance object, and the parameter
<code class="docutils literal notranslate"><span class="pre">k</span></code> is the name of the member. This function pushes the value of the
member of the index position instance <code class="docutils literal notranslate"><span class="pre">k</span></code> onto the top of the virtual
stack.</p>
<p>This function is used to get the value of <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">map</span></code>. The function
prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getindex</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the object to be operated. This
function is used to get an element from the <code class="docutils literal notranslate"><span class="pre">map</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> container (internal values, not instances of <code class="docutils literal notranslate"><span class="pre">map</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> classes),
and the index of the element is stored at the top of the stack (relative
index is  − 1). After calling this function, the value obtained from the
container will be pushed onto the top of the stack. If there is no
subscript pointed to by the container, the value of <code class="docutils literal notranslate"><span class="pre">nil</span></code> will be pushed
onto the top of the stack. For example, if the element with index 1 in
the virtual stack is a <code class="docutils literal notranslate"><span class="pre">list</span></code>, and we want to extract the element with
index 0 from it, then we can use the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_pushint</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Push the index value 0 onto the virtual-stack</span>
<span class="n">be_getindex</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Get an element from the list container</span>
</pre></div>
</div>
<p>We first push the integer value <code class="docutils literal notranslate"><span class="pre">0</span></code> onto the stack, and this value will
be used as the index to get the element from the <code class="docutils literal notranslate"><span class="pre">list</span></code> container. The
second line of code implements to get elements from the <code class="docutils literal notranslate"><span class="pre">list</span></code>
container. The index value of the <code class="docutils literal notranslate"><span class="pre">list</span></code> container in the example is 1
in the virtual stack. The retrieved element is stored at the top of the
stack, and we can use the relative index  − 1 to access it.</p>
<p>This function is used to set a value in <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">map</span></code>. The function
prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_setindex</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code> is the subscript of the object to be operated.
This function is used to write an element of the <code class="docutils literal notranslate"><span class="pre">map</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>
container. The index of the value to be written in the virtual stack is
 − 1, and the index of the subscript of the write position in the
virtual stack is  − 2. If the element with the specified subscript does
not exist in the container, the write operation will fail.</p>
<p>Assuming that the position with index <code class="docutils literal notranslate"><span class="pre">1</span></code> in the virtual stack has a
value of <code class="docutils literal notranslate"><span class="pre">map</span></code>, and it has an element with a subscript of <code class="docutils literal notranslate"><span class="pre">&quot;test&quot;</span></code>, an
example of setting the element at the subscript of <code class="docutils literal notranslate"><span class="pre">&quot;test&quot;</span></code> to <code class="docutils literal notranslate"><span class="pre">100</span></code> is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_pushstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;test&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Push the index &quot;index&quot;</span>
<span class="n">be_pushint</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// Push the value 100</span>
<span class="n">be_setindex</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Set the key-value pair to map[&quot;test&quot;] = 100</span>
</pre></div>
</div>
<p>We must first push the subscript and the value to be written on the
stack in order. For <code class="docutils literal notranslate"><span class="pre">map</span></code>, it is a key-value pair. In the example, the
first two lines of code complete these tasks. The third line calls the
<code class="docutils literal notranslate"><span class="pre">be_setindex</span></code> function to write the value into the <code class="docutils literal notranslate"><span class="pre">map</span></code> object.</p>
<p>This function is used to read an Up Value of the native closure. The
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getupval</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the native closure index value of the Up Value to be read;
<code class="docutils literal notranslate"><span class="pre">pos</span></code> is the position of the Up Value in the native closure Up Value
table (numbering starts from 0). The read Up Value will be pushed onto
the top of the virtual stack.</p>
<p>This function is used to set an Up Value of the native closure. The
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_setupval</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the native closure index value to be written into the Up
Value; <code class="docutils literal notranslate"><span class="pre">pos</span></code> is the position of the Up Value in the native closure Up
Value table (numbering starts from 0). This function obtains a value
from the top of the virtual stack and writes it to the target Up Value.
After the operation is completed, the top value of the stack will not be
popped from the stack.</p>
<p>This function is used to get the parent object of the base class or
instance of the class. The function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getsuper</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the class or object to be operated. If the value at <code class="docutils literal notranslate"><span class="pre">index</span></code>
is a class with a base class, the function will push its base class onto
the top of the stack; if the value at <code class="docutils literal notranslate"><span class="pre">index</span></code> is an object with a parent
object, the function will take its parent The object is pushed onto the
top of the stack; otherwise, a value of <code class="docutils literal notranslate"><span class="pre">nil</span></code> is pushed onto the top of
the stack.</p>
<p>This function is used to get the number of elements contained in the
container. The function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_data_size</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the container object to be operated. If the
value at <code class="docutils literal notranslate"><span class="pre">index</span></code> is a Map value or List value, the function returns the
number of elements contained in the container, otherwise it returns
<code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p>This function is used to append a new element to the end of the
container. The function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_data_push</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the container object to be operated. The object
at <code class="docutils literal notranslate"><span class="pre">index</span></code> must be a List value. This function gets a value from the top
of the stack and appends it to the end of the container. After the
operation is completed, the value at the top of the stack will not be
popped from the stack.</p>
<p>This function is used to insert a pair of elements into the container.
The function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_data_insert</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the container object to be operated. The object
at <code class="docutils literal notranslate"><span class="pre">index</span></code> must be a List value or a Map value. The inserted element
forms a pair of key-value pairs. The value is stored at the top of the
stack, and the key is stored at the previous index on the top of the
stack. It should be noted that the key inserted into the Map container
cannot be a <code class="docutils literal notranslate"><span class="pre">nil</span></code> value, and the key inserted into the List container
must be an integer value. If the operation is successful, the function
will return <code class="docutils literal notranslate"><span class="pre">bture</span></code>, otherwise it will return <code class="docutils literal notranslate"><span class="pre">bfalse</span></code>.</p>
<p>This function is used to remove an element in the container. The
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_data_remove</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the container object to be operated. The object
at <code class="docutils literal notranslate"><span class="pre">index</span></code> must be a List value or Map value. For the Map container, the
key to delete the element is stored on the top of the virtual stack
(need to be pressed before the function call); for the List container,
the index of the element to be deleted is stored on the top of the
virtual stack (need to be before the function call) push into). If the
operation is successful, the function will return <code class="docutils literal notranslate"><span class="pre">bture</span></code>, otherwise it
will return <code class="docutils literal notranslate"><span class="pre">bfalse</span></code>.</p>
<p>This function is used to reset the capacity of the container. The
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_data_resize</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the container object to be operated. This
function is only available for List containers, and the new capacity is
stored on the top of the virtual stack (must be an integer).</p>
<p>This function is used to get the next element of the iterator. The
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_iter_next</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the iterator to be operated. The iterator object
may be an iterator of a List container or a Map container. For the List
iterator, this function pushes the iteration result value onto the top
of the stack, while for the Map iterator, it pushes the key value into
the previous position and the top of the stack respectively. Calling
this function will update the iterator. If the function returns <code class="docutils literal notranslate"><span class="pre">0</span></code>, the
call fails, returning <code class="docutils literal notranslate"><span class="pre">1</span></code> to indicate that the current iterator is a
List iterator, and returning <code class="docutils literal notranslate"><span class="pre">2</span></code> to indicate that the current iterator
is a Map iterator.</p>
<p>This function is used to test whether there is another element in the
iterator. The function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">map_hasnext</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the iterator to be operated. The iterator object
may be an iterator of a List container or a Map container. If there are
more iterable elements in the iterator, return <code class="docutils literal notranslate"><span class="pre">1</span></code>, otherwise return
<code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>This function is used to test whether there is a reference to the
specified object in the reference stack. It must be used in conjunction
with <code class="docutils literal notranslate"><span class="pre">be_refpush</span></code> and <code class="docutils literal notranslate"><span class="pre">be_refpop</span></code>. This API can avoid recursion when
traversing objects that have their own references. The function
prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_refcontains</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the object to be operated. This function is used
for the value of an instance type. If there is a reference to the object
in the reference stack, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>, otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Push the reference of the specified object onto the reference stack. The
function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_refpush</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the object to be operated. This function is used
for the value of an instance type.</p>
<p>Pop the object at the top of the reference stack. The function prototype
is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_refpop</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance. This
function is used in pairs with <code class="docutils literal notranslate"><span class="pre">be_refpush</span></code>. The following is the use of
the reference stack API to avoid the problem of infinite recursive
traversal when the object itself is referenced:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">list_traversal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">be_refcontains</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">be_return</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">be_refpush</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Traversing the container, may call list_traversal recursively.</span>
<span class="w">    </span><span class="n">be_refpop</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">be_return</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This is a simplified traversal process of the List container. For the
complete code, please refer to the source code of the function
<code class="docutils literal notranslate"><span class="pre">m_tostring</span></code> in <em>be_listlib.c</em>. We assume that the index of the List
object is <code class="docutils literal notranslate"><span class="pre">1</span></code>. First, we check whether the List already exists in the
reference stack (line 4), and if the reference already exists, return
directly, otherwise proceed with subsequent processing. To make
<code class="docutils literal notranslate"><span class="pre">be_refcontains</span></code> usable, we need to use <code class="docutils literal notranslate"><span class="pre">be_refpush</span></code> and <code class="docutils literal notranslate"><span class="pre">be_refpop</span></code> to
process the reference stack before and after the actual traversal
operation (lines 7 and 9).</p>
<p>This function tests the amount of free space on the stack and expands
the stack space if it is insufficient. The function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_stack_require</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance;
<code class="docutils literal notranslate"><span class="pre">count</span></code> is the required free stack capacity. If the free capacity of the
virtual stack allocated by the VM to the native function is lower than
this value, an expansion operation will be performed.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>, otherwise it
returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isnil</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is of type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, if it is, the function returns
<code class="docutils literal notranslate"><span class="pre">1</span></code>, otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isbool</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is an integer type, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isint</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is a real number type, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isreal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is an integer or a real number type, if it is, it
returns <code class="docutils literal notranslate"><span class="pre">1</span></code>, otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function
is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isnumber</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is a string type, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isstring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is a closure type, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isclosure</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is a primitive closure type, if it is, it returns
<code class="docutils literal notranslate"><span class="pre">1</span></code>, otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isntvclos</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is a function type, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isfunction</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured. There are three types
of functions: closure, native function and native closure.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is of type <code class="docutils literal notranslate"><span class="pre">proto</span></code>, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isproto</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured. <code class="docutils literal notranslate"><span class="pre">proto</span></code> The type is
the function prototype of the Berry closure.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is of type <code class="docutils literal notranslate"><span class="pre">class</span></code>, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isclass</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is of type <code class="docutils literal notranslate"><span class="pre">instance</span></code>, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isinstance</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is an instance or sub-instance of class <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isbytes</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is of type <code class="docutils literal notranslate"><span class="pre">list</span></code>, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_islist</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is of type <code class="docutils literal notranslate"><span class="pre">map</span></code>, if it is, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>,
otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_ismap</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<p>This function returns whether the value indexed by the parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>
in the virtual stack is a universal pointer type, if it is, it returns
<code class="docutils literal notranslate"><span class="pre">1</span></code>, otherwise it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>. The prototype of this function is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_iscomptr</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance, and
<code class="docutils literal notranslate"><span class="pre">index</span></code> is the index of the value to be measured.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bint</span><span class="w"> </span><span class="nf">be_toint</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Get the value of the index position of <code class="docutils literal notranslate"><span class="pre">index</span></code> from the virtual stack
and return it as an integer type. This function does not check the
correctness of the type. If the value is an instance, the method <code class="docutils literal notranslate"><span class="pre">toint()</span></code> is called if it exists.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">breal</span><span class="w"> </span><span class="nf">be_toreal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Get the value of the index position of <code class="docutils literal notranslate"><span class="pre">index</span></code> from the virtual stack
and return it as a floating-point number type. This function does not
check the correctness of the type.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bint</span><span class="w"> </span><span class="nf">be_toindex</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Get the value of the index position of <code class="docutils literal notranslate"><span class="pre">index</span></code> from the virtual stack
and return it as an integer type. This function does not check the
correctness of the type. Unlike <code class="docutils literal notranslate"><span class="pre">be_toint</span></code>, the return value type of
<code class="docutils literal notranslate"><span class="pre">be_toindex</span></code> is <code class="docutils literal notranslate"><span class="pre">int</span></code>, while the return value of the former is <code class="docutils literal notranslate"><span class="pre">bint</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bbool</span><span class="w"> </span><span class="nf">be_tobool</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Get the value of the index position of <code class="docutils literal notranslate"><span class="pre">index</span></code> from the virtual stack
and return it as a Boolean type. If the indexed value is not of Boolean
type, it will be converted according to the rules in section
type_bool,
and the conversion process will not cause the indexed value to change. If the value is an instance, the method <code class="docutils literal notranslate"><span class="pre">tobool()</span></code> is called if it exists.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tostring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Get the value of the index position of <code class="docutils literal notranslate"><span class="pre">index</span></code> from the virtual stack
and return it as a string type. If the indexed value is not a string
type, the indexed value will be converted to a string, and the
conversion process will replace the value at the indexed position in the
virtual stack with the converted string. The string returned by this
function always ends with <code class="docutils literal notranslate"><span class="pre">’\0’</span></code> characters. If the value is an instance, the method <code class="docutils literal notranslate"><span class="pre">tostring()</span></code> is called if it exists.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tocomptr</span><span class="p">(</span><span class="n">bvm</span><span class="o">*</span><span class="w"> </span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Get the value of the index position of <code class="docutils literal notranslate"><span class="pre">index</span></code> from the virtual stack
and return it as a general pointer type. This function does not check
the correctness of the type.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tobytes</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">len</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Get the value of the index position of <code class="docutils literal notranslate"><span class="pre">index</span></code> from the virtual stack
and return it as a bytes buffer. The pointer of the buffer is returned, and the size is stored in <code class="docutils literal notranslate"><span class="pre">*len</span></code> (unless <code class="docutils literal notranslate"><span class="pre">len</span></code> is NULL). This function works only for instances of the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> class, or returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushnil</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push a <code class="docutils literal notranslate"><span class="pre">nil</span></code> value onto the virtual stack.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushbool</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push a Boolean value onto the virtual stack. The parameter <code class="docutils literal notranslate"><span class="pre">b</span></code> is the
boolean value to be pushed onto the stack. When the value is <code class="docutils literal notranslate"><span class="pre">0</span></code>, it
means false, otherwise it is true.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushint</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">bint</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push an integer value <code class="docutils literal notranslate"><span class="pre">i</span></code> onto the virtual stack.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushreal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">breal</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push a floating point value <code class="docutils literal notranslate"><span class="pre">r</span></code> onto the virtual stack.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">be_pushstring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Push the string <code class="docutils literal notranslate"><span class="pre">str</span></code> onto the virtual stack. The parameter <code class="docutils literal notranslate"><span class="pre">str</span></code> must
point to a C string that ends with a null character <code class="docutils literal notranslate"><span class="pre">’\0’</span></code>, and a null
pointer cannot be passed in.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushnstring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push the string <code class="docutils literal notranslate"><span class="pre">str</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span></code> onto the virtual stack. The length
of the string is subject to the parameter <code class="docutils literal notranslate"><span class="pre">n</span></code>, and the null character is
not used as the end mark of the string.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_pushfstring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
</pre></div>
</div>
<p>Push the formatted string into the virtual stack. The parameter <code class="docutils literal notranslate"><span class="pre">format</span></code>
is a formatted string, which contains the text to be pushed onto the
stack, and the <code class="docutils literal notranslate"><span class="pre">format</span></code> parameter contains a label, which can be
replaced by the value specified by the subsequent additional parameter
and formatted as required. According to the label of the <code class="docutils literal notranslate"><span class="pre">format</span></code>
string, a series of additional parameters may be required, and each
additional parameter will replace the corresponding <code class="docutils literal notranslate"><span class="pre">%</span></code> label in the
<code class="docutils literal notranslate"><span class="pre">format</span></code> parameter.</p>
<div id="tab::format_specifier">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><strong><span class="sans-serif">specifier</span></strong></p></th>
<th class="text-left head"><p><strong>Description</strong></p></th>
<th class="text-left head"><p></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">d</span></code></p></td>
<td class="text-left"><p>Format as decimal signed integer (positive numbers do not output sign)</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">f</span></code></p></td>
<td class="text-left"><p>Single or double precision floating point number formatted as a decimal</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">g</span></code></p></td>
<td class="text-left"><p>Single or double precision floating point number formatted as exponential</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">s</span></code></p></td>
<td class="text-left"><p>Format as string</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
<td class="text-left"><p>Format as a single character</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">p</span></code></p></td>
<td class="text-left"><p>Format as pointer address</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td class="text-left"><p>Escaped as <code class="docutils literal notranslate"><span class="pre">%</span></code> Character (no parameter)</p></td>
<td class="text-left"><p></p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">format</span></code> Label parameter description</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">be_pushfstring</span></code> The function is similar to the standard function of C
<code class="docutils literal notranslate"><span class="pre">printf</span></code>, but the function of formatting strings is relatively basic and
does not support operations such as customizing the width and decimal
places. A typical example is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_pushfstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s: %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span><span class="w"> </span><span class="c1">// Good, it works!</span>
<span class="n">be_pushfstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s: %.5d&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span><span class="w"> </span><span class="c1">// Error, the specified width is not supported.</span>
</pre></div>
</div>
<p>This means that <code class="docutils literal notranslate"><span class="pre">be_pushfstring</span></code> can only perform simple formatting
operations. If the requirements cannot be met, it is recommended to use
<code class="docutils literal notranslate"><span class="pre">sprintf</span></code> formatted strings for operations.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushvalue</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push the value with index <code class="docutils literal notranslate"><span class="pre">index</span></code> onto the top of the virtual stack.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushntvclosure</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">bntvfunc</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nupvals</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push a native closure onto the top of the virtual stack. The parameter
<code class="docutils literal notranslate"><span class="pre">f</span></code> is the C function pointer of the native closure, and <code class="docutils literal notranslate"><span class="pre">nupvals</span></code> is
the upvalue number of the closure.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushntvfunction</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">bntvfunc</span><span class="w"> </span><span class="n">f</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push a native function onto the top of the virtual stack, and the
parameter <code class="docutils literal notranslate"><span class="pre">f</span></code> is the native function pointer.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushclass</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">bnfuncinfo</span><span class="w"> </span><span class="o">*</span><span class="n">lib</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push a native class onto the top of the virtual stack. The parameter
<code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of the native class, and the parameter <code class="docutils literal notranslate"><span class="pre">lib</span></code> is the
attribute description of the native class.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushcomptr</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push a general pointer onto the top of the virtual stack. The general
pointer <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to a certain C data area. Since the content pointed
to by this pointer is not maintained by Berry’s garbage collector, users
have to maintain the life cycle of the data themselves.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">be_pushbytes</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push a <code class="docutils literal notranslate"><span class="pre">bytes()</span></code> buffer starting at position <code class="docutils literal notranslate"><span class="pre">buf</span></code> and of size <code class="docutils literal notranslate"><span class="pre">len</span></code>.
The buffer is copied into Berry allocated memory, you don’t need to keep
the buffer valid after this call.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bbool</span><span class="w"> </span><span class="nf">be_pushiter</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Push an iterator onto the top of the virtual stack.</p>
<p>Push an error message onto the top of the stack. After executing the
FFI, the interpreter will directly return to the position that can
handle the error, and the code immediately following will not be
executed. The function prototype is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pusherror</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">vm</span></code> is the pointer of the virtual machine instance; <code class="docutils literal notranslate"><span class="pre">msg</span></code>
is the string containing the error information.</p>
<p>Move the value at the <code class="docutils literal notranslate"><span class="pre">from</span></code> index to the <code class="docutils literal notranslate"><span class="pre">to</span></code> index position. This
function does not delete the value of <code class="docutils literal notranslate"><span class="pre">from</span></code> index position, only
modifies the value of <code class="docutils literal notranslate"><span class="pre">to</span></code> index position.</p>
</section>
<section id="compile-time-construction-technology">
<h3>Compile-time construction technology<a class="headerlink" href="#compile-time-construction-technology" title="Permalink to this headline">¶</a></h3>
<p>The compile-time construction technology is mainly implemented by
<em>coc</em> which is located in the
<em>coc/coc</em> path of the interpreter
source code directory. <em>coc</em> Tool is used to generate constant
strings, and constant objects
as C code, and will be compiled into constants when the interpreter is
compiled. In principle, the <em>coc</em> tool will
generate code from the declaration information of the constant object
(in accordance with a specific format). The process will automatically
calculate the Hash value and generate the Hash table.</p>
<p><em>Makefile</em> in the root directory of the interpreter project will
automatically compile this tool and run the tool before compiling the
interpreter source code. The content of <em>Makefile</em> ensures that when
using the <code class="docutils literal notranslate"><span class="pre">make</span></code> command, the code for constructing the object at
compile time will always be updated through the tool (if it needs to be
updated). The code for constructing objects at compile time can be
manually generated through the <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">prebuild</span></code> command, which is stored
in the <em>generate</em> folder.</p>
<p>The compile-time construction can be turned on or off by modifying the
<code class="docutils literal notranslate"><span class="pre">BE_USE_PRECOMPILED_OBJECT</span></code> macro. In any case, the tool <em>coc</em> is called to generate constant object codes (the codes
are not used when compile-time construction is turned off).</p>
<section id="use-command">
<h4>Use command<a class="headerlink" href="#use-command" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">coc</span></code> Tool is used to generate code for constant objects. The
format of the command is</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>tools/coc/coc -o &lt;dst_path&gt; &lt;src_path<span class="o">(</span>s<span class="o">)</span>&gt; -c &lt;include_path&gt;
</pre></div>
</div>
<p>The output path <em>dst_path</em> is used to store the generated code, and the
source path <em>src_path</em> is a list of paths that need to be scanned for
the source code (use spaces to separate multiple paths).
<code class="docutils literal notranslate"><span class="pre">include_path</span></code> contains a C header file scanned to detect compilation
directives. <code class="docutils literal notranslate"><span class="pre">coc</span></code> tries to compile only the necessary constants.
Since <em>generate</em> is used as the generated code path in the source code of the
interpreter, <em>dst_path</em> must be <em>generate</em>. Taking the standard
interpreter project as an example, the command to use the tool in
<code class="docutils literal notranslate"><span class="pre">map_build</span></code> should be</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>tools/coc/coc -o generate default src -c default/berry_conf.h
</pre></div>
</div>
<p>The meaning of this command is: the output path is <em>generate</em>, and the
source path is <em>src</em> and <em>default</em>.</p>
</section>
<section id="output-path">
<h4>output path<a class="headerlink" href="#output-path" title="Permalink to this headline">¶</a></h4>
<p>Strictly speaking, the <em>generate</em> folder used as the output path cannot
be placed anywhere, it must be stored in a parent directory containing
the path. The include path refers to the path where the header file will
be searched in the project. Taking the standard interpreter source code
as an example, the include path is <em>src</em> and <em>default</em>. Therefore, in
the standard interpreter project, the <em>generate</em> folder is stored in the
root directory of the interpreter source code (the parent directory of
<em>src</em> and <em>default</em>).</p>
<p>The reason for the above rules is that the following codes are used in
the interpreter source code to refer to constant objects:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;../generate/be_fixed_xxx.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>If readers want to define constant objects themselves, they also need to
use such code to include the corresponding header files. This section
will introduce how to use these tools to define and use constant
objects.</p>
</section>
</section>
<section id="compile-time-string-table">
<h3>Compile-time string table<a class="headerlink" href="#compile-time-string-table" title="Permalink to this headline">¶</a></h3>
<p>The compile-time string table is used to store constant strings.
Constant strings are objects that are transparent to the script. They
are not created or destroyed when the interpreter is running, but are
always stored as constants in the data segment of the interpreter
program. If you need to use a string as a constant string, you can add
the prefix <code class="docutils literal notranslate"><span class="pre">be_const_str_</span></code> in front of the string in the interpreter
source code, and the declaration can be placed anywhere in the source
file (including comments). For example, to create a constant string with
the content <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code>, you need to declare the symbol
<code class="docutils literal notranslate"><span class="pre">be_const_str_string</span></code> in the source file, and this symbol is also the
variable name that refers to the constant string in the C code.</p>
<p>All keywords will create constant strings. If you modify the
keyword-related code in the Berry interpreter, the corresponding code in
<em>coc</em> must also be modified.</p>
<p>If the string contains special symbols, they are automatically escaped
as <code class="docutils literal notranslate"><span class="pre">_XHH</span></code> where <code class="docutils literal notranslate"><span class="pre">HH</span></code> is the hex representation (uppercase) of the character.
For example <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> is represented by <code class="docutils literal notranslate"><span class="pre">_X3A</span></code>. This representation is bihective
so it’s easy to convert to and from the original string.</p>
<section id="use-constant-string">
<h4>Use constant string<a class="headerlink" href="#use-constant-string" title="Permalink to this headline">¶</a></h4>
<p>Normally, there is no need to manually declare constant strings, nor to
use them manually. If you really need to call the constant string
manually, include the header file <em>be_constobj.h</em> to use all constant
string variables (this header file has declarations for all constant
strings). The typical use of constant strings is to construct objects at
compile time. The declaration and definition of constant strings in this
process are automatically handled by the tool.</p>
<p>In any case, the FFI function <code class="docutils literal notranslate"><span class="pre">be_pushstring</span></code> should be used directly to
create a string. When a string has a constant string, it will not
repeatedly create a new string object, but directly use the
corresponding constant string.</p>
<p>By default, all strings used are referenced in a global
<code class="docutils literal notranslate"><span class="pre">m_const_string_table</span></code> hashtable. However, some projects may have
many compilation variants for which some sets of string are not needed.
If all string constants are stored in all variants, this creates a waste
of flash size. For this reason, some strings can be declared as <code class="docutils literal notranslate"><span class="pre">weak</span></code>
strings in the sense of having a <code class="docutils literal notranslate"><span class="pre">weak</span></code> reference. In such case
the string constant is declared in C code, but not included in the global
map object. This means that the linker can choose to not include the string
constants if it is not referenced by any code. The con is that if you
dynamically create a string object with the same value, a new object
is created in memory (while it would not for a regular string constant).
To indicate weak strings, use the <code class="docutils literal notranslate"><span class="pre">strings:</span> <span class="pre">weak</span></code> modifier (see below).</p>
</section>
</section>
<section id="construct-object-at-compile-time">
<h3>Construct object at compile time<a class="headerlink" href="#construct-object-at-compile-time" title="Permalink to this headline">¶</a></h3>
<p>Objects constructed at compile time are also called constant objects.
The data structure of these objects is constructed when the interpreter
is compiled and cannot be modified at runtime. <code class="docutils literal notranslate"><span class="pre">map_build</span></code> A set of
declaration rules is defined in the tool to generate C code for constant
objects. The declaration information of the constant object is directly
stored in the source file (<em>*.c</em>). In order to distinguish it from
other content, a complete declaration information should be included in
the following boot code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@const_object_info_begin</span>
<span class="nd">@const_object_info_end</span>
</pre></div>
</div>
<p>The constant object declaration information does not conform to the C
language syntax, so they should be placed in a multi-line comment
(included with <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code>). All constant objects have the same declaration
form. The declaration structure of a constant object is called “object
declaration block”, which is composed of</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">object_name</span> <span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">member_fields</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> is the type of constant object, it can be <code class="docutils literal notranslate"><span class="pre">map</span></code>, <code class="docutils literal notranslate"><span class="pre">class</span></code>,
<code class="docutils literal notranslate"><span class="pre">module</span></code> or <code class="docutils literal notranslate"><span class="pre">vartab</span></code>. <code class="docutils literal notranslate"><span class="pre">object_name</span></code> is the variable name of the constant
object in C language. <code class="docutils literal notranslate"><span class="pre">attributes</span></code> is the attribute list of constant
objects. An attribute is composed of attribute name and attribute value.
The attribute name and attribute value are separated by semicolons, and
multiple attributes are separated by commas. For example, the attribute
list <code class="docutils literal notranslate"><span class="pre">scope:</span> <span class="pre">global,</span> <span class="pre">name:</span> <span class="pre">map</span></code> means that the <code class="docutils literal notranslate"><span class="pre">scope</span></code> attribute of a
constant object is <code class="docutils literal notranslate"><span class="pre">global</span></code>, and the <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute is <code class="docutils literal notranslate"><span class="pre">map</span></code>.
Also <code class="docutils literal notranslate"><span class="pre">strings:</span> <span class="pre">weak</span></code> indicate to generate weak string constants
for the names of member fields or any string constant.
<code class="docutils literal notranslate"><span class="pre">member_fields</span></code> is the list of member domains of constant objects. A
member is composed of name and value, separated by commas. Each line can
declare one member, and multiple members must be declared on multiple
lines.</p>
<p>The <strong>coc</strong> tool uses regular expressions to parse the object
declaration block. In the parsing process, the entire object declaration
block will be matched first, and the information <code class="docutils literal notranslate"><span class="pre">type</span></code> and
<code class="docutils literal notranslate"><span class="pre">object_name</span></code> will be matched. For the information of <code class="docutils literal notranslate"><span class="pre">attributes</span></code> and
<code class="docutils literal notranslate"><span class="pre">member_fields</span></code>, further Analysis. In order to facilitate the
implementation, the tool does not have strict requirements on the syntax
of the object declaration block, and lacks a complete error handling
mechanism, so you should ensure that the syntax is correct when writing
the object declaration block.</p>
<p>In order to facilitate understanding, we illustrate with a simple
constant class:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* @const_object_info_begin</span>
<span class="cm">class be_class_map (scope: global, name: map) {</span>
<span class="cm">    .data, var</span>
<span class="cm">    init, func(m_init)</span>
<span class="cm">    tostring, func(m_tostring)</span>
<span class="cm">}</span>
<span class="cm">@const_object_info_end */</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;../generate/be_fixed_be_class_map.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>In this example, the declaration information of the entire constant
class is in the C language comment, so it will not affect the
compilation of the C code. The object declaration block is placed
between <code class="docutils literal notranslate"><span class="pre">&#64;const_object_info_begin</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;const_object_info_end</span></code> to
ensure that the  <strong>coc</strong> tool detects the object declaration block.</p>
<p>Since it is a constant class declaration, the value of <em>type</em> in the
object declaration block is <code class="docutils literal notranslate"><span class="pre">class</span></code>, and <code class="docutils literal notranslate"><span class="pre">be_class_map</span></code> is the variable
name of the constant object in the C code. Two attributes are declared
in the attribute list of the object (the part enclosed in parentheses),
and the meaning of these attributes will be introduced in the
“Compile-Time Construction Class” section of this section. Three members
are defined in the member list surrounded by curly braces, multiple
members are separated by newlines, and the name of the member and the
value of the member are separated by a comma.There are several legal
formats for member names:</p>
<ul class="simple">
<li><p>Berry variable name format: start with a letter or underscore,
followed by several letters, underscores or numbers.</p></li>
<li><p>Use “<code class="docutils literal notranslate"><span class="pre">.</span></code>” as the first character, followed by letters, underscores
or numbers.</p></li>
<li><p>Overloadable operators, such as “<code class="docutils literal notranslate"><span class="pre">+</span></code>”, “<code class="docutils literal notranslate"><span class="pre">-</span></code>” and “<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>” etc.</p></li>
</ul>
<p>The value of a member can be of the following types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">var</span></code>: This symbol will be compiled into an integer object
(<code class="docutils literal notranslate"><span class="pre">be_const_var</span></code>), and the value of the integer object is
automatically incremented from <code class="docutils literal notranslate"><span class="pre">0</span></code>. <code class="docutils literal notranslate"><span class="pre">var</span></code> It is designed for the
declaration of member variables in the class, and its automatic
numbering feature is used to realize the serial number of member
variables.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">func(symbol)</span></code>: Declare native member functions or methods of
constant objects. The symbol will be compiled into a native function
value (<code class="docutils literal notranslate"><span class="pre">be_const_func</span></code>), <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is the native function pointer
corresponding to the member. <code class="docutils literal notranslate"><span class="pre">m_init</span></code> and <code class="docutils literal notranslate"><span class="pre">m_tostring</span></code> in the
example are two native functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">closure(symbol)</span></code>: Declare pre-compiled bytecode member functions or methods
of constant objects. The symbol will be compiled into a native function
value (<code class="docutils literal notranslate"><span class="pre">be_const_closure</span></code>), <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is the name of the solidified function.
See <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">solidify</span></code> to know how to solidify objects.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nil()</span></code>: This symbol will be compiled into an nil value
(<code class="docutils literal notranslate"><span class="pre">be_const_nil</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int(value)</span></code>: This symbol will be compiled into an integer object
(<code class="docutils literal notranslate"><span class="pre">be_const_int</span></code>), the value of the integer object is <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">real(value)</span></code>: This symbol will be compiled into a real number
object (<code class="docutils literal notranslate"><span class="pre">be_const_real</span></code>), the value of the real number object is
<code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">comptr(value)</span></code>: This symbol will be compiled into a pointer
object (<code class="docutils literal notranslate"><span class="pre">be_const_comptr</span></code>), the value of the pointer is
<code class="docutils literal notranslate"><span class="pre">value</span></code> and can be used to pass the address of a C global structure.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">class(symbol)</span></code>: This symbol will be compiled into a class object
(<code class="docutils literal notranslate"><span class="pre">be_const_class</span></code>). <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is a pointer to this type of object,
and the pointer needs to point to a constant type object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">module(symbol)</span></code>: This symbol will be compiled into a module object
(<code class="docutils literal notranslate"><span class="pre">be_const_module</span></code>). <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is a pointer to the module object, and
the pointer needs to point to a constant module object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ctype_func(symbol)</span></code>: This symbol will be compiled into a native function
(<code class="docutils literal notranslate"><span class="pre">be_const_ctype_func</span></code>). <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is a pointer to the C mapping
definition. This feature is used by
<a class="reference external" href="https://github.com/berry-lang/berry_mapping">berry_mapping</a></p></li>
</ul>
<p>In order to use the <code class="docutils literal notranslate"><span class="pre">be_class_map</span></code> object, we need to include the
corresponding header file in the C code to ensure that the object will
be compiled. The usual practice is to include the corresponding header
file near the object declaration block. In the example, line 8 contains
it. The corresponding header file can be used to construct
<code class="docutils literal notranslate"><span class="pre">be_class_map</span></code> objects at compile time.</p>
<p>After processing by the <strong>coc</strong> tool , each object declaration block
will be compiled into a header file named <em>be_fixed_be_xxx.h</em>, and <em>xxx</em>
is the C variable name of the object. In order to compile constant
objects in C code, we need to include the corresponding header files. It
is usually recommended to include the corresponding header files near
the object declaration block. The 8th line in the example contains
<em>be_fixed_be_class_map.h</em> to construct the <code class="docutils literal notranslate"><span class="pre">be_class_map</span></code> object at
compile time.</p>
<section id="construct-map-at-compile-time">
<h4>Construct Map at Compile Time<a class="headerlink" href="#construct-map-at-compile-time" title="Permalink to this headline">¶</a></h4>
<p>Maps constructed at compile-time are also constant <code class="docutils literal notranslate"><span class="pre">map</span></code> objects. They
are generally not declared directly using object declaration blocks, but
are declared in other compile-time construction structures. When
constructing the constant <code class="docutils literal notranslate"><span class="pre">map</span></code>, the constant object type information
should be <code class="docutils literal notranslate"><span class="pre">map</span></code>, which supports a <code class="docutils literal notranslate"><span class="pre">scope</span></code> attribute. When the <code class="docutils literal notranslate"><span class="pre">scope</span></code>
attribute value is <code class="docutils literal notranslate"><span class="pre">local</span></code>, the constant object is <code class="docutils literal notranslate"><span class="pre">static</span></code>, the
attribute When it is <code class="docutils literal notranslate"><span class="pre">global</span></code>, it is <code class="docutils literal notranslate"><span class="pre">extern</span></code>, and the value of this
attribute is <code class="docutils literal notranslate"><span class="pre">local</span></code> by default. The constant <code class="docutils literal notranslate"><span class="pre">map</span></code> object’s
<code class="docutils literal notranslate"><span class="pre">member_fields</span></code> supports common member name/member value specifications,
and member values are only stored as data without special
interpretation. The following is an example of using the object
declaration block to directly declare a constant <code class="docutils literal notranslate"><span class="pre">map</span></code> object:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>map map_name (scope: local/global) {
    init, func(m_init)
}
</pre></div>
</div>
</section>
<section id="compile-time-construction-class">
<h4>Compile-time construction class<a class="headerlink" href="#compile-time-construction-class" title="Permalink to this headline">¶</a></h4>
<p>To construct a class at compile time, use the object declaration block
to declare, and the type information of the object is <code class="docutils literal notranslate"><span class="pre">class</span></code>. The
declared properties of this object are <code class="docutils literal notranslate"><span class="pre">scope</span></code> and <code class="docutils literal notranslate"><span class="pre">name</span></code>. <code class="docutils literal notranslate"><span class="pre">scope</span></code> The
scope of the C variable of the attribute declaration object, when the
value is <code class="docutils literal notranslate"><span class="pre">local</span></code> (default), the scope is <code class="docutils literal notranslate"><span class="pre">static</span></code>, when it is <code class="docutils literal notranslate"><span class="pre">global</span></code>,
the scope is <code class="docutils literal notranslate"><span class="pre">extern</span></code>; <code class="docutils literal notranslate"><span class="pre">name</span></code> The value of the attribute is that class
Name, anonymous class can omit this parameter. Since the attribute list
of a class only stores methods and member variable indexes, the
<code class="docutils literal notranslate"><span class="pre">member_fields</span></code> of the class constructed at compile time can only use
the values <code class="docutils literal notranslate"><span class="pre">var</span></code> and <code class="docutils literal notranslate"><span class="pre">func()</span></code>. A simple compile-time construction class
declaration block is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class be_class_map (scope: global, name: map) {
    .data, var
    init, func(m_init)
    tostring, func(m_tostring)
}
</pre></div>
</div>
</section>
<section id="building-module-at-compile-time">
<h4>Building Module at Compile Time<a class="headerlink" href="#building-module-at-compile-time" title="Permalink to this headline">¶</a></h4>
<p>The type information of the building block declaration block at compile
time is <code class="docutils literal notranslate"><span class="pre">module</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">module</span><span class="w"> </span><span class="nf">math</span><span class="w"> </span><span class="p">(</span><span class="n">scope</span><span class="o">:</span><span class="w"> </span><span class="n">global</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">m_sin</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">m_cos</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="n">real</span><span class="p">(</span><span class="n">M_PI</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="construct-built-in-domain-at-compile-time">
<h4>Construct Built-in Domain at Compile Time<a class="headerlink" href="#construct-built-in-domain-at-compile-time" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">vartab</span><span class="w"> </span><span class="nf">m_builtin</span><span class="w"> </span><span class="p">(</span><span class="n">scope</span><span class="o">:</span><span class="w"> </span><span class="n">local</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">l_assert</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">print</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">l_print</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">class</span><span class="p">(</span><span class="n">be_class_list</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Guan Wenliang &amp; Stephan Hadinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
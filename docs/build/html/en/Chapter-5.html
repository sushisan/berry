<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5. Function &mdash; berry 1.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> berry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Home.html">Welcome to the berry wiki!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../es/Home.html">Bienvenido a la wiki de Berry!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">berry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>5. Function</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/en/Chapter-5.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="function">
<h1>5. Function<a class="headerlink" href="#function" title="Permalink to this headline"></a></h1>
<p><strong>function</strong> is a “subroutine” that can be called by external code. As a
part of the program, the function itself is also a piece of code. A
function can have 0 or more parameters and will return a result, which
is called the function’s <strong>return value</strong>.</p>
<p>In Berry, the function is <strong>first class value</strong>. Therefore, in addition
to calling functions, you can also pass functions as values, for
example, bind functions to variables, use functions as return values,
and so on.</p>
<section id="basic-information">
<h2>5.1 Basic Information<a class="headerlink" href="#basic-information" title="Permalink to this headline"></a></h2>
<p>The use of functions includes two parts: function definition and call.
The function definition statement uses the <code class="docutils literal notranslate"><span class="pre">def</span></code> keyword as the
beginning. The function definition is the process of packaging and
naming the code of the function body. This process only generates the
function structure and does not execute the function. The execution
function must use <strong>call operator</strong>, which is a pair of parentheses. The
call operator acts on an expression whose result is a function type. The
parameters passed to the function are written in parentheses, and
multiple parameters are separated by commas. The result of the calling
expression is the return value of the function.</p>
<section id="function-definition">
<h3>5.1.1 Function Definition<a class="headerlink" href="#function-definition" title="Permalink to this headline"></a></h3>
<section id="named-function">
<h4>Named Function<a class="headerlink" href="#named-function" title="Permalink to this headline"></a></h4>
<p><strong>named function</strong> is a function given a name when it is defined. Its
definition statement consists of the following parts: <code class="docutils literal notranslate"><span class="pre">def</span></code> keywords,
function names, lists consisting of 0 to multiple parameters, and
function bodies ( function body), multiple parameters in the parameter
list are separated by commas, and all parameters are written in a pair
of parentheses. We call the parameter when the function is defined as
<strong>Formal parameters</strong>, and the parameter when calling the function as
<strong>Arguments</strong>. The general form of the function definition is:</p>
<div class="algorithm">
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>’def’ name ´(´ arguments ´)´
  block
´end’
</pre></div>
</div>
</div>
<p>The function name <strong>name</strong> is an identifier;
<strong>arguments</strong> is the formal parameter
list; <strong>block</strong> is the function body. If the function
body is an empty statement, the function is called an “empty function”.
The function return value statement is contained in the function body.
If there is no return statement in <strong>block</strong>, the
function will return <code class="docutils literal notranslate"><span class="pre">nil</span></code> by default. The function name is actually the
variable name of the bound function object. If the name already exists
in the current scope, defining the function is equivalent to binding the
function object to this variable.</p>
<p>The following example defines a function named <code class="docutils literal notranslate"><span class="pre">add</span></code>. The function of
this function is to sum two numbers and return.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def add(a, b)
    return a + b
end
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">add</span></code> The function has two parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, and the two addends
are passed into the function through these parameters for calculation.
<code class="docutils literal notranslate"><span class="pre">return</span></code> The statement returns the result of the calculation.</p>
<p>A function as a class attribute is called a method. This part of the
content will be explained in the object-oriented chapter.</p>
</section>
<section id="anonymous-function">
<h4>Anonymous Function<a class="headerlink" href="#anonymous-function" title="Permalink to this headline"></a></h4>
<p>Unlike named functions, <strong>anonymous function</strong> has no name, and its
definition expression has the form:</p>
<div class="algorithm">
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>´def’ ´(´ arguments ´)´
  block
´end’
</pre></div>
</div>
</div>
<p>It can be seen that compared with named functions, there is no function
name in the definition of anonymous functions <strong>name</strong>. The
definition of an anonymous function is essentially an expression, which
is called <strong>Function literal</strong>. In order to use anonymous functions, we
can bind the function literal value to a variable:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>add = def (a, b)
    return a + b
end
</pre></div>
</div>
<p>The function of this code is exactly the same as that of the function
<code class="docutils literal notranslate"><span class="pre">add</span></code> in the previous section. An anonymous function can be used to
conveniently pass the function value as a literal value. Like other
types of literals, function literals are also the smallest unit of
expressions. Therefore, between <code class="docutils literal notranslate"><span class="pre">def</span></code> keywords and <code class="docutils literal notranslate"><span class="pre">end</span></code> are an
indivisible whole.</p>
</section>
</section>
<section id="call-function">
<h3>Call function<a class="headerlink" href="#call-function" title="Permalink to this headline"></a></h3>
<p>Take the <code class="docutils literal notranslate"><span class="pre">add</span></code> function as an example. To call this function, you need
to provide two values, and you can get the sum of the two numbers by
calling the function:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>res = add(5, 3)
print(res) # 8
</pre></div>
</div>
<p>We call the called function (the <code class="docutils literal notranslate"><span class="pre">add</span></code> function in the example) as
<strong>Called function</strong>, and the function that calls the called function
(the <code class="docutils literal notranslate"><span class="pre">main</span></code> function in the example) as <strong>Key function</strong>. The function
call process is as follows: First, the interpreter will (implicitly)
initialize the formal parameter list of the called function with the
argument list, and at the same time suspend the calling function and
save its state, then create an environment for the called function and
execute the called function. function.</p>
<p>The function will end its execution when it encounters the <code class="docutils literal notranslate"><span class="pre">return</span></code>
statement and pass the return value to the calling function. The
interpreter will destroy the environment of the called function after
the called function returns, then restore the environment of the calling
function and continue to execute the calling function. The return value
of the function is also the result of the function call expression. The
following example defines a function <code class="docutils literal notranslate"><span class="pre">square</span></code> and binds this function to
a variable <code class="docutils literal notranslate"><span class="pre">f</span></code>, and then calls the function <code class="docutils literal notranslate"><span class="pre">square</span></code> through the
variable <code class="docutils literal notranslate"><span class="pre">f</span></code>. This usage is similar to function pointers in C language.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def square(n)
    return n * n
end
f = square
print(f(5)) # 25
</pre></div>
</div>
<p>It should be noted that the function object is only bound to these
variables (refer to section
<a href="#section::assign_operator" data-reference-type="ref" data-reference="section::assign_operator">[section::assign_operator]</a>)
and cannot be modified, so reassigning the variable corresponding to the
function name will not make the function lose:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>f = square
square = nil
print(f(5)) # 25
</pre></div>
</div>
<p>It can be seen that the function can still be called normally after
reassigning <code class="docutils literal notranslate"><span class="pre">square</span></code>. Only after the function object is no longer bound
to any variable will it be lost, and the resources occupied by this type
of function object will be recycled by the system.</p>
<section id="forward-call">
<h4>Forward call<a class="headerlink" href="#forward-call" title="Permalink to this headline"></a></h4>
<p>The call of the function must be in the scope of the function variable,
so it usually cannot be called before the function is defined. In order
to solve this problem, you can use this method to compromise:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>var func1
def func2(x)
    return func1(x)
end
def func1(x)
    return x * x
end
print(func2(4)) # 16
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">func2</span></code> calls <code class="docutils literal notranslate"><span class="pre">func1</span></code>, but the function <code class="docutils literal notranslate"><span class="pre">func1</span></code> is
defined after <code class="docutils literal notranslate"><span class="pre">func2</span></code>. After executing this code, the program will
output the correct result <code class="docutils literal notranslate"><span class="pre">16</span></code>. This routine uses the mechanism that the
function will not be called when the function is defined. Define the
variable <code class="docutils literal notranslate"><span class="pre">func1</span></code> before defining <code class="docutils literal notranslate"><span class="pre">func2</span></code> to ensure that the symbol
<code class="docutils literal notranslate"><span class="pre">func1</span></code> will not be found during compilation. Then we define the
function <code class="docutils literal notranslate"><span class="pre">func1</span></code> after <code class="docutils literal notranslate"><span class="pre">func2</span></code> so that the function will be used to
overwrite the value of the variable <code class="docutils literal notranslate"><span class="pre">func1</span></code>. When the function <code class="docutils literal notranslate"><span class="pre">func2</span></code>
is called in the last line <code class="docutils literal notranslate"><span class="pre">print(func2(4))</span></code>, the variable <code class="docutils literal notranslate"><span class="pre">func1</span></code> is
already the function we need, so the correct result will be output.</p>
</section>
<section id="recursive-call">
<h4>Recursive call<a class="headerlink" href="#recursive-call" title="Permalink to this headline"></a></h4>
<p><strong>recursive function</strong> refers to functions that call themselves directly
or indirectly. Recursion refers to a strategy that divides the problem
into similar sub-problems and then solves them. Taking factorial as an
example, the recursive definition of factorial is
0! = 1, <em>n</em>! = <em>n</em> ⋅ (<em>n</em>−1)!, we can write the recursive function for
calculating factorial according to the definition:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def fact(n)
    if n == 0
        return 1
    end
    return n * fact(n-1)
end
</pre></div>
</div>
<p>Take the factorial of 5 as an example, the process of manually
calculating the factorial of 5 is:
5! = 5 × 4 × 3 × 2 × 1 = 120
The result of calling the <code class="docutils literal notranslate"><span class="pre">fact</span></code> function is also 120:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>print(fact(5)) # 120
</pre></div>
</div>
<p>In order to ensure that the depth of the recursive call is limited (too
deep recursion level will exhaust the stack space), the recursive
function must have an end condition. <code class="docutils literal notranslate"><span class="pre">fact</span></code> The <code class="docutils literal notranslate"><span class="pre">if</span></code> statement in the
second line of the function definition is used to detect the end
condition, and the recursive process ends when <code class="docutils literal notranslate"><span class="pre">n</span></code> is calculated as <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The above factorial formula does not apply to non-integer parameters.
Executing an expression like <code class="docutils literal notranslate"><span class="pre">fact(5.1)</span></code> will cause a stack overflow
error due to the inability to end the recursion.</p>
<p>There is another situation <code class="docutils literal notranslate"><span class="pre">Indirect</span> <span class="pre">recursion</span></code>, that is, the function
is not called by itself but by another function (directly or indirectly)
called by it. Indirect recursion usually requires the use of forward
function call techniques. Take the functions <code class="docutils literal notranslate"><span class="pre">is_odd</span></code> and <code class="docutils literal notranslate"><span class="pre">is_even</span></code> for
calculating odd and even numbers as examples:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>var is_odd
def is_even(n)
    if n == 0
        return true
    end
    return is_odd(n-1)
end
def is_odd(n)
    if n == 0
        return false
    end
    return is_even(n-1)
end
</pre></div>
</div>
<p>These two functions call each other. In order to ensure that this name
is in the scope when calling the function <code class="docutils literal notranslate"><span class="pre">is_odd</span></code> on line 6, the
variable <code class="docutils literal notranslate"><span class="pre">is_odd</span></code> is defined on line 1.</p>
</section>
<section id="anonymous-function-call">
<h4>Anonymous function call<a class="headerlink" href="#anonymous-function-call" title="Permalink to this headline"></a></h4>
<p>If an anonymous function will only be called once, the easiest way is to
call it when it is defined, for example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>res = def (a, b) return a + b end (1, 2) # 3
</pre></div>
</div>
<p>In this routine, we use the call expression directly after the function
literal to call the function. This usage is very suitable for functions
that will only be called in one place.</p>
<p>You can also bind an anonymous function to a variable and call it:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>add = def (a, b) return a + b end
res = add(1, 2) # 3
</pre></div>
</div>
<p>This usage is similar to the call of a named function, essentially
calling the variable bound to the function value. It should be noted
that it is more difficult to make recursive calls to anonymous
functions, unless you use forward call techniques.</p>
</section>
</section>
<section id="formal-and-actual-parameters">
<h3>Formal and actual parameters<a class="headerlink" href="#formal-and-actual-parameters" title="Permalink to this headline"></a></h3>
<p>The function uses actual parameters to initialize the formal parameters
when it is called. Under normal circumstances, the actual parameter and
the shape parameter are equal and the positions correspond to each
other, but Berry also allows the actual parameter to be unequal to the
formal parameter: if the actual parameter is more than the formal
parameter, the extra actual parameter will be discarded. Less than the
formal parameters will initialize the remaining formal parameters to
<code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>The process of parameter passing is similar to assignment operation. For
<code class="docutils literal notranslate"><span class="pre">nil</span></code>, <code class="docutils literal notranslate"><span class="pre">boolean</span></code> and numeric types, parameter passing is by value, while
other types are by reference. For the writable pass-by-reference type
such as instance, modifying them in the called function will also modify
the object in the calling function. The following example demonstrates
this feature:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>var l = [], i = 0
def func(a, b)
    a.push(1)
    b =&#39;string&#39;
end
func(l, i)
print(l, i) # [1] 0
</pre></div>
</div>
<p>It can be seen that the value of variable <code class="docutils literal notranslate"><span class="pre">l</span></code> has changed after calling
function <code class="docutils literal notranslate"><span class="pre">func</span></code>, but the value of variable <code class="docutils literal notranslate"><span class="pre">i</span></code> has not changed.</p>
</section>
<section id="function-with-variable-number-of-arguments-vararg">
<h3>Function with variable number of arguments (vararg)<a class="headerlink" href="#function-with-variable-number-of-arguments-vararg" title="Permalink to this headline"></a></h3>
<p>You can define a function to take any arbitrary number of arguments and iterate on them.
For example <code class="docutils literal notranslate"><span class="pre">print()</span></code> takes any number of arguments and prints each of them separated
by spaces. You need to define the last argument as a capture-all-arguments using <code class="docutils literal notranslate"><span class="pre">*</span></code>
before its name.</p>
<p>All arguments following the formal arguments are grouped at runtime in a <code class="docutils literal notranslate"><span class="pre">list</span></code> instance.
If no arguments are captured, the list is empty.</p>
<p>Example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def f(a, b, *c) return size(c) end
f(1,2) # returns 0, c is []
f(1,2,3) # returns 1, c is [3]
f(1,2,3,4) # returns 2, c is [3,4]
</pre></div>
</div>
</section>
<section id="calling-a-function-with-dynamic-number-of-arguments">
<h3>Calling a function with dynamic number of arguments<a class="headerlink" href="#calling-a-function-with-dynamic-number-of-arguments" title="Permalink to this headline"></a></h3>
<p>Berry syntax allows only to call with a fixed number of arguments.
Use the <code class="docutils literal notranslate"><span class="pre">call(f,</span> <span class="pre">[args])</span></code> function to pass any arbitrary number or arguments.</p>
<p>You can statically add any number of arguments to <code class="docutils literal notranslate"><span class="pre">call()</span></code>. If the last argument
is a <code class="docutils literal notranslate"><span class="pre">list</span></code>, it is automatically expanded to discrete arguments.</p>
<p>Example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def f(a,b) return nil end

call(f,1)        # calls f(1)
call(f,1,2)      # calls f(1,2)
call(f,1,2,3)    # calls f(1,2,3), last arg is ignored by f
call(f,1,[2,3])  # calls f(1,2,3), last arg is ignored by f
call(f,[1,2])    # calls f(1,2)
call(f,[])       # calls f()
</pre></div>
</div>
<p>You can combine <code class="docutils literal notranslate"><span class="pre">call</span></code> and vararg. For example let’s create a function that
acts like <code class="docutils literal notranslate"><span class="pre">print()</span></code> but converts all arguments to uppercase.</p>
<p>Full example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def print_upper(*a)  # take arbitrary number of arguments, args is a list
    import string
    for i:0..size(a)-1
        if type(a[i]) == &#39;string&#39;
            a[i] = string.toupper(a[i])
        end
    end
    call(print, a)   # call print with all arguments
end

print_upper(&quot;a&quot;,1,&quot;Foo&quot;,&quot;Bar&quot;)  # prints: A 1 FOO BAR
</pre></div>
</div>
</section>
<section id="functions-and-local-variables">
<h3>Functions and local variables<a class="headerlink" href="#functions-and-local-variables" title="Permalink to this headline"></a></h3>
<p>The function body itself is a scope, so the variables defined in the
function are all local variables.
Unlike directly nested blocks, every time a function is called, space is
allocated for local variables. The space for local variables is
allocated on the stack, and the allocation information is determined at
compile time, so this process is very fast. When multiple levels of
scope are nested in a function, the interpreter allocates stack space
for the scope nesting chain with the most local variables, rather than
the total number of local variables in the function.</p>
</section>
<section id="return-statement">
<h3><code class="docutils literal notranslate"><span class="pre">return</span></code> Statement<a class="headerlink" href="#return-statement" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">return</span></code> The statement is used to return the result of a function, that
is, the return value of the function. All functions in Berry have a
return value, but you can not use any <code class="docutils literal notranslate"><span class="pre">return</span></code> statement in the function
body. At this time, the interpreter will generate a default <code class="docutils literal notranslate"><span class="pre">return</span></code>
statement to ensure that the function returns. <code class="docutils literal notranslate"><span class="pre">return</span></code> There are two
ways to write sentences:</p>
<div class="algorithm">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>´return’
´return’ expression
</pre></div>
</div>
</div>
<p>The first way of writing is to write only the <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword and not
the expression to be returned. In this case, the default <code class="docutils literal notranslate"><span class="pre">nil</span></code> value is
returned. The second way of writing is to follow the expression
<strong>expression</strong> after the <code class="docutils literal notranslate"><span class="pre">return</span></code>
keyword, and the value of the expression will be used as the return
value of the function. When the program executes to the <code class="docutils literal notranslate"><span class="pre">return</span></code>
statement, the currently running function will end execution and return
to the code that called the function to continue running.</p>
<p>When using a separate keyword <code class="docutils literal notranslate"><span class="pre">return</span></code> as the return statement of a
function, it is easy to cause ambiguity. At this time, it is recommended
to add a semicolon after <code class="docutils literal notranslate"><span class="pre">return</span></code> to prevent errors:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def func()
    return;
    x = 1
end
</pre></div>
</div>
<p>In this example, the <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></code> statement after the <code class="docutils literal notranslate"><span class="pre">return</span></code> statement will
not be executed, so it is redundant. If this kind of redundant code is
avoided, the <code class="docutils literal notranslate"><span class="pre">return</span></code> statement is usually followed by keywords such as
<code class="docutils literal notranslate"><span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">else</span></code> or <code class="docutils literal notranslate"><span class="pre">elif</span></code>. In this case, even if a separate <code class="docutils literal notranslate"><span class="pre">return</span></code>
statement is used, there is no need to worry about ambiguity.</p>
</section>
</section>
<section id="closure">
<h2>closure<a class="headerlink" href="#closure" title="Permalink to this headline"></a></h2>
<section id="basic-concepts">
<h3>Basic Concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this headline"></a></h3>
<p>As mentioned earlier, functions are the first type of value in Berry.
You can define functions anywhere, and you can also pass functions as
parameters or return values. When another function is defined in a
function, the nested function can access the local variables of any
outer function. We call the “local variables of the outer function” used
in the function the function <strong>Free variable</strong>. The generalized free
variables also include global variables, but there is no such rule in
Berry.<strong>Closure</strong> is a technique that binds functions to
<strong>environments</strong>. The environment is a mapping that associates each free
variable of a function with a value. In terms of implementation,
closures associate the function prototype with its own variables.
Function prototypes are generated at compile time, and environment is a
runtime concept, so closures are also dynamically generated at runtime.
Each closure binds the function prototype to the environment when it is
generated, for example, in the following example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def func(i) # The outer function
    def foo() # The inner function (closure)
        print(i)
    end
    foo()
end
</pre></div>
</div>
<p>The inner function <code class="docutils literal notranslate"><span class="pre">foo</span></code> is a closure, which has a free variable <code class="docutils literal notranslate"><span class="pre">i</span></code>,
which is a parameter of the outer function <code class="docutils literal notranslate"><span class="pre">func</span></code>. When the closure
<code class="docutils literal notranslate"><span class="pre">foo</span></code> is generated, its function prototype is bound to the environment
containing the free variable <code class="docutils literal notranslate"><span class="pre">i</span></code>. When the variable <code class="docutils literal notranslate"><span class="pre">foo</span></code> leaves the
scope, the closure will be destroyed. Usually, the inner function will
be the return value of the outer function, for example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def func(i) # The outer function
    return def () # Return a closure (anonymous function)
        print(i)
        i = i + 1
    end
end
</pre></div>
</div>
<p>The closure returned here is an anonymous function. When the closure is
returned by the outer function, the local variables of the outer
function will be destroyed, and the closure will not be able to directly
access the variables in the original outer function. The system will
copy the value of the free variable to the environment when the free
variable is destroyed. The life cycle of these free variables is the
same as the closure, and can only be accessed by the closure. The
returned function or closure will not be executed automatically, so we
need to call the closure returned by the function <code class="docutils literal notranslate"><span class="pre">func</span></code>:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>f = func(0)
f()
</pre></div>
</div>
<p>This code will output <code class="docutils literal notranslate"><span class="pre">0</span></code>. If we continue to call the closure <code class="docutils literal notranslate"><span class="pre">f</span></code>, we
will get the output <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>… This may not be well understood:
variable [2.198 ] Is destroyed after the function <code class="docutils literal notranslate"><span class="pre">func</span></code> returns, and
as a free variable of the closure <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span></code> will be stored in the closure
environment, so every time <code class="docutils literal notranslate"><span class="pre">f</span></code> is called, the value of <code class="docutils literal notranslate"><span class="pre">i</span></code> will be added
to 1 (<code class="docutils literal notranslate"><span class="pre">func</span></code> function definition line 4).</p>
<section id="use-of-closures">
<h4>Use of closures<a class="headerlink" href="#use-of-closures" title="Permalink to this headline"></a></h4>
<p>Closures have many uses. Here are a few common uses:</p>
<section id="lazy-evaluation">
<h5>Lazy evaluation<a class="headerlink" href="#lazy-evaluation" title="Permalink to this headline"></a></h5>
<p>The closure does not do anything until it is called.</p>
</section>
<section id="function-private-communication">
<h5>Function private communication<a class="headerlink" href="#function-private-communication" title="Permalink to this headline"></a></h5>
<p>You can let some closures share free variables, which are only visible
to these closures, and communicate between functions by changing the
values of these free variables. This can avoid the use of external
variables.</p>
</section>
<section id="generate-multiple-functions">
<h5>Generate multiple functions<a class="headerlink" href="#generate-multiple-functions" title="Permalink to this headline"></a></h5>
<p>Sometimes we may need to use multiple functions, these functions may
only have different values of some variables. We can implement a
function and then use these different variables as function parameters.
A better way is to return the closure through a factory function, and
use these possibly different variables as free variables of the closure,
so that you don’t always have to write those parameters when calling the
function, and any number of similar functions can be generated.</p>
</section>
<section id="simulate-private-members">
<h5>Simulate private members<a class="headerlink" href="#simulate-private-members" title="Permalink to this headline"></a></h5>
<p>Some languages support the use of private members in objects, but
Berry’s class does not support private members. We can use the free
variables of closures to simulate private members. This use is not the
original intention of designing closures, but nowadays, this “misuse” of
closures is very common.</p>
</section>
<section id="cache-result">
<h5>Cache result<a class="headerlink" href="#cache-result" title="Permalink to this headline"></a></h5>
<p>If there is a function that is very time-consuming to run, it will take
a lot of time to call it every time. We can cache the result of this
function, look it up in the cache before calling the function, and
return the cached value if found, otherwise call the function and update
the cached value. We can use closures to save the cached value so that
it will not be exposed to the outer scope, and the cached result will be
retained (until the closure is destroyed).</p>
</section>
</section>
</section>
<section id="binding-free-variables">
<h3>Binding free variables<a class="headerlink" href="#binding-free-variables" title="Permalink to this headline"></a></h3>
<p>If multiple closures bind the same free variable, all closures will
always share this free variable. E.g:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def func(i) # The outer function
    return [# Return a closure list
        def () # The closure #1
            print(&quot;closure 1 log:&quot;, i)
            i = i + 1
        end,
        def () # The closure #2
            print(&quot;closure 2 log:&quot;, i)
            i = i + 1
        end
    ]
end
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">func</span></code> in this example returns two closures through a list,
and these two closures share free variables <code class="docutils literal notranslate"><span class="pre">i</span></code>. If we call these
closures:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>f = func(0)
f[0]() # closure 1 log: 0
f[1]() # closure 2 log: 1
</pre></div>
</div>
<p>As you can see, we updated the free variable <code class="docutils literal notranslate"><span class="pre">i</span></code> when we called the
closure <code class="docutils literal notranslate"><span class="pre">f[0]</span></code>, and this change affected the result of calling the
closure <code class="docutils literal notranslate"><span class="pre">f[1]</span></code>. This is because if a free variable is used by multiple
closures, there is only one copy of the free variable, and all closures
have a reference to the free variable entity. Therefore, any
modification to the free variable is visible to all closures that use
the free variable.</p>
<p>Similarly, before the local variables of the outer function are
destroyed, modifying the value of the free variable will also affect the
closure:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def func()
    i = 0
    def foo()
        print(i)
    end
    i = 1
    return foo
end
</pre></div>
</div>
<p>In this example, we change the value of the variable <code class="docutils literal notranslate"><span class="pre">i</span></code> (which is the
free variable of the closure <code class="docutils literal notranslate"><span class="pre">foo</span></code>) from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code> before the outer
function <code class="docutils literal notranslate"><span class="pre">func</span></code> returns, then we call the closure afterwards The value
of the free variable <code class="docutils literal notranslate"><span class="pre">i</span></code> when the package <code class="docutils literal notranslate"><span class="pre">foo</span></code> is also <code class="docutils literal notranslate"><span class="pre">1</span></code>:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>func()() # 1
</pre></div>
</div>
</section>
<section id="create-closure-in-loop">
<h3>Create closure in loop<a class="headerlink" href="#create-closure-in-loop" title="Permalink to this headline"></a></h3>
<p>When constructing a closure in the loop body, you may not want the free
variables of the closure to change with the loop variables. Let’s first
look at an example of creating a closure in a loop <code class="docutils literal notranslate"><span class="pre">while</span></code>:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def func()
    l = [] i = 0
    while i &lt;= 2
        l.push(def () print(i) end)
        i = i + 1
    end
    return l
end
</pre></div>
</div>
<p>In this example, we construct a closure in a loop and put this closure
in a <code class="docutils literal notranslate"><span class="pre">list</span></code>. Obviously, when the loop ends, the value of the variable
<code class="docutils literal notranslate"><span class="pre">i</span></code> will be <code class="docutils literal notranslate"><span class="pre">3</span></code>, and all the closures in the list <code class="docutils literal notranslate"><span class="pre">l</span></code> are also
references using this variable. If we execute the closure returned by
<code class="docutils literal notranslate"><span class="pre">func</span></code> we will get the same result:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>res = func()
res[0]() # 3
res[1]() # 3
res[2]() # 3
</pre></div>
</div>
<p>If we want each closure to refer to different free variables, we can
define another layer of functions, and then bind the current loop
variables with the function parameters:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def func()
    l = [] i = 0
    while i &lt;= 2
        l.push(def (n)
            return def () print(n) end
        end (i))
        i = i + 1
    end
    return l
end
</pre></div>
</div>
<p>To help understand this seemingly incomprehensible code, we focus on the
code from lines 4 to 6:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def (n)
    return def ()
        print(n)
    end
end (i)
</pre></div>
</div>
<p>Here actually defines an anonymous function and calls it immediately.
The function of this temporary anonymous function is to bind the value
of the loop variable <code class="docutils literal notranslate"><span class="pre">i</span></code> to its parameter <code class="docutils literal notranslate"><span class="pre">n</span></code>, and the variable <code class="docutils literal notranslate"><span class="pre">n</span></code> is
also what we need to close The free variables of the package, so that
the free variables bound to the closure constructed during each loop are
different. Now we will get the desired output:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>res = func()
res[0]() # 0
res[1]() # 1
res[2]() # 2
</pre></div>
</div>
<p>There are some ways to solve the problem of loop variables as free
variables. A slightly simpler way is to define a temporary variable in
the loop body:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def func()
    l = [] i = 0
    while i &lt;= 2
        temp = i
        l.push(def () print(temp) end)
        i = i + 1
    end
    return l
end
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">temp</span></code> is a temporary variable. The scope of this variable is in
the loop body, so it will be redefined every time it loops. We can also
use the <code class="docutils literal notranslate"><span class="pre">for</span></code> statement to solve the problem:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def func()
    l = []
    for i: 0 .. 2
        l.push(def () print(i) end)
    end
    return l
end
</pre></div>
</div>
<p>This may be the simplest way. <code class="docutils literal notranslate"><span class="pre">for</span></code> The iteration variable of the
statement will be created in each loop. The principle is similar to the
previous method.</p>
</section>
</section>
<section id="lambda-expression">
<h2>Lambda expression<a class="headerlink" href="#lambda-expression" title="Permalink to this headline"></a></h2>
<p><strong>Lambda expression</strong> is a special anonymous function. Lambda expression
is composed of parameter list and function body, but the form is
different from general function:</p>
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>´/´ args ´-&gt;´ expr ´end’
</pre></div>
</div>
<p><strong>args</strong> is the parameter list, the number of parameters can
be zero or more, and multiple parameters are separated by commas or
spaces (cannot be mixed at the same time); <strong>expr</strong> is the
return expression, the lambda expression will return the expression
value. Lambda expressions are suitable for implementing functions with
very simple functions. For example, the lambda expression for judging
the size of two numbers is:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>/ a b -&gt; a &lt; b
</pre></div>
</div>
<p>This is easier than writing a function of the same function. In some
general sorting algorithms, this type of size comparison function may
need to be used extensively. Using lambda expressions can simplify the
code and improve readability.</p>
<p>Like general functions, lambda expressions can form closures. Lambda
expressions are called in the same way as ordinary functions. If you use
the immediate calling method similar to anonymous functions:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>lambda = / a b -&gt; a &lt; b
result = lambda(1, 2) # normal calling
result = (/ a b -&gt; a &lt; b)(1, 2) # direct calling
</pre></div>
</div>
<p>Since the function call operator has a higher priority, a pair of
parentheses should be added to the lambda expression when making a
direct call, so that it will be called as a whole.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Guan Wenliang &amp; Stephan Hadinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
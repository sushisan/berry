<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6. Object Oriented Function &mdash; berry 1.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> berry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">6. Object Oriented Function</a><ul>
<li><a class="reference internal" href="#class-and-instance">6.1 Class and instance</a><ul>
<li><a class="reference internal" href="#class-declaration">6.1.1 Class declaration</a></li>
<li><a class="reference internal" href="#instantiate">Instantiate</a></li>
<li><a class="reference internal" href="#method-and-self-parameters">Method and <code class="docutils literal notranslate"><span class="pre">self</span></code> Parameters</a></li>
<li><a class="reference internal" href="#synthetic-methods">Synthetic methods</a></li>
<li><a class="reference internal" href="#class-variables-static">Class Variables <code class="docutils literal notranslate"><span class="pre">static</span></code></a></li>
<li><a class="reference internal" href="#class-methods-static">Class Methods <code class="docutils literal notranslate"><span class="pre">static</span></code></a></li>
<li><a class="reference internal" href="#constructor-and-destructor">Constructor and Destructor</a><ul>
<li><a class="reference internal" href="#constructor">Constructor</a></li>
<li><a class="reference internal" href="#destructor">Destructor</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-inheritance">Class inheritance</a></li>
<li><a class="reference internal" href="#method-overload">Method Overload</a><ul>
<li><a class="reference internal" href="#common-method-overload">Common method overload</a></li>
<li><a class="reference internal" href="#operator-overloading">Operator Overloading</a><ul>
<li><a class="reference internal" href="#overload-of-compound-assignment-operator">Overload of compound assignment operator</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#instance">Instance</a><ul>
<li><a class="reference internal" href="#access-base-class-object">Access base class object</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">berry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>6. Object Oriented Function</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/en/Chapter-6.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="object-oriented-function">
<h1>6. Object Oriented Function<a class="headerlink" href="#object-oriented-function" title="Permalink to this headline">¶</a></h1>
<p>For optimization considerations, Berry did not consider simple types as
objects. These simple types include <code class="docutils literal notranslate"><span class="pre">nil</span></code> types, numeric types, boolean
types, and string types. But Berry provides classes to implement the
object mechanism. Among Berry’s basic data types, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">map</span></code> and
<code class="docutils literal notranslate"><span class="pre">range</span></code> are class objects. An object is a collection containing data and
methods, where data is composed of some variables, and methods are
functions. The type of an object is called a class, and the entity of an
object is called an instance.</p>
<section id="class-and-instance">
<h2>6.1 Class and instance<a class="headerlink" href="#class-and-instance" title="Permalink to this headline">¶</a></h2>
<section id="class-declaration">
<h3>6.1.1 Class declaration<a class="headerlink" href="#class-declaration" title="Permalink to this headline">¶</a></h3>
<p>To use a class, you must first declare it. The declaration of a class
starts with the keyword <code class="docutils literal notranslate"><span class="pre">class</span></code>. The member variables and methods of the
class must be specified in the declaration. This is an example of
declaring a class:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">person</span><span class="w"></span>
<span class="w">    </span><span class="kr">static</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">majority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kr">self</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="w"></span>
<span class="w">        </span><span class="kr">self</span><span class="p">.</span><span class="na">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">tostring</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="ow">return</span><span class="w"> </span><span class="s1">&#39;name: &#39;</span><span class="o">+</span><span class="w"> </span><span class="nb">str</span><span class="p">(</span><span class="kr">self</span><span class="p">.</span><span class="na">name</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;, age:&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">str</span><span class="p">(</span><span class="kr">self</span><span class="p">.</span><span class="na">age</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">isadult</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="ow">return</span><span class="w"> </span><span class="kr">self</span><span class="p">.</span><span class="na">age</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="kr">self</span><span class="p">.</span><span class="na">majority</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="ow">end</span><span class="w"></span>
</pre></div>
</div>
<p>Class member variables are declared with keyword <code class="docutils literal notranslate"><span class="pre">var</span></code>, while member
methods are declared with keyword <code class="docutils literal notranslate"><span class="pre">def</span></code>. Currently, Berry does not
support initializing member variables at the time of definition, so the
initialization of member variables should be done by the constructor.
The properties of the class cannot be modified after the declaration is
completed, so the class is a read-only object.</p>
<p>This design is to ensure that the class can be statically
constructed in the C language when the interpreter is implemented and
the <code class="docutils literal notranslate"><span class="pre">const</span></code> property can be used Modified to save RAM</p>
<p>Berry’s class does not support access restrictions, and all properties
of the class are visible to the outside. In native classes, you can use
some tricks to make properties invisible to Berry code (usually let the
member name start with dot “.”). You can use some conventions to restrict
access to the members of the class, such as the convention that the
attributes starting with an underscore are private attributes. This
convention does not have any use at the grammatical level, but is
conducive to the logical structure of the code.</p>
</section>
<section id="instantiate">
<h3>Instantiate<a class="headerlink" href="#instantiate" title="Permalink to this headline">¶</a></h3>
<p>The class itself is just an abstract description. Taking cars as an
example, I know the concept of cars, and when we really want to use
cars, we need real cars. The use of classes is similar. We will not only
use this abstract description, but need to produce a concrete object
based on this description. This process is called <strong>Instantiation of the
class</strong>, abbreviated as instantiation, and the concrete object produced
by instantiation is called <strong>Instance</strong>. The class itself does not have
data, and instantiation produces an instance based on the information
described by the class and gives the instance specific data.</p>
</section>
<section id="method-and-self-parameters">
<h3>Method and <code class="docutils literal notranslate"><span class="pre">self</span></code> Parameters<a class="headerlink" href="#method-and-self-parameters" title="Permalink to this headline">¶</a></h3>
<p>Class methods are essentially functions. Unlike ordinary functions,
methods implicitly pass in a <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter, and is always the first
parameter, which stores a reference to the current instance. Due to the
existence of <code class="docutils literal notranslate"><span class="pre">self</span></code> parameters, the number of parameters of the method
will be one more than the number of parameters defined in the
declaration. Here we use a simple example to demonstrate:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Test</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">method</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="ow">return</span><span class="w"> </span><span class="kr">self</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="ow">end</span><span class="w"></span>
<span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">Test</span><span class="p">()</span><span class="w"></span>
<span class="nb">print</span><span class="p">(</span><span class="n">object</span><span class="p">)</span><span class="w"></span>
<span class="nb">print</span><span class="p">(</span><span class="n">object</span><span class="p">.</span><span class="nf">method</span><span class="p">())</span><span class="w"></span>
</pre></div>
</div>
<p>This example defines a <code class="docutils literal notranslate"><span class="pre">Test</span></code> class, which has a <code class="docutils literal notranslate"><span class="pre">method</span></code> method, which
returns its <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter. The last two lines in the routine print
the value of the instance <code class="docutils literal notranslate"><span class="pre">object</span></code> of the <code class="docutils literal notranslate"><span class="pre">Test</span></code> class and the return
value of the method <code class="docutils literal notranslate"><span class="pre">method</span></code> respectively. The running result of this
example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">instance</span><span class="p">:</span> <span class="n">Test</span><span class="p">()</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">instance</span><span class="p">:</span> <span class="n">Test</span><span class="p">()</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>It can be seen that the <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter of the method and the name of
the use instance (<code class="docutils literal notranslate"><span class="pre">object</span></code> in the example) both represent the same
object, and they are both instance references. Use <code class="docutils literal notranslate"><span class="pre">self</span></code> to access the
members or attributes of the instance in the method.</p>
</section>
<section id="synthetic-methods">
<h3>Synthetic methods<a class="headerlink" href="#synthetic-methods" title="Permalink to this headline">¶</a></h3>
<p>You can declare synthetic dynamic members and methods using the
<strong>Virtual members</strong> as described in Chapter 8.2.</p>
</section>
<section id="class-variables-static">
<h3>Class Variables <code class="docutils literal notranslate"><span class="pre">static</span></code><a class="headerlink" href="#class-variables-static" title="Permalink to this headline">¶</a></h3>
<p>Variables or functions can be declared <code class="docutils literal notranslate"><span class="pre">static</span></code>.
Static variables have the same value for all instances of the same class.
They are declare as <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">var</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span></code>.
Static variables are initialized right after the creation of the class.</p>
</section>
<section id="class-methods-static">
<h3>Class Methods <code class="docutils literal notranslate"><span class="pre">static</span></code><a class="headerlink" href="#class-methods-static" title="Permalink to this headline">¶</a></h3>
<p>Methods can be declared <code class="docutils literal notranslate"><span class="pre">static</span></code> which means that they act like
regular function and do not take <code class="docutils literal notranslate"><span class="pre">self</span></code> as first argument.
Within static methods, there is no implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> variable declared.
Static methods can be called via the class or via an instance.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>&gt; class static_demo
      static def increment_static(i)
          return i + 1
      end
      def increment_instance(i)
          return i + 1
      end
  end
&gt; a = static_demo()
&gt; static_demo.increment_static(1)    # call via class
2
&gt; a.increment_static(1)              # call via instance
&gt; 
&gt; static_demo.increment_instance(1)
type_error: unsupported operand type(s) for +: &#39;nil&#39; and &#39;int&#39;
stack traceback:
   stdin:6: in function `increment_instance`
   stdin:1: in function `main`
&gt; a.increment_instance(1)
2
</pre></div>
</div>
</section>
<section id="constructor-and-destructor">
<h3>Constructor and Destructor<a class="headerlink" href="#constructor-and-destructor" title="Permalink to this headline">¶</a></h3>
<section id="constructor">
<h4>Constructor<a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h4>
<p>The constructor of the class is the <code class="docutils literal notranslate"><span class="pre">init</span></code> method. The constructor is
called when the class is instantiated. Therefore, the constructor is
generally used for member initialization, for example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Test</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kr">self</span><span class="p">.</span><span class="na">a</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;this is a test&#39;</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="ow">end</span><span class="w"></span>
</pre></div>
</div>
<p>The constructor in this example initializes the <code class="docutils literal notranslate"><span class="pre">a</span></code> member of the <code class="docutils literal notranslate"><span class="pre">Test</span></code>
class to the string <code class="docutils literal notranslate"><span class="pre">’this</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">test’</span></code>. If we instantiate the class, we
can get the value of member <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nf">Test</span><span class="p">().</span><span class="na">a</span><span class="p">)</span><span class="w"> </span><span class="c1"># this is a test</span>
</pre></div>
</div>
</section>
<section id="destructor">
<h4>Destructor<a class="headerlink" href="#destructor" title="Permalink to this headline">¶</a></h4>
<p>The destructor of the class is the <code class="docutils literal notranslate"><span class="pre">deinit</span></code> method. The destructor is
called when the instance is destroyed. The destructor is generally used
to complete some cleanup work. Because the garbage collection mechanism
automatically releases the memory of useless objects, there is no need
to release the memory in the destructor (and there is no way to release
the memory in the destructor). In most cases, there is no need to use a
destructor, unless a certain class requires certain processing when it
is destroyed. A typical example is that a file object must close the
file when it is destroyed.</p>
</section>
</section>
</section>
<section id="class-inheritance">
<h2>Class inheritance<a class="headerlink" href="#class-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Berry only supports single inheritance, that is, a class can only have
one base class, and the base class uses the operator <code class="docutils literal notranslate"><span class="pre">:</span></code> to declare:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Test</span><span class="o">:</span><span class="w"> </span><span class="n">Base</span><span class="w"></span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="ow">end</span><span class="w"></span>
</pre></div>
</div>
<p>Here the <code class="docutils literal notranslate"><span class="pre">Test</span></code> class inherits from the <code class="docutils literal notranslate"><span class="pre">Base</span></code> class. The subclass will
inherit all the methods and properties of the base class, and you can
override them in the subclass. This mechanism is called <strong>Overload</strong>.
Under normal circumstances, we will only overload methods, not
properties.</p>
<p>The inheritance mechanism of the Berry class is relatively simple.
Subclasses will contain references to the base class, and instance
objects are similar. When instantiating a class with a base class,
multiple objects are actually generated. These objects will be chained
together according to the inheritance relationship, and finally we will
get the instance object at the end of the inheritance chain.</p>
</section>
<section id="method-overload">
<h2>Method Overload<a class="headerlink" href="#method-overload" title="Permalink to this headline">¶</a></h2>
<p><strong>Overload</strong> means that the subclass and the base class use the same
name method, and the subclass method will override the mechanism of the
base class method. To be precise, member variables can also be
overloaded, but this overloading has no meaning. Method overloading is
divided into ordinary method overloading and operator overloading.</p>
<section id="common-method-overload">
<h3>Common method overload<a class="headerlink" href="#common-method-overload" title="Permalink to this headline">¶</a></h3>
</section>
<section id="operator-overloading">
<h3>Operator Overloading<a class="headerlink" href="#operator-overloading" title="Permalink to this headline">¶</a></h3>
<p>You can use the operator overloading of the class to make the instance
support the operation of the built-in operator. For example, for a class
overloaded with the addition operator, we can use the addition operator
to perform operations on the instance. An overloaded operator is a
method with a special name, and the overloaded function form of a binary
operator is</p>
<div class="algorithm">
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>´def’ operator ´(´ other ´)´
  block
´end’
</pre></div>
</div>
</div>
<p><strong>operator</strong> is an overloaded binary
operator. The left operand of the binary operator is the <code class="docutils literal notranslate"><span class="pre">self</span></code> object,
and the right operand is the value of the parameter
<strong>other</strong>. The overloaded function form of the unary
operator is</p>
<div class="algorithm">
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>´def’ operator ´()´
  block
´end’
</pre></div>
</div>
</div>
<p><strong>operator</strong> is an overloaded unary
operator. To distinguish it from the subtraction operator, the unary
minus sign is written as <code class="docutils literal notranslate"><span class="pre">-*</span></code> when overloaded. Operator overloaded
functions should have a return value, because the default <code class="docutils literal notranslate"><span class="pre">nil</span></code> return
value is usually not the expected result. Let’s take an integer class as
an example to illustrate the use of operator overloading. First define
the <code class="docutils literal notranslate"><span class="pre">integer</span></code> class:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">integer</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kr">self</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="o">+</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="ow">return</span><span class="w"> </span><span class="nf">integer</span><span class="p">(</span><span class="kr">self</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="na">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="ow">return</span><span class="w"> </span><span class="nf">integer</span><span class="p">(</span><span class="kr">self</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="na">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="o">-*</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="ow">return</span><span class="w"> </span><span class="nf">integer</span><span class="p">(</span><span class="o">-</span><span class="kr">self</span><span class="p">.</span><span class="na">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">tostring</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="ow">return</span><span class="w"> </span><span class="nb">str</span><span class="p">(</span><span class="kr">self</span><span class="p">.</span><span class="na">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="ow">end</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">integer</span></code> class overloads the plus, multiplication, and symbolic
operators, and the <code class="docutils literal notranslate"><span class="pre">tostring</span></code> method is to make the instance use the
<code class="docutils literal notranslate"><span class="pre">print</span></code> function to output the result. We can use a simple line of code
to test the operator overloading function of the class:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="nf">integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">integer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="nf">integer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1"># -5</span>
</pre></div>
</div>
<p>The result of this line of code is an instance of <code class="docutils literal notranslate"><span class="pre">integer</span></code>. The value
of the <code class="docutils literal notranslate"><span class="pre">value</span></code> member of this instance is <code class="docutils literal notranslate"><span class="pre">-5</span></code>, which is the same as the
result of the same four arithmetic operations on integers.</p>
<p>Logical operators cannot be overloaded directly. If you need an instance
to support logical operations, you must implement the <code class="docutils literal notranslate"><span class="pre">tobool</span></code> method.
The method has no parameters and the return value must be of Boolean
type. The logic operation of the instance is actually realized by
converting the instance into a Boolean value, so the logic operation of
the instance is completely in line with the nature of the general logic
operation. The subscript operator is not directly overloaded, but is
implemented by the methods <code class="docutils literal notranslate"><span class="pre">item</span></code> and <code class="docutils literal notranslate"><span class="pre">setitem</span></code>. <code class="docutils literal notranslate"><span class="pre">item</span></code> The method is
used for subscript reading, its first parameter is the subscript value,
and the return value is the result of the subscript operation; <code class="docutils literal notranslate"><span class="pre">setitem</span></code>
is used for subscript writing, and its first parameter is the subscript
Value, the second parameter is the value to be written, this method does
not use the return value.</p>
<p>The overloaded operator can be assigned any meaning, even not satisfying
the usual properties of operators. Considering the versatility of the
code and the difficulty of understanding, it is not recommended that
users give overloaded operators a function far from the general meaning.</p>
<section id="overload-of-compound-assignment-operator">
<h4>Overload of compound assignment operator<a class="headerlink" href="#overload-of-compound-assignment-operator" title="Permalink to this headline">¶</a></h4>
<p>The compound assignment operator cannot be directly overloaded, but we
can achieve the purpose of “overloading” the compound assignment
operator by overloading the binary operator corresponding to the
compound assignment operator. For example, after overloading the “<code class="docutils literal notranslate"><span class="pre">+</span></code>”
operator, you can use the “<code class="docutils literal notranslate"><span class="pre">+=</span></code>” operator for instances of related
classes. It is worth noting that the use of compound assignment
operations on the instance will cause the variables of the bound
instance to lose their reference to the instance.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">integer</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kr">self</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="o">+</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="ow">return</span><span class="w"> </span><span class="nf">integer</span><span class="p">(</span><span class="kr">self</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="na">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="ow">end</span><span class="w"></span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">integer</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1"># a: &lt;instance: 0x55edff400a78&gt;</span>
<span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nf">integer</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1"># a: &lt;instance: 0x55edff4011b8&gt;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="na">value</span><span class="p">)</span><span class="w"> </span><span class="c1"># 9</span>
</pre></div>
</div>
<p>After the 11th line of code is executed, the instance bound in the
variable <code class="docutils literal notranslate"><span class="pre">a</span></code> has actually changed. This line of code is equivalent to
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">integer(4)</span> <span class="pre">+</span> <span class="pre">integer(5)</span></code>. If the binary operator of the class
overload does not modify the state of the instance, then the
corresponding compound assignment operator will not modify any instance
(it may generate new instances).</p>
</section>
</section>
</section>
<section id="instance">
<h2>Instance<a class="headerlink" href="#instance" title="Permalink to this headline">¶</a></h2>
<p><strong>Instance</strong> is an object generated after class instantiation. A class
can be instantiated multiple times to generate different instances.
Berry instances are referenced by the class they belong to and the
corresponding data fields. All instances of a class will refer to this
class, but the data fields of these instances are independent of each
other.</p>
<section id="access-base-class-object">
<h3>Access base class object<a class="headerlink" href="#access-base-class-object" title="Permalink to this headline">¶</a></h3>
<p>The built-in function <code class="docutils literal notranslate"><span class="pre">super</span></code> is used to access super class objects.
It can be used on classes or instances.</p>
<p>Magic happens when you call a method from the superclass so that it
behaves like you intuitively think it would.
For example, the common pattern for <code class="docutils literal notranslate"><span class="pre">init()</span></code> is as follows:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="o">&lt;</span><span class="n">args</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c1"># do stuff before super init</span>
<span class="w">    </span><span class="kr">super</span><span class="p">(</span><span class="kr">self</span><span class="p">).</span><span class="nf">init</span><span class="p">(</span><span class="o">&lt;</span><span class="n">args</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c1"># do stuff after super init</span>
<span class="ow">end</span><span class="w"></span>
</pre></div>
</div>
<p>Note that classes always contains an implicit <code class="docutils literal notranslate"><span class="pre">init()</span></code> methods that
does nothing, so you can always call init from super class even if
no <code class="docutils literal notranslate"><span class="pre">init()</span></code> method was declared.</p>
<p>Full example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">A</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">val</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1"># super(self).init(val)    # this would be valid but useless</span>
<span class="w">        </span><span class="kr">self</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">tostring</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="ow">return</span><span class="w"> </span><span class="s2">&quot;val=&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">str</span><span class="p">(</span><span class="kr">self</span><span class="p">.</span><span class="na">val</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="ow">end</span><span class="w"></span>

<span class="kd">class</span> <span class="nc">B</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">magic</span><span class="w">    </span><span class="c1"># true if value is 42</span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kr">super</span><span class="p">(</span><span class="kr">self</span><span class="p">).</span><span class="nf">init</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w">     </span><span class="c1"># call super init</span>
<span class="w">        </span><span class="kr">self</span><span class="p">.</span><span class="na">magic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="kd">def</span><span class="w"> </span><span class="nf">tostring</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="ow">if</span><span class="w"> </span><span class="kr">self</span><span class="p">.</span><span class="na">magic</span><span class="w"></span>
<span class="w">            </span><span class="ow">return</span><span class="w"> </span><span class="s2">&quot;magic!&quot;</span><span class="w"></span>
<span class="w">        </span><span class="ow">else</span><span class="w"></span>
<span class="w">            </span><span class="ow">return</span><span class="w"> </span><span class="kr">super</span><span class="p">(</span><span class="kr">self</span><span class="p">).</span><span class="nf">tostring</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="ow">end</span><span class="w"></span>
<span class="w">    </span><span class="ow">end</span><span class="w"></span>
<span class="ow">end</span><span class="w"></span>

<span class="c1">####### Example of usage</span>

<span class="o">&gt;</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">B</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">b1</span><span class="w"></span>
<span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">b42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">B</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">b42</span><span class="w"></span>
<span class="n">magic</span><span class="o">!</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Advanced features</strong> When calling <code class="docutils literal notranslate"><span class="pre">super(self).&lt;method&gt;(&lt;args&gt;)</span></code> some magic happens. When the super-method is called, the <code class="docutils literal notranslate"><span class="pre">self</span></code> arguments refers to
the lowest more specific class. However the <code class="docutils literal notranslate"><span class="pre">&lt;method&gt;</span></code> if searched not
from the class of <code class="docutils literal notranslate"><span class="pre">self</span></code> (which is always the lowest), but from the
super class of the class containing the method currently running.</p>
<p>Example:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kd">class</span> <span class="nc">A</span><span class="w"></span>
<span class="w">      </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In A::init, self is of type&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">classname</span><span class="p">(</span><span class="kr">self</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="ow">end</span><span class="w"></span>
<span class="w">  </span><span class="ow">end</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="kd">class</span> <span class="nc">B</span><span class="o">:</span><span class="n">A</span><span class="w"></span>
<span class="w">      </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In B::init, self is of type&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">classname</span><span class="p">(</span><span class="kr">self</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="kr">super</span><span class="p">(</span><span class="kr">self</span><span class="p">).</span><span class="nf">init</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="ow">end</span><span class="w"></span>
<span class="w">  </span><span class="ow">end</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="kd">class</span> <span class="nc">C</span><span class="o">:</span><span class="n">B</span><span class="w"></span>
<span class="w">      </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In C::init, self is of type&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">classname</span><span class="p">(</span><span class="kr">self</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="kr">super</span><span class="p">(</span><span class="kr">self</span><span class="p">).</span><span class="nf">init</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="ow">end</span><span class="w"></span>
<span class="w">  </span><span class="ow">end</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">C</span><span class="p">()</span><span class="w"></span>
<span class="n">In</span><span class="w"> </span><span class="n">C</span><span class="o">::</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="kr">self</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="n">C</span><span class="w"></span>
<span class="n">In</span><span class="w"> </span><span class="n">B</span><span class="o">::</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="kr">self</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="n">C</span><span class="w"></span>
<span class="n">In</span><span class="w"> </span><span class="n">A</span><span class="o">::</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="kr">self</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="n">C</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span>
</pre></div>
</div>
<p>Explanation:</p>
<ul class="simple">
<li><p>calling <code class="docutils literal notranslate"><span class="pre">C:init()</span></code> on <code class="docutils literal notranslate"><span class="pre">instance&lt;C&gt;</span></code></p></li>
<li><p>in <code class="docutils literal notranslate"><span class="pre">C:init()</span></code> <code class="docutils literal notranslate"><span class="pre">self</span></code> is <code class="docutils literal notranslate"><span class="pre">instance&lt;C&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">super(self).init()</span></code> refers to the super class of <code class="docutils literal notranslate"><span class="pre">C</span></code> (current method) i.e. <code class="docutils literal notranslate"><span class="pre">B</span></code>, so <code class="docutils literal notranslate"><span class="pre">B:init()</span></code> is called with <code class="docutils literal notranslate"><span class="pre">instance&lt;C&gt;</span></code> argument</p></li>
<li><p>in <code class="docutils literal notranslate"><span class="pre">B:init()</span></code> <code class="docutils literal notranslate"><span class="pre">self</span></code> is <code class="docutils literal notranslate"><span class="pre">instance&lt;C&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">super(self).init()</span></code> refers to the super class of <code class="docutils literal notranslate"><span class="pre">B</span></code> (current method) i.e. <code class="docutils literal notranslate"><span class="pre">A</span></code>, so <code class="docutils literal notranslate"><span class="pre">A:init()</span></code> is called with <code class="docutils literal notranslate"><span class="pre">instance&lt;C&gt;</span></code> argument</p></li>
<li><p>in <code class="docutils literal notranslate"><span class="pre">A:init()</span></code> <code class="docutils literal notranslate"><span class="pre">self</span></code> is <code class="docutils literal notranslate"><span class="pre">instance&lt;C&gt;</span></code>, print and return</p></li>
</ul>
<p>Note: for backwards compatibility, super can take a second argument <code class="docutils literal notranslate"><span class="pre">super(instance,</span> <span class="pre">class)</span></code> to specify the class where to resolve the method.
This feature should not be used anymore as it is error-prone.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Guan Wenliang &amp; Stephan Hadinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
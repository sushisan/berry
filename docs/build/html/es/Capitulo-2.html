<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. Tipos y Variables &mdash; berry 1.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> berry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">2. Tipos y Variables</a><ul>
<li><a class="reference internal" href="#tipo-incorporado">2.1 Tipo incorporado</a><ul>
<li><a class="reference internal" href="#tipo-simple">2.1.1 Tipo simple</a><ul>
<li><a class="reference internal" href="#nil"><code class="docutils literal notranslate"><span class="pre">nil</span></code></a></li>
<li><a class="reference internal" href="#tipo-entero">Tipo entero</a></li>
<li><a class="reference internal" href="#tipo-de-numero-real">Tipo de número real</a></li>
<li><a class="reference internal" href="#tipo-booleano">Tipo booleano</a></li>
<li><a class="reference internal" href="#cadena">Cadena</a></li>
<li><a class="reference internal" href="#funcion">Función</a></li>
<li><a class="reference internal" href="#clase">Clase</a></li>
<li><a class="reference internal" href="#ejemplos">Ejemplos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tipo-de-clase">2.1.2 Tipo de clase</a><ul>
<li><a class="reference internal" href="#lista">Lista</a></li>
<li><a class="reference internal" href="#mapa">Mapa</a></li>
<li><a class="reference internal" href="#rango">Rango</a></li>
<li><a class="reference internal" href="#bytes">Bytes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#variables">2.2 Variables</a><ul>
<li><a class="reference internal" href="#definir-variables">2.2.1 Definir variables</a></li>
<li><a class="reference internal" href="#alcance-y-ciclo-de-vida">2.2.2 Alcance y Ciclo de Vida</a><ul>
<li><a class="reference internal" href="#alcance-anidado">Alcance anidado</a></li>
<li><a class="reference internal" href="#ciclo-de-vida-variable">Ciclo de vida variable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tipo-de-variable">2.2.3 Tipo de variable</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">berry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>2. Tipos y Variables</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/es/Capitulo-2.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <!-- Spanish Translation: Emiliano Gonzalez (egonzalez . hiperion @ gmail . com) -->
<section id="tipos-y-variables">
<h1>2. Tipos y Variables<a class="headerlink" href="#tipos-y-variables" title="Permalink to this headline">¶</a></h1>
<p><strong>Tipo</strong> es un atributo de datos, que define el significado de los datos y las operaciones que se pueden realizar en los datos. Los tipos se pueden dividir en tipos integrados y tipos definidos por el usuario. Los tipos integrados se refieren a algunos tipos básicos integrados en el lenguaje Berry, entre los cuales los tipos que no se basan en definiciones de clase se denominan <strong>Tipo simple</strong>.
Los tipos basados en definiciones de clase se denominan <strong>Tipo de clase</strong>, algunos de los tipos integrados son tipos de clase y los tipos definidos por el usuario también son tipos de clase.</p>
<section id="tipo-incorporado">
<h2>2.1 Tipo incorporado<a class="headerlink" href="#tipo-incorporado" title="Permalink to this headline">¶</a></h2>
<section id="tipo-simple">
<h3>2.1.1 Tipo simple<a class="headerlink" href="#tipo-simple" title="Permalink to this headline">¶</a></h3>
<section id="nil">
<h4><code class="docutils literal notranslate"><span class="pre">nil</span></code><a class="headerlink" href="#nil" title="Permalink to this headline">¶</a></h4>
<p>El tipo Nil es el tipo nulo, lo que significa que el objeto tiene un valor no válido, o se puede decir que el objeto no tiene un valor significativo. Este es un tipo muy especial. Aunque podríamos decir que una variable es <code class="docutils literal notranslate"><span class="pre">nil</span></code>, de hecho el tipo nil no tiene valor, entonces de lo que estamos hablando aquí es que el tipo de la variable es nil (no un valor).</p>
<p>El valor predeterminado de una variable antes de la asignación es <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Este tipo se puede utilizar en operaciones lógicas. En este caso ‘nil’ es equivalente a ‘falso’.</p>
</section>
<section id="tipo-entero">
<h4>Tipo entero<a class="headerlink" href="#tipo-entero" title="Permalink to this headline">¶</a></h4>
<p>El tipo entero (integer) representa un entero con signo, denominado entero. El número de bits del entero representado por este tipo depende de la implementación específica y, por lo general, consta de un entero de 32 bits con signo en una plataforma de 32 bits. Integer es un tipo aritmético y admite todas las operaciones aritméticas. Preste atención al rango de valores de los enteros cuando use este tipo. El rango de valores típico de los enteros con signo de 32 bits está entre −2147483648 y 2147483647.</p>
<p>Cualquier valor se puede convertir a <code class="docutils literal notranslate"><span class="pre">int</span></code> usando la función <code class="docutils literal notranslate"><span class="pre">int()</span></code>; sin embargo <code class="docutils literal notranslate"><span class="pre">int(nil)</span> <span class="pre">==</span> <span class="pre">nil</span></code>. Si el argumento es una instancia, y si contiene un miembro <code class="docutils literal notranslate"><span class="pre">toint()</span></code>, se nos llamará y el valor devuelto se convertirá en <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</section>
<section id="tipo-de-numero-real">
<h4>Tipo de número real<a class="headerlink" href="#tipo-de-numero-real" title="Permalink to this headline">¶</a></h4>
<p>El tipo real (real), para ser precisos, es un tipo de coma flotante. Los tipos de números reales generalmente se implementan como números de punto flotante de precisión simple o números de punto flotante de precisión doble. El tipo de número real también es un tipo aritmético. En comparación con el tipo de número entero, el tipo de número real tiene mayor precisión y un mayor rango de valores, por lo que este tipo es más adecuado para cálculos matemáticos. Cabe señalar que el tipo de número real es en realidad un número de coma flotante, por lo que aun existen problemas de precisión. Por ejemplo, no se recomienda comparar dos valores de tipo <code class="docutils literal notranslate"><span class="pre">real</span></code> para la igualdad.</p>
<p>Cuando los enteros y los números reales participan en operaciones al mismo tiempo, los enteros generalmente se convierten en números reales.</p>
</section>
<section id="tipo-booleano">
<h4>Tipo booleano<a class="headerlink" href="#tipo-booleano" title="Permalink to this headline">¶</a></h4>
<p>El tipo booleano (boolean) se utiliza para operaciones lógicas. Tiene dos valores <code class="docutils literal notranslate"><span class="pre">true</span></code> y <code class="docutils literal notranslate"><span class="pre">false</span></code>, que representan los dos valores verdaderos (verdadero y falso) en lógica y álgebra booleana. El tipo booleano se utiliza principalmente para el juicio condicional. Los operandos y los valores devueltos de las expresiones lógicas y las expresiones relacionales son todos de tipo booleano, y las sentencias como <code class="docutils literal notranslate"><span class="pre">if</span></code> y <code class="docutils literal notranslate"><span class="pre">while</span></code> utilizan tipos booleanos como comprobaciones condicionales.</p>
<p>En muchos casos, los valores no booleanos también se pueden usar como tipos booleanos.
Esto se debe a que el intérprete convertirá implícitamente los parámetros.
Esta es también la razón por la que las expresiones de verificación condicional, como las declaraciones <code class="docutils literal notranslate"><span class="pre">if</span></code>, pueden usar cualquier tipo de parámetros. Las reglas para convertir varios tipos a tipos booleanos son:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nil</span></code>: convertido a <code class="docutils literal notranslate"><span class="pre">falso</span></code>.</p></li>
<li><p><strong>Entero</strong>: cuando el valor es <code class="docutils literal notranslate"><span class="pre">0</span></code>, se convierte en <code class="docutils literal notranslate"><span class="pre">falso</span></code>,
de lo contrario, se convierte en <code class="docutils literal notranslate"><span class="pre">verdadero</span></code>.</p></li>
<li><p><strong>Número real</strong>: cuando el valor es <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, se convierte en <code class="docutils literal notranslate"><span class="pre">falso</span></code>,
de lo contrario, se convierte en <code class="docutils literal notranslate"><span class="pre">verdadero</span></code>.</p></li>
<li><p><strong>Cadena</strong>: cuando el valor es “” (cadena vacía) se convierte en <code class="docutils literal notranslate"><span class="pre">falso</span></code>
de lo contrario, se convierte en <code class="docutils literal notranslate"><span class="pre">verdadero</span></code>.</p></li>
<li><p><strong>Comobj</strong> y <strong>Comptr</strong>: cuando el puntero interno es <code class="docutils literal notranslate"><span class="pre">NULL</span></code> es
convertido a <code class="docutils literal notranslate"><span class="pre">falso</span></code>, de lo contrario se convierte a <code class="docutils literal notranslate"><span class="pre">verdadero</span></code>.</p></li>
<li><p><strong>Instancia</strong>: si la instancia contiene un método <code class="docutils literal notranslate"><span class="pre">tobool()</span></code>,
se utilizará el valor de retorno del método,
de lo contrario, se convertirá en <code class="docutils literal notranslate"><span class="pre">verdadero</span></code>.</p></li>
<li><p>Todos los demás tipos: converten a <code class="docutils literal notranslate"><span class="pre">verdadero</span></code>.</p></li>
</ul>
<p>Cualquier valor se puede convertir a <code class="docutils literal notranslate"><span class="pre">bool</span></code> usando la función <code class="docutils literal notranslate"><span class="pre">bool()</span></code>.</p>
</section>
<section id="cadena">
<h4>Cadena<a class="headerlink" href="#cadena" title="Permalink to this headline">¶</a></h4>
<p>Una cadena es una secuencia de caracteres. En términos de almacenamiento, Berry divide las cadenas en cadenas largas y cadenas cortas. Solo hay una instancia de la misma cadena de caracteres cortos en la memoria, y todas las cadenas de caracteres cortos están vinculadas en una tabla hash. Este diseño ayuda a mejorar el rendimiento de la comparación de igualdad de cadenas y puede reducir el uso de memoria.
Dado que la frecuencia de uso de cadenas largas es baja y la sobrecarga de la operación hash es bastante alta, no están vinculadas a la tabla hash, por lo que puede haber varias instancias idénticas en la memoria. La cadena es de solo lectura después de que se crea. Por lo tanto, “modificar” la cadena generará una nueva cadena y la cadena original no se modificará.</p>
<p>Berry no se preocupa por el formato o la codificación de los caracteres. Por ejemplo, la cadena <code class="docutils literal notranslate"><span class="pre">'abc'</span></code> es en realidad el código ASCII de los caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'b'</span></code> y <code class="docutils literal notranslate"><span class="pre">'c'</span></code>. Por lo tanto, si hay caracteres anchos en la cadena (la longitud de los caracteres es superior a 1 byte), el número de caracteres de la cadena no se puede contar directamente. De hecho, usar la función <code class="docutils literal notranslate"><span class="pre">size()</span></code> solo puede obtener el número de bytes en la cadena. Además, para facilitar la interacción con el lenguaje C, la cadena de Berry siempre termina con los caracteres <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>. Esta función es transparente para el programa Berry.</p>
<p>El tipo de cadena se puede comparar en tamaño, por lo que se puede usar en operaciones relacionales.</p>
</section>
<section id="funcion">
<h4>Función<a class="headerlink" href="#funcion" title="Permalink to this headline">¶</a></h4>
<p>Una función es una pieza de código que está encapsulada y disponible para llamadas, generalmente utilizada para implementar una función específica. La función es en realidad una categoría grande, que incluye varios subtipos, como cierres, funciones nativas y cierres nativos. Para el código Berry, todos los subtipos de funciones tienen el mismo comportamiento. Las funciones pertenecen al primer tipo de valor en Berry, por lo que se pueden pasar como valores. Además, se puede usar directamente en expresiones a través de la forma “literal” de “funciones anónimas”.</p>
<p>Una función es un objeto de solo lectura y no se puede modificar una vez definida.
Puede comparar si dos funciones son iguales (si son la misma función), pero no se puede comparar el tipo de función. <strong>Función nativa</strong> y <strong>Cierre nativo</strong> se refieren a funciones y cierres implementados en lenguaje C. Uno de los propósitos principales de las funciones nativas y los cierres nativos es proporcionar funciones que el lenguaje Berry no proporciona, como operaciones de E/S y operaciones de bajo nivel. Si un fragmento de código se usa con frecuencia y tiene requisitos de rendimiento, se recomienda reescribirlo como una función nativa o un cierre nativo.</p>
</section>
<section id="clase">
<h4>Clase<a class="headerlink" href="#clase" title="Permalink to this headline">¶</a></h4>
<p>En la programación orientada a objetos, una clase es una plantilla de código de programa extensible. Las clases se utilizan para crear objetos de instancia, por lo que se puede decir que la clase es el “tipo” de la instancia. Todos los objetos de instancia son del tipo <code class="docutils literal notranslate"><span class="pre">instancia</span></code> y todos tienen una clase correspondiente, que se llama instancia <strong>Tipo de clase</strong>. En pocas palabras, una clase es un valor que representa el tipo de un objeto de instancia y una clase es una abstracción de las características de una instancia. Una clase también es un objeto de solo lectura, una vez definida, no se puede modificar.</p>
<p>Las clases solo pueden comparar iguales y desiguales, pero no pueden comparar tamaños.</p>
</section>
<section id="ejemplos">
<h4>Ejemplos<a class="headerlink" href="#ejemplos" title="Permalink to this headline">¶</a></h4>
<p>Una instancia es un objeto materializado generado por una clase, y el proceso de generar una instancia a partir de una clase se llama <code class="docutils literal notranslate"><span class="pre">Instanciación</span></code>.
En la programación orientada a objetos, “instancia” suele ser sinónimo de “objeto”. Sin embargo, para distinguir los objetos que no son de instancia, no usamos el término “objeto” solo, sino que usamos “instancia” u “objeto de instancia”. Las instancias de Berry siempre se asignan dinámicamente y deben usarse con un recolector de basura. Además de la asignación de memoria, el proceso de creación de instancias también necesita inicializar la instancia, este proceso lo completa el <code class="docutils literal notranslate"><span class="pre">Constructor</span></code>. Además, puedes completar la destrucción del objeto a través del <code class="docutils literal notranslate"><span class="pre">Destructor</span></code> antes de recuperar la memoria del objeto.</p>
<p>En la implementación interna, la instancia contendrá una referencia a la clase, y la instancia en sí misma solo almacena variables miembro y no métodos.</p>
</section>
</section>
<section id="tipo-de-clase">
<h3>2.1.2 Tipo de clase<a class="headerlink" href="#tipo-de-clase" title="Permalink to this headline">¶</a></h3>
<p>Algunos de los tipos incorporados son tipos de clase, son <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">map</span></code> y <code class="docutils literal notranslate"><span class="pre">range</span></code>. A diferencia de los tipos personalizados, los tipos de clase integrados se pueden construir usando literales, por ejemplo, <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> es un literal de tipo <code class="docutils literal notranslate"><span class="pre">list</span></code>.</p>
<section id="lista">
<h4>Lista<a class="headerlink" href="#lista" title="Permalink to this headline">¶</a></h4>
<p>La clase List es un contenedor que proporciona soporte para tipos de datos de lista.
La lista de Berry es una colección ordenada de elementos, y cada elemento de la lista tiene un índice entero único, y se puede acceder a cada elemento directamente según el índice. List admite la inserción o eliminación de elementos en cualquier posición, y el elemento puede ser de cualquier tipo. Además de usar índices, también puede usar iteradores para acceder a los elementos de la lista.</p>
<p>La implementación de List es una matriz dinámica y esta estructura de datos tiene un buen rendimiento de acceso aleatorio. La eficiencia de agregar y eliminar elementos al final de la lista es muy alta, pero la eficiencia de agregar y eliminar elementos en el medio de la lista es baja.</p>
<p>El método de inicialización literal del contenedor List es usar una lista de objetos entre corchetes y múltiples objetos separados por comas, por ejemplo:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="p">[]</span><span class="w"></span>
<span class="p">[</span><span class="s1">&#39;string&#39;</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;list&#39;</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Operaciones: ver capítulo 7.</p>
</section>
<section id="mapa">
<h4>Mapa<a class="headerlink" href="#mapa" title="Permalink to this headline">¶</a></h4>
<p>El mapa también es un tipo de contenedor, el mapa es una colección de pares clave-valor, y cada clave posible aparece como máximo una vez en la colección. El contenedor Mapa proporciona las siguientes operaciones básicas:</p>
<ul class="simple">
<li><p>Agregar pares clave-valor a la colección</p></li>
<li><p>Eliminar pares clave-valor de la colección</p></li>
<li><p>Modificar el valor correspondiente a una clave existente</p></li>
<li><p>Encuentra el valor correspondiente por clave</p></li>
</ul>
<p>El mapa se implementa utilizando una tabla hash y tiene una alta eficiencia de búsqueda.
La operación de agregar y eliminar pares clave-valor consumirá más tiempo si se produce un “rehashing”.</p>
<p>El contenedor Map también se puede inicializar con valores literales, escritos entre llaves para encerrar una lista de pares clave-valor, separados por dos puntos entre claves y valores, y separados por comas entre pares clave-valor. P.ej:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="p">{}</span><span class="w"></span>
<span class="p">{</span><span class="s1">&#39;str&#39;</span><span class="o">:</span><span class="s1">&#39;hola&#39;</span><span class="p">}</span><span class="w"></span>
<span class="p">{</span><span class="s1">&#39;str&#39;</span><span class="o">:</span><span class="s1">&#39;hola&#39;</span><span class="p">,</span><span class="s1">&#39;int&#39;</span><span class="o">:</span><span class="w"> </span><span class="mi">45</span><span class="p">,</span><span class="w"> </span><span class="mi">78</span><span class="o">:</span><span class="w"> </span><span class="kc">nil</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Operaciones: ver capítulo 7.</p>
</section>
<section id="rango">
<h4>Rango<a class="headerlink" href="#rango" title="Permalink to this headline">¶</a></h4>
<p>El contenedor Range representa un rango de enteros, que generalmente se usa para iterar en un rango de enteros. Este tipo tiene un miembro <code class="docutils literal notranslate"><span class="pre">__lower__</span></code> y un miembro <code class="docutils literal notranslate"><span class="pre">__upper__</span></code>, que representan los límites inferior y superior del rango, respectivamente. El valor literal de Range es un par de enteros conectados mediante el operador <code class="docutils literal notranslate"><span class="pre">..</span></code>:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="mi">-5</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
</pre></div>
</div>
<p>Cuando la clase Range se usa para la iteración, los elementos de la iteración son todos valores enteros desde el límite inferior hasta el límite superior, incluidos los valores límite. Por ejemplo, el resultado de la iteración de <code class="docutils literal notranslate"><span class="pre">0..5</span></code> es:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
</pre></div>
</div>
<p>Por tanto, cabe señalar que para un rango de <em>x</em> .. (<em>x</em>+<em>n</em>), el número de iteraciones es <em>n</em> + 1. Una construcción común para iterar a través de los elementos de una lista por elemento es:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="ow">for</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="nb">size</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="mi">-1</span><span class="w"></span>
</pre></div>
</div>
<p>Rango abierto: si omite el último rango, se reemplaza implícitamente con MAXINT.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="o">..</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="nf">r</span><span class="w"></span>
<span class="p">(</span><span class="mi">10</span><span class="o">..</span><span class="mi">9223372036854775807</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="bytes">
<h4>Bytes<a class="headerlink" href="#bytes" title="Permalink to this headline">¶</a></h4>
<p>El objeto Bytes denota un búfer de bytes que se puede usar para manipular búferes de bytes o para leer/escribir algunas áreas o estructuras de memoria C.</p>
<p>Consulte el Capítulo 7.</p>
</section>
</section>
</section>
<section id="variables">
<h2>2.2 Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h2>
<p>Una variable es un espacio de almacenamiento con un nombre, y los datos o la información almacenados en el espacio de almacenamiento se denominan valor de la variable.
Los nombres de variables se utilizan para hacer referencia a las variables en el código fuente. En diferentes ámbitos, un nombre de variable puede vincular varias variables independientes, pero las variables no tienen alias. El valor de la variable se puede acceder o cambiar en cualquier momento durante la ejecución del programa.
Berry es un lenguaje de tipo dinámico, por lo que el tipo de valor de la variable se determina en tiempo de ejecución y la variable puede almacenar cualquier tipo de valor.</p>
<section id="definir-variables">
<h3>2.2.1 Definir variables<a class="headerlink" href="#definir-variables" title="Permalink to this headline">¶</a></h3>
<p>La primera forma de definir una variable es usar una declaración de asignación para asignar un valor a un nuevo nombre de variable:</p>
<div class="algorithm">
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>’var’ =  expresión
</pre></div>
</div>
<p><strong>var</strong> es el nombre de la variable, y el nombre de la variable es un identificador (consulte la sección identificador).
<strong>expresión</strong> es la expresión para inicializar la variable.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;str&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>Sin embargo, este método de definición de variables tiene algunas limitaciones. Tome el siguiente código como ejemplo:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="ow">do</span><span class="w"></span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 1</span>
<span class="ow">end</span><span class="w"></span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 1</span>
</pre></div>
</div>
<p>La instrucción <code class="docutils literal notranslate"><span class="pre">do</span></code> en la rutina constituye el alcance interno. Modificamos el valor de la variable <code class="docutils literal notranslate"><span class="pre">i</span></code> en la línea 3, y el valor de <code class="docutils literal notranslate"><span class="pre">i</span></code> sigue siendo <code class="docutils literal notranslate"><span class="pre">1</span></code> después de dejar el alcance interno en la línea 6. Si queremos que la variable <code class="docutils literal notranslate"><span class="pre">i</span></code> del ámbito interno sea una variable independiente, el método de definir la variable mediante la asignación directa al nuevo nombre de variable no puede cumplir el requisito, porque el identificador <code class="docutils literal notranslate"><span class="pre">i</span></code> ya existe en el ámbito externo. En este caso, la variable se puede definir mediante la palabra clave <code class="docutils literal notranslate"><span class="pre">var</span></code>:</p>
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>’var’ variable
’var’ variable = expresión
</pre></div>
</div>
<p>Hay dos formas de usar <code class="docutils literal notranslate"><span class="pre">var</span></code> para definir una variable: la primera es seguir el nombre de la variable <strong>variable</strong> después de la palabra clave <code class="docutils literal notranslate"><span class="pre">var</span></code>, en este caso la variable se inicializará a <code class="docutils literal notranslate"><span class="pre">nil</span></code>, y la otra se escribe en la variable y se inicializa al mismo tiempo que se define la variable. En este caso, se requiere una expresión de valor inicial <strong>expresión</strong>. Usar <code class="docutils literal notranslate"><span class="pre">var</span></code> para definir una variable tiene dos posibles resultados: si el alcance actual no define la variable de <strong>variable</strong>, definir e inicializar la variable, de lo contrario, es equivalente a reinicializar la variable.
Por lo tanto, la variable definida con <code class="docutils literal notranslate"><span class="pre">var</span></code> protegerá a la variable con el mismo nombre en el ámbito externo.</p>
<p>Ahora cambiamos el ejemplo anterior para usar la palabra clave <code class="docutils literal notranslate"><span class="pre">var</span></code> para definir variables:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="ow">do</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 1</span>
<span class="ow">end</span><span class="w"></span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 0</span>
</pre></div>
</div>
<p>A partir de la rutina modificada, se puede encontrar que el valor de la variable <code class="docutils literal notranslate"><span class="pre">i</span></code> en el ámbito interno es <code class="docutils literal notranslate"><span class="pre">1</span></code>, y su valor en el ámbito externo es <code class="docutils literal notranslate"><span class="pre">0</span></code>. Esto prueba que después de usar la palabra clave <code class="docutils literal notranslate"><span class="pre">var</span></code>, se define una nueva variable <code class="docutils literal notranslate"><span class="pre">i</span></code> en el ámbito interno y se bloquea la variable con el mismo nombre en el ámbito externo. Una vez que finaliza el ámbito interno, el identificador <code class="docutils literal notranslate"><span class="pre">i</span></code> vuelve a vincularse a la variable <code class="docutils literal notranslate"><span class="pre">i</span></code> en el ámbito externo.</p>
<p>Al usar la palabra clave <code class="docutils literal notranslate"><span class="pre">var</span></code> para definir una variable, también puede usar una lista de múltiples nombres de variables, separados por comas. También puede inicializar una o más variables al definir variables:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;test&#39;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="alcance-y-ciclo-de-vida">
<h3>2.2.2 Alcance y Ciclo de Vida<a class="headerlink" href="#alcance-y-ciclo-de-vida" title="Permalink to this headline">¶</a></h3>
<p>Como se mencionó anteriormente, los nombres de las variables se pueden vincular a varias entidades de variables (espacios de almacenamiento) y los nombres de las variables se vinculan a una sola entidad en cada posición. La entidad vinculada por el nombre de la variable debe determinarse de acuerdo con la posición en la que aparece el nombre de la variable.</p>
<p><strong>Ámbito</strong> se refiere al área de código donde el nombre y la entidad están vinculados de forma única. Fuera del alcance, el nombre puede estar vinculado a otras entidades, o no estar vinculado a ninguna entidad. La entidad solo es visible en el alcance asociado al nombre, es decir, la variable solo es válida en su alcance. Un bloque de código (ver bloque) es un alcance. Una variable solo está disponible dentro del bloque, y los nombres en diferentes bloques pueden vincular diferentes entidades variables. El siguiente ejemplo demuestra el alcance de las variables:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="ow">do</span><span class="w"></span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;str&#39;</span><span class="w"></span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="c1"># 0 str</span>
<span class="ow">end</span><span class="w"></span>
<span class="c1">#  La variable j no está disponible aquí</span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1"># 0</span>
</pre></div>
</div>
<p>Los nombres <code class="docutils literal notranslate"><span class="pre">i</span></code> y <code class="docutils literal notranslate"><span class="pre">j</span></code> se definen en esta rutina. El nombre <code class="docutils literal notranslate"><span class="pre">i</span></code> se define fuera de la oración <code class="docutils literal notranslate"><span class="pre">do</span></code>, y el nombre definido en el bloque más externo tiene <strong>Alcance global</strong>. El nombre con alcance global está disponible en todo el programa después de la personalización. El nombre <code class="docutils literal notranslate"><span class="pre">j</span></code> se define en el bloque en la oración <code class="docutils literal notranslate"><span class="pre">do</span></code>, y el nombre de este tipo de definición en el bloque no exterior tiene <strong>Ámbito local</strong>.
No se puede acceder a un nombre con un ámbito local fuera del ámbito.</p>
<p>Berry tiene algunos objetos integrados, que están todos en el ámbito global.
Sin embargo, los objetos integrados y las variables globales definidas en los scripts no están en el mismo ámbito global. Los objetos integrados en realidad pertenecen al <strong>Alcance integrado</strong>. El alcance es visible globalmente como el alcance global ordinario, pero puede estar cubierto por el alcance global ordinario. Los objetos incorporados incluyen funciones y clases en la biblioteca estándar. Estos objetos incluyen funciones de <code class="docutils literal notranslate"><span class="pre">impresión</span></code>, funciones de <code class="docutils literal notranslate"><span class="pre">tipo</span></code> y clases de <code class="docutils literal notranslate"><span class="pre">mapa</span></code>. A diferencia de otros ámbitos, las variables en el ámbito integrado son de solo lectura, por lo que la “asignación” a las variables en el ámbito integrado en realidad define una variable con el mismo nombre en el ámbito global, que anula los símbolos en el ámbito en el alcance incorporado.</p>
<section id="alcance-anidado">
<h4>Alcance anidado<a class="headerlink" href="#alcance-anidado" title="Permalink to this headline">¶</a></h4>
<p>Ámbito anidado significa que el ámbito contiene otro ámbito. Llamamos al ámbito contenido <strong>Ámbito interno</strong> y al ámbito que contiene el ámbito interno <strong>Ámbito externo</strong>. Se puede acceder al nombre definido en el ámbito externo en todos los ámbitos internos. El ámbito interno también puede volver a vincular el nombre ya definido en el ámbito externo. El ejemplo anterior usando <code class="docutils literal notranslate"><span class="pre">var</span></code> para definir variables describe este escenario.</p>
</section>
<section id="ciclo-de-vida-variable">
<h4>Ciclo de vida variable<a class="headerlink" href="#ciclo-de-vida-variable" title="Permalink to this headline">¶</a></h4>
<p>No existe el concepto de nombres de variables cuando el programa se está ejecutando, y las variables existen en forma de entidades en este momento. El “período de validez” de una variable durante la ejecución del programa es el <strong>ciclo de vida</strong> de la variable. Las variables en tiempo de ejecución solo son válidas dentro del alcance. Después de salir del alcance, las variables se destruirán para recuperar recursos.</p>
<p>Las variables definidas en el ámbito global se denominan <strong>Variable global</strong> y tienen <strong>Ciclo de vida estático</strong>. Se puede acceder a dichas variables durante todo el programa en ejecución y no se destruirán. Las variables definidas en el ámbito local se denominan <strong>Variable local</strong> y tienen <strong>Ciclo de vida dinámico</strong>. No se puede acceder a dichas variables después de abandonar el alcance y se destruirán.</p>
<p>Debido a los diferentes ciclos de vida, las variables locales y las variables globales usan diferentes formas de asignar el espacio de almacenamiento. Las variables locales se asignan en una estructura llamada <strong>Pila</strong> (stack), y los objetos asignados en función de la pila se pueden reclamar rápidamente al final del alcance.
Las variables globales se asignan en <strong>Tabla global</strong> (tabla global).
Los objetos de la tabla global no se reciclarán una vez creados y se puede acceder a la tabla desde cualquier parte del programa.</p>
</section>
</section>
<section id="tipo-de-variable">
<h3>2.2.3 Tipo de variable<a class="headerlink" href="#tipo-de-variable" title="Permalink to this headline">¶</a></h3>
<p>Berry determina el tipo de variable en tiempo de ejecución. En otras palabras, la variable puede almacenar cualquier tipo de valor. Por lo tanto, Berry es un lenguaje de <strong>escritura dinámica</strong>. El intérprete no deduce el tipo de la variable en tiempo de compilación, lo que puede provocar que se expongan algunos errores en tiempo de ejecución. Por ejemplo, el error generado al ejecutar la expresión <code class="docutils literal notranslate"><span class="pre">'1'</span> <span class="pre">+</span> <span class="pre">1</span></code> es un error de tiempo de ejecución y no un error del compilador. La ventaja de usar tipos dinámicos es que se pueden simplificar muchos diseños y el programa será más flexible, sin mencionar la necesidad de diseñar un sistema de inferencia de tipos complejo.</p>
<p>Debido a que el intérprete no verifica el tipo, es posible que el código de usuario deba determinar el tipo de valor por sí mismo, y esta característica también se puede usar para implementar algunas operaciones especiales. Esta característica también hace que las funciones sobrecargadas sean innecesarias. Por ejemplo, la función nativa <code class="docutils literal notranslate"><span class="pre">type</span></code> acepta cualquier tipo de parámetro y devuelve una cadena que describe el tipo de parámetro.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Guan Wenliang &amp; Stephan Hadinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4. Declaración &mdash; berry 1.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> berry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../en/Home.html">Welcome to the berry wiki!</a></li>
<li class="toctree-l1"><a class="reference internal" href="Home.html">Bienvenido a la wiki de Berry!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">berry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>4. Declaración</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/es/Capitulo-4.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <!-- Spanish Translation: Emiliano Gonzalez (egonzalez . hiperion @ gmail . com) -->
<section id="declaracion">
<h1>4. Declaración<a class="headerlink" href="#declaracion" title="Permalink to this headline"></a></h1>
<p>Berry es un lenguaje de programación imperativo. Este paradigma asume que los programas se ejecutan paso a paso. Normalmente, las declaraciones de Berry se ejecutan secuencialmente, y esta estructura de programa se denomina estructura secuencial. Aunque la estructura de la secuencia es muy básica, las estructuras de rama y las estructuras de bucle se utilizan normalmente en los programas reales.
Berry proporciona varias declaraciones de control para realizar esta compleja estructura de flujo, como declaraciones condicionales y declaraciones de iteración.</p>
<p>A excepción de los comentarios de línea, los retornos de carro o los saltos de línea (”<code class="docutils literal notranslate"><span class="pre">\r</span></code>” y “<code class="docutils literal notranslate"><span class="pre">\n</span></code>”) solo se usan como caracteres en blanco, por lo que las declaraciones se pueden escribir en líneas. Además, puede escribir varias declaraciones en la misma línea.</p>
<p>Puede agregar un punto y coma al final de la declaración para indicar el final de la declaración, pero el intérprete generalmente puede dividir la declaración automáticamente sin usar un punto y coma. Puede usar punto y coma para decirle al intérprete cómo analizar el código para el código que será ambiguo. Sin embargo, es mejor no escribir código ambiguo.</p>
<section id="oracion-simple">
<h2>4.1 Oración simple<a class="headerlink" href="#oracion-simple" title="Permalink to this headline"></a></h2>
<section id="declaracion-de-expresion">
<h3>4.1.1 Declaración de expresión<a class="headerlink" href="#declaracion-de-expresion" title="Permalink to this headline"></a></h3>
<p>Las declaraciones de expresión son principalmente declaraciones compuestas de expresiones de asignación o expresiones de llamada de función. Otras expresiones también pueden formar oraciones, pero no tienen significado. Por ejemplo, la expresión <code class="docutils literal notranslate"><span class="pre">1+2</span></code> es una oración escrita sola, pero no tiene ningún efecto. Las siguientes rutinas dan ejemplos de sentencias de expresión y sentencias de función:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>a = 1 #  Declaración de asignación
print(a) #  Declaración de llamada
</pre></div>
</div>
<p>La línea 1 es una declaración de asignación simple que asigna el valor literal <code class="docutils literal notranslate"><span class="pre">i</span></code> a la variable <code class="docutils literal notranslate"><span class="pre">a</span></code>. La declaración en la línea 2 es una declaración de llamada de función, que imprime el valor de la variable ‘a’ llamando a la función ‘imprimir’.</p>
<p>Las expresiones de líneas cruzadas se escriben de la misma manera que las expresiones de una sola línea y no se requieren símbolos especiales de continuación de línea. P.ej:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>a = 1 +
    func() # Ajustar línea
</pre></div>
</div>
<p>También puede escribir varias declaraciones de expresión en una línea y varios tipos de declaraciones se pueden escribir en una línea. Este ejemplo pone dos declaraciones de expresión en la misma línea:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>b = 1 c = 2 #  sentencias múltiples
</pre></div>
</div>
<p>A veces el programador quiere escribir dos declaraciones, pero el intérprete puede pensar erróneamente que es una declaración. Este problema es causado por la ambigüedad en el proceso de análisis gramatical. Tome este código como ejemplo:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>a = c
(b) = 1 #  Considérese como una llamada de función
</pre></div>
</div>
<p>Supongamos que las líneas 1 y 2 están destinadas a ser dos oraciones de expresión: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">c</span></code> y <code class="docutils literal notranslate"><span class="pre">(b)</span> <span class="pre">=</span> <span class="pre">1</span></code>, pero el intérprete las interpretará como una oración: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">c(b)</span> <span class="pre">=</span> <span class="pre">1</span></code>. La causa de este problema es que el intérprete analiza incorrectamente <code class="docutils literal notranslate"><span class="pre">c</span></code> y <code class="docutils literal notranslate"><span class="pre">(b)</span></code> en llamadas de función. Para evitar ambigüedades, podemos agregar un punto y coma al final de la declaración para separar claramente la declaración:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>a = c; (b) = 1;
</pre></div>
</div>
<p>Una mejor manera es no usar paréntesis en el lado izquierdo del número de tarea. Obviamente, no hay razón para usar paréntesis aquí. En circunstancias normales, las expresiones complejas no deberían aparecer en el lado izquierdo del operador de asignación, sino solo expresiones simples compuestas de nombres de variables, expresiones de operación de dominio y expresiones de operación de subíndice:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>a = c b = 1
</pre></div>
</div>
<p>Usar expresiones simples solo en el lado izquierdo del signo de asignación no causará ambigüedad en la segmentación de oraciones. Por lo tanto, en la mayoría de los casos, no es necesario usar punto y coma para separar expresiones y no recomendamos esta forma de escritura.</p>
</section>
<section id="bloque">
<h3>Bloque<a class="headerlink" href="#bloque" title="Permalink to this headline"></a></h3>
<p>Un <strong>Bloque</strong> es una colección de varias oraciones. Un bloque es un alcance, por lo que solo se puede acceder a las variables definidas en el bloque dentro del bloque y sus sub-bloques. Hay muchos lugares donde se utilizan bloques, como declaraciones <code class="docutils literal notranslate"><span class="pre">if</span></code>, declaraciones <code class="docutils literal notranslate"><span class="pre">while</span></code>, declaraciones de funciones, etc. Estas declaraciones contendrán un bloque a través de un par de palabras clave. Por ejemplo, el bloque utilizado en la sentencia <code class="docutils literal notranslate"><span class="pre">if</span></code>:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>if isOpen
    close()
    print(&#39;el dispositivo fue cerrado&#39;)
end
</pre></div>
</div>
<p>Las sentencias en las líneas 2 a 3 constituyen un bloque, que se intercala entre el par de palabras clave <code class="docutils literal notranslate"><span class="pre">if</span></code> y <code class="docutils literal notranslate"><span class="pre">end</span></code> (la expresión condicional de la sentencia en <code class="docutils literal notranslate"><span class="pre">if</span></code> no está en el bloque). No es necesario que el bloque contenga declaraciones, lo que constituye un bloque vacío, o se puede decir que es un bloque que contiene una declaración vacía. En términos generales, cualquier cantidad de oraciones consecutivas puede llamarse bloque, pero preferimos expandir el alcance del bloque tanto como sea posible, lo que puede garantizar que el área del bloque sea consistente con el alcance del alcance. En el ejemplo anterior, tendemos a pensar que las filas 2 a 3 son un bloque completo, que es el rango más grande entre las palabras clave <code class="docutils literal notranslate"><span class="pre">if</span></code> y <code class="docutils literal notranslate"><span class="pre">end</span></code>.</p>
<section id="declaracion-do">
<h4>Declaración <code class="docutils literal notranslate"><span class="pre">do</span></code><a class="headerlink" href="#declaracion-do" title="Permalink to this headline"></a></h4>
<p>A veces solo queremos abrir un nuevo ámbito, pero no queremos usar ninguna declaración de control. En este caso, podemos usar la instrucción <code class="docutils literal notranslate"><span class="pre">do</span></code> para encapsular el bloque, entonces la sentencia no tiene función de control. La oración tiene la forma:</p>
<p><code class="docutils literal notranslate"><span class="pre">do</span></code> <strong>bloque</strong> <code class="docutils literal notranslate"><span class="pre">end</span></code></p>
<p>Entre ellos <strong>bloque</strong> está el bloque que necesitamos. Esta instrucción utiliza un par de palabras clave <code class="docutils literal notranslate"><span class="pre">do</span></code> y <code class="docutils literal notranslate"><span class="pre">end</span></code> para contener bloques. La declaración no tiene función de control, ni genera ninguna instrucción de tiempo de ejecución.</p>
</section>
</section>
</section>
<section id="sentencia-condicional">
<h2>Sentencia condicional<a class="headerlink" href="#sentencia-condicional" title="Permalink to this headline"></a></h2>
<p>Berry proporciona sentencias <code class="docutils literal notranslate"><span class="pre">if</span></code> para realizar la función de ejecución de control condicional. Este tipo de estructura de programa generalmente se denomina estructura de rama <code class="docutils literal notranslate"><span class="pre">if</span></code>. La declaración determinará la rama de ejecución basada en la expresión condicional verdadera (<code class="docutils literal notranslate"><span class="pre">true</span></code>) o falsa (<code class="docutils literal notranslate"><span class="pre">false</span></code>). En algunos lenguajes, existen otras opciones para implementar el control condicional. Por ejemplo, los lenguajes como C y C++ proporcionan sentencias <code class="docutils literal notranslate"><span class="pre">switch</span></code>, pero para simplificar el diseño, Berry no admite sentencias <code class="docutils literal notranslate"><span class="pre">switch</span></code>.</p>
<section id="declaracion-if">
<h3>Declaración <code class="docutils literal notranslate"><span class="pre">if</span></code><a class="headerlink" href="#declaracion-if" title="Permalink to this headline"></a></h3>
<p>La instrucción <strong><code class="docutils literal notranslate"><span class="pre">if</span></code></strong> se utiliza para implementar la estructura de rama, que selecciona la rama del programa de acuerdo con el verdadero o falso de una determinada condición de juicio. La sentencia también puede incluir la rama <code class="docutils literal notranslate"><span class="pre">else</span></code> o la rama <code class="docutils literal notranslate"><span class="pre">elif</span></code>. La forma simple de declaración <code class="docutils literal notranslate"><span class="pre">if</span></code> sin ramas es</p>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> <strong>condición</strong>
    <strong>bloque</strong>
<code class="docutils literal notranslate"><span class="pre">end</span></code></p>
<p><strong>condición</strong> es una expresión condicional. Cuando el valor de *<em>condición</em> es <code class="docutils literal notranslate"><span class="pre">verdadero</span></code>, se ejecutará <strong>bloque</strong> en la segunda línea; de lo contrario, se omitirá el <strong>bloque</strong> y se ejecutará la instrucción que sigue a <code class="docutils literal notranslate"><span class="pre">end</span></code>. En el caso de que se ejecute <strong>bloque</strong>, después de que se ejecute la última declaración en el bloque, dejará la declaración <code class="docutils literal notranslate"><span class="pre">if</span></code> y comenzará a ejecutar la declaración que sigue a <code class="docutils literal notranslate"><span class="pre">end</span></code>.</p>
<p>Aquí hay un ejemplo para ilustrar el uso de la sentencia <code class="docutils literal notranslate"><span class="pre">if</span></code>:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>if 8 % 2 == 0
    print(&#39;este número es par&#39;)
end
</pre></div>
</div>
<p>Este código se usa para juzgar si el número ‘8’ es par y, si lo es, generará ‘este número es par’. Aunque este ejemplo es muy simple, es suficiente para ilustrar el uso básico de las oraciones <code class="docutils literal notranslate"><span class="pre">if</span></code>.</p>
<p>Si desea tener una rama correspondiente para la ejecución cuando la condición se cumple y no se cumple, use la instrucción <code class="docutils literal notranslate"><span class="pre">if</span></code> con la rama <code class="docutils literal notranslate"><span class="pre">else</span></code>. La forma de la oración es:</p>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> <strong>condición</strong>
    <strong>bloque</strong>
<code class="docutils literal notranslate"><span class="pre">else</span></code>
<strong>bloque</strong>
<code class="docutils literal notranslate"><span class="pre">end</span></code></p>
<p>A diferencia de la simple instrucción <code class="docutils literal notranslate"><span class="pre">if</span></code>, la declaración <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">else</span></code> ejecutará <strong>bloque</strong> en la rama <code class="docutils literal notranslate"><span class="pre">else</span></code> cuando el valor de <strong>condición</strong> sea <code class="docutils literal notranslate"><span class="pre">falso</span></code>. No importa qué rama se ejecute bajo <strong>bloque</strong>, después de que se ejecute la última declaración en el bloque, aparecerá la declaración <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">else</span></code>, es decir, se ejecutará la declaración después de <code class="docutils literal notranslate"><span class="pre">end</span></code>. En otras palabras, no importa si el valor de <strong>condición</strong> es <code class="docutils literal notranslate"><span class="pre">verdadero</span></code> o <code class="docutils literal notranslate"><span class="pre">falso</span></code>, se ejecutará un <strong>bloque</strong>.</p>
<p>Continúe usando el juicio de paridad como ejemplo, esta vez cambie la demanda para generar la información correspondiente de acuerdo con la paridad del número de entrada. El código para lograr este requisito es:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>if x % 2 == 0
    print(&#39;este número es par&#39;)
else
    print(&#39;este número es impar&#39;)
end
</pre></div>
</div>
<p>Antes de ejecutar este código, primero debemos asignar un valor entero a la variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, que es el número cuya paridad queremos comprobar. Si ‘x’ es un número par, el programa generará ‘este número es par’; de lo contrario, generará ‘este número es impar’. A veces necesitamos anidar declaraciones <code class="docutils literal notranslate"><span class="pre">if</span></code>. Una forma es anidar una instrucción <code class="docutils literal notranslate"><span class="pre">if</span></code> debajo de la rama <code class="docutils literal notranslate"><span class="pre">else</span></code>.
Este es un requisito muy común porque muchas condiciones deben juzgarse consecutivamente. Para este tipo de demanda, use la instrucción <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">else</span></code> para escribir:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>if expr
    bloque
else
    if expr
        bloque
    end
end
</pre></div>
</div>
<p>Obviamente, esta forma de escribir aumentará el nivel de sangría del código, y es más engorroso usar múltiples <code class="docutils literal notranslate"><span class="pre">end</span></code> al final. Como mejora, Berry proporciona la rama <code class="docutils literal notranslate"><span class="pre">elif</span></code> para optimizar la escritura anterior. Usar la rama <code class="docutils literal notranslate"><span class="pre">elif</span></code> es equivalente al código anterior, en la forma</p>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> <strong>condición</strong>
<strong>bloque</strong>
<code class="docutils literal notranslate"><span class="pre">elif</span></code> <strong>condición</strong>
<strong>bloque</strong>
<code class="docutils literal notranslate"><span class="pre">else</span></code>
<strong>bloque</strong>
<code class="docutils literal notranslate"><span class="pre">end</span></code></p>
<p>La rama debe usarse después de la rama <code class="docutils literal notranslate"><span class="pre">if</span></code> y antes de la rama, y la rama <code class="docutils literal notranslate"><span class="pre">elif</span></code> se puede usar varias veces seguidas.
Si se cumple la <strong>condición</strong> correspondiente a la rama <code class="docutils literal notranslate"><span class="pre">elif</span></code>, se ejecutará el <strong>bloque</strong> debajo de la rama. La ramificación <code class="docutils literal notranslate"><span class="pre">elif</span></code> es adecuada para situaciones que requieren que se juzguen múltiples condiciones en secuencia.</p>
<p>Usamos un fragmento de código que juzga positivo, negativo y 0 para demostrar la rama <code class="docutils literal notranslate"><span class="pre">elif</span></code>:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>if x&gt; 0
    print(&#39;positivo&#39;)
elif x == 0
    print(&#39;cero&#39;)
else
    print(&#39;negativo&#39;)
end
</pre></div>
</div>
<p>Aquí también, la variable <code class="docutils literal notranslate"><span class="pre">x</span></code> debe asignarse primero. Este código es muy simple y no será explicado.</p>
<p>Algunos lenguajes tienen un problema llamado “<code class="docutils literal notranslate"><span class="pre">else</span></code>” colgante, que se refiere a cuando una oración <code class="docutils literal notranslate"><span class="pre">if</span></code> está anidada dentro de otra oración <code class="docutils literal notranslate"><span class="pre">if</span></code>, ¿a dónde pertenece la rama <code class="docutils literal notranslate"><span class="pre">else</span></code>? Es un problema con la sentencia <code class="docutils literal notranslate"><span class="pre">if</span></code>. Cuando usamos C/C++, debemos considerar el problema de colgar <code class="docutils literal notranslate"><span class="pre">else</span></code>. Para evitar la ambigüedad en el problema de <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">else</span></code>, los programadores de C/C++ a menudo usan llaves para convertir una rama en un bloque. En Berry, la rama de la instrucción <code class="docutils literal notranslate"><span class="pre">if</span></code> debe ser un bloque, lo que también determina que Berry no tiene el problema de sobresalir por <code class="docutils literal notranslate"><span class="pre">else</span></code>.</p>
</section>
</section>
<section id="declaracion-de-iteracion">
<h2>Declaración de iteración<a class="headerlink" href="#declaracion-de-iteracion" title="Permalink to this headline"></a></h2>
<p>Las declaraciones iterativas también se denominan declaraciones de bucle, que se utilizan para repetir ciertas operaciones hasta que se cumple la condición de terminación. Berry proporciona las declaraciones <code class="docutils literal notranslate"><span class="pre">while</span></code> y <code class="docutils literal notranslate"><span class="pre">for</span></code>, dos declaraciones de iteración. Muchos lenguajes también proporcionan estas dos declaraciones para la iteración. La declaración <code class="docutils literal notranslate"><span class="pre">while</span></code> de Berry es similar a la declaración <code class="docutils literal notranslate"><span class="pre">while</span></code> en C/C++, pero la declaración <code class="docutils literal notranslate"><span class="pre">for</span></code> de Berry solo se usa para recorrer los elementos en el contenedor, similar a la declaración <code class="docutils literal notranslate"><span class="pre">foreach</span></code> proporcionada por algunos lenguajes y la que se introdujo por el nuevo estilo en C++11 de <code class="docutils literal notranslate"><span class="pre">for</span></code>. No se admite la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code> de estilo C.</p>
<section id="sentencia-while">
<h3>Sentencia <code class="docutils literal notranslate"><span class="pre">while</span></code><a class="headerlink" href="#sentencia-while" title="Permalink to this headline"></a></h3>
<p>La declaración <strong><code class="docutils literal notranslate"><span class="pre">while</span></code></strong> es una declaración iterativa básica. La instrucción <code class="docutils literal notranslate"><span class="pre">while</span></code> utiliza una condición de juicio. Cuando la condición es verdadera, el cuerpo del ciclo se ejecuta repetidamente; de lo contrario, el ciclo finaliza. El patrón de la declaración es</p>
<p><code class="docutils literal notranslate"><span class="pre">while</span></code> <strong>condición</strong>
    <strong>bloque</strong>
<code class="docutils literal notranslate"><span class="pre">end</span></code></p>
<p>Cuando el programa ejecuta la sentencia <code class="docutils literal notranslate"><span class="pre">while</span></code>, comprobará si la expresión <strong>condición</strong> es verdadera o falsa. Si es cierto, ejecuta el <strong>bloque</strong> del cuerpo del ciclo; de lo contrario, finaliza el ciclo. Después de ejecutar la última declaración en <strong>bloque</strong>, el programa saltará al comienzo de la declaración <code class="docutils literal notranslate"><span class="pre">while</span></code> y comenzará la siguiente ronda de detección. Si la expresión de <strong>condición</strong> es falsa cuando se evalúa por primera vez, el <strong>bloque</strong> del cuerpo del bucle no se ejecutará en absoluto (al igual que la expresión de <strong>condición</strong> de la declaración <code class="docutils literal notranslate"><span class="pre">if</span></code> es falsa). En términos generales, el valor de la expresión <strong>condición</strong> debería poder cambiar durante el ciclo, en lugar de ser una constante o una variable modificada fuera del ciclo, lo que hará que el ciclo no se ejecute o no termine. Un bucle que nunca termina se llama bucle sin fin. Por lo general, esperamos que el ciclo se ejecute un número específico de veces y luego termine. Por ejemplo, cuando usamos el bucle <code class="docutils literal notranslate"><span class="pre">while</span></code> para acceder a todos los elementos de la matriz, esperamos que el número de ejecuciones del bucle sea igual a la longitud de la matriz, por ejemplo:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>i = 0
l = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]
while i &lt; l.size()
    print(l[i])
    i = i + 1
end
</pre></div>
</div>
<p>Este bucle obtiene los elementos del arreglo <code class="docutils literal notranslate"><span class="pre">l</span></code> y los imprime. Usamos una variable <code class="docutils literal notranslate"><span class="pre">i</span></code> como contador de bucles e índice de matriz. Dejamos que el valor de <code class="docutils literal notranslate"><span class="pre">i</span></code> alcance la longitud de la matriz <code class="docutils literal notranslate"><span class="pre">l</span></code> para finalizar el bucle. En la última línea del cuerpo del bucle, añadimos <code class="docutils literal notranslate"><span class="pre">1</span></code> al valor de <code class="docutils literal notranslate"><span class="pre">i</span></code> para asegurar que se acceda al siguiente elemento de la matriz en el siguiente bucle, y el bucle <code class="docutils literal notranslate"><span class="pre">while</span></code> finaliza cuando el número de bucles alcanza la longitud de la matriz.</p>
</section>
<section id="sentencia-for">
<h3>Sentencia <code class="docutils literal notranslate"><span class="pre">for</span></code><a class="headerlink" href="#sentencia-for" title="Permalink to this headline"></a></h3>
<p>La instrucción <strong><code class="docutils literal notranslate"><span class="pre">for</span></code></strong> de Berry se usa para recorrer los elementos en el contenedor, y su forma es</p>
<p><code class="docutils literal notranslate"><span class="pre">for</span> </code> <strong>variable</strong> <code class="docutils literal notranslate"><span class="pre">:</span></code> <strong>expresión</strong>
<strong>bloque</strong>
<code class="docutils literal notranslate"><span class="pre">end</span></code></p>
<p><strong>expresión</strong> El valor de la expresión debe ser un contenedor iterable o una función, como la clase <code class="docutils literal notranslate"><span class="pre">range</span></code>. La declaración obtiene un iterador del contenedor y obtiene un elemento en el contenedor cada vez que se llama al iterador.</p>
<p><strong>variable</strong> se denomina variable de iteración, que siempre se define en la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code>. Por lo tanto, <strong>variable</strong> debe ser un nombre de variable y no una expresión. El elemento contenedor obtenido del iterador en cada bucle se asignará a la variable de iteración. Este proceso ocurre antes de la primera declaración en <strong>bloque</strong>.</p>
<p>La declaración <code class="docutils literal notranslate"><span class="pre">for</span></code> verificará si hay elementos no visitados en el iterador para la iteración. Si los hay, comenzará la siguiente iteración; de lo contrario, finalizará la declaración <code class="docutils literal notranslate"><span class="pre">for</span></code> y ejecutará la declaración que sigue a <code class="docutils literal notranslate"><span class="pre">end</span></code>. Actualmente, Berry solo proporciona iteradores de solo lectura, lo que significa que los elementos del contenedor no se pueden modificar a través de las variables de iteración en la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code>.</p>
<p>El alcance de la variable de iteración <strong>variable</strong> se limita al <strong>bloque</strong> del cuerpo del ciclo, y la variable no tendrá ninguna relación con la variable con el mismo nombre fuera del alcance. Para ilustrar este punto, usemos un ejemplo para ilustrar. En este ejemplo, usamos la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code> para acceder a todos los elementos en la instancia <code class="docutils literal notranslate"><span class="pre">range</span></code> e imprimirlos. Por supuesto, también usamos este ejemplo para demostrar el alcance de las variables de bucle.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>i = &quot;Hola, estoy bien&quot;. # Variable exterior
for i: 0 .. 2
    print(i) #  variable de iteración
end
print(i)
</pre></div>
</div>
<p>En este ejemplo, en relación con la variable de iteración <code class="docutils literal notranslate"><span class="pre">i</span></code> definida en la línea 2, la variable <code class="docutils literal notranslate"><span class="pre">i</span></code> definida en la línea 1 es una variable externa. Al ejecutar este ejemplo obtendrá el siguiente resultado</p>
<p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">Hola,</span> <span class="pre">estoy</span> <span class="pre">bien</span></code></p>
<p>Se puede ver que la variable de iteración <code class="docutils literal notranslate"><span class="pre">i</span></code> y la variable externa <code class="docutils literal notranslate"><span class="pre">i</span></code> son dos variables diferentes. Solo tienen el mismo nombre pero diferentes alcances.</p>
<section id="principio-de-enunciado-for">
<h4>Principio de enunciado <code class="docutils literal notranslate"><span class="pre">for</span></code><a class="headerlink" href="#principio-de-enunciado-for" title="Permalink to this headline"></a></h4>
<p>A diferencia de la sentencia iterativa tradicional <code class="docutils literal notranslate"><span class="pre">while</span></code>, la sentencia <code class="docutils literal notranslate"><span class="pre">for</span></code> utiliza iteradores para atravesar el contenedor. Si necesita usar la declaración <code class="docutils literal notranslate"><span class="pre">for</span></code> para atravesar una clase personalizada, debe comprender su mecanismo de implementación. Cuando se usa la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code>, el intérprete oculta muchos detalles de implementación. De hecho, para dicho código:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>for i: 0 .. 2
    print(i)
end
</pre></div>
</div>
<p>Será traducido al siguiente código equivalente por el intérprete:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>var it = __iterator__(0 .. 2)
try
    while true
        var i = it()
        print(i)
    end
except &#39;stop_iteration&#39;
    #  no hacer nada
end
</pre></div>
</div>
<p>Hasta cierto punto, la declaración <code class="docutils literal notranslate"><span class="pre">for</span></code> es solo un azúcar sintáctico, y es esencialmente solo una forma simple de escribir una pieza de código complejo. En este código equivalente se usa una variable intermedia <code class="docutils literal notranslate"><span class="pre">it</span></code>. El valor de la variable es un iterador y, en este ejemplo, es un iterador del contenedor <code class="docutils literal notranslate"><span class="pre">range</span></code> <code class="docutils literal notranslate"><span class="pre">0..2</span></code>. Al procesar la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code>, el intérprete oculta la variable intermedia del iterador, por lo que no se puede acceder a ella en el código.</p>
<p>El parámetro de la función <code class="docutils literal notranslate"><span class="pre">__iterator__</span></code> es un contenedor y la función devuelve un iterador de parámetros. Esta función obtiene el iterador llamando al método de parámetro. Por lo tanto, si el valor de retorno del método <code class="docutils literal notranslate"><span class="pre">iter</span></code> es un tipo de instancia (<code class="docutils literal notranslate"><span class="pre">instance</span></code>), esta instancia debe tener un método <code class="docutils literal notranslate"><span class="pre">next</span></code> y un método <code class="docutils literal notranslate"><span class="pre">hasnext</span></code>.</p>
<p>El parámetro de la función <code class="docutils literal notranslate"><span class="pre">__hasnext__</span></code> es un iterador, que comprueba si el iterador tiene el siguiente elemento llamando al método <code class="docutils literal notranslate"><span class="pre">hasnext</span></code> del iterador <code class="docutils literal notranslate"><span class="pre">hasnext</span></code> El valor de retorno del método es de tipo <code class="docutils literal notranslate"><span class="pre">booleano</span></code>. El parámetro de la función <code class="docutils literal notranslate"><span class="pre">__next__</span></code> también es un iterador, que obtiene el siguiente elemento en el iterador llamando al método <code class="docutils literal notranslate"><span class="pre">next</span></code> del iterador.</p>
<p>Hasta ahora, las funciones <code class="docutils literal notranslate"><span class="pre">__iterator__</span></code>, <code class="docutils literal notranslate"><span class="pre">__hasnext__</span></code> y <code class="docutils literal notranslate"><span class="pre">__next__</span></code> simplemente llaman a algunos métodos del contenedor o iterador y luego devuelven el valor de retorno de estos métodos. Por lo tanto, la escritura equivalente de la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code> también se puede simplificar de esta forma:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>do
    var it = (0 .. 2).iter()
    while (it.hasnext())
        var i = it.next()
        print(i)
    end
end
</pre></div>
</div>
<p>Este código es más fácil de leer. Se puede ver en el código que el alcance de la variable iteradora <code class="docutils literal notranslate"><span class="pre">it</span></code> es la declaración <code class="docutils literal notranslate"><span class="pre">for</span></code> completa, pero no es visible fuera de la declaración <code class="docutils literal notranslate"><span class="pre">for</span></code>, mientras que el alcance de la variable de iteración <code class="docutils literal notranslate"><span class="pre">i</span></code> está en el cuerpo del bucle, por lo que cada iteración definirá nuevas variables de iteración.</p>
</section>
</section>
</section>
<section id="declaracion-de-salto">
<h2>Declaración de salto<a class="headerlink" href="#declaracion-de-salto" title="Permalink to this headline"></a></h2>
<p>La declaración de salto proporcionada por Berry se usa para realizar el salto del flujo del programa en el proceso de bucle. Las sentencias de salto se dividen en sentencias de “ruptura” y sentencias de “continuación”. Estas dos declaraciones deben usarse dentro de declaraciones iterativas y solo pueden usarse dentro de funciones para saltar. Algunos lenguajes proporcionan sentencias <code class="docutils literal notranslate"><span class="pre">goto</span></code> para realizar saltos arbitrarios dentro de las funciones, que Berry no proporciona, pero los efectos de las sentencias <code class="docutils literal notranslate"><span class="pre">goto</span></code> se pueden reemplazar por sentencias condicionales y sentencias de iteración.</p>
</section>
<section id="declaracion-break">
<h2>Declaración <code class="docutils literal notranslate"><span class="pre">break</span></code><a class="headerlink" href="#declaracion-break" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">break</span></code> se usa para terminar la declaración de iteración y saltar. Después de la ejecución de la sentencia <code class="docutils literal notranslate"><span class="pre">break</span></code>, el nivel más cercano de la sentencia de iteración terminará inmediatamente y la ejecución continuará desde la posición de la primera sentencia después de la sentencia de iteración. Para ilustrar el flujo de ejecución de la declaración <code class="docutils literal notranslate"><span class="pre">break</span></code>, usamos un ejemplo para demostrarlo:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>while true
    print(&#39;antes del break&#39;)
    break
    print(&#39;después del break&#39;)
end
print(&#39;fuera del bucle&#39;)
</pre></div>
</div>
<p>En este código, la sentencia <code class="docutils literal notranslate"><span class="pre">break</span></code> está en un bucle <code class="docutils literal notranslate"><span class="pre">while</span></code>. Antes y después de la declaración <code class="docutils literal notranslate"><span class="pre">break</span></code> y después de la declaración <code class="docutils literal notranslate"><span class="pre">while</span></code>, hemos colocado una declaración de impresión para probar el flujo de ejecución del programa. El resultado de este código es:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">antes</span> <span class="k">del</span> <span class="k">break</span>
<span class="n">fuera</span> <span class="k">del</span> <span class="n">bucle</span>
</pre></div>
</div>
<p>Esto muestra que la sentencia <code class="docutils literal notranslate"><span class="pre">while</span></code> finaliza el bucle en la posición de la sentencia <code class="docutils literal notranslate"><span class="pre">break</span></code> en la tercera línea y el programa continúa ejecutándose desde la sexta línea.</p>
<section id="declaracion-continue">
<h3>Declaración <code class="docutils literal notranslate"><span class="pre">continue</span></code><a class="headerlink" href="#declaracion-continue" title="Permalink to this headline"></a></h3>
<p>Esta declaración también se usa dentro de una declaración de iteración. Su función es finalizar una iteración e iniciar inmediatamente la siguiente ronda.
Por lo tanto, después de la ejecución de la sentencia <code class="docutils literal notranslate"><span class="pre">continue</span></code>, el código restante en la sentencia de iteración de la capa más cercana ya no se ejecutará, pero comenzará una nueva ronda de iteración. Aquí usamos una sentencia <code class="docutils literal notranslate"><span class="pre">for</span></code> para demostrar la función de la sentencia <code class="docutils literal notranslate"><span class="pre">continue</span></code>:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>for i: 0 .. 5
    if i &gt;= 2
        continue
    end
    print(&#39;i =&#39;, i)
end
print(&#39;fuera del bucle&#39;)
</pre></div>
</div>
<p>Aquí, la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code> iterará 6 veces. Cuando la variable de iteración <code class="docutils literal notranslate"><span class="pre">i</span></code> es mayor o igual que <code class="docutils literal notranslate"><span class="pre">2</span></code>, se ejecutará la declaración <code class="docutils literal notranslate"><span class="pre">continue</span></code> en la línea 3, y la declaración de impresión en la línea 5 no se ejecutará a partir de entonces. En otras palabras, la línea 5 solo se ejecutará en las dos primeras iteraciones (en este momento <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">2</span></code>). El resultado de ejecución de esta rutina es:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fuera</span> <span class="k">del</span> <span class="n">bucle</span>
</pre></div>
</div>
<p>Se puede ver que el valor de la variable <code class="docutils literal notranslate"><span class="pre">i</span></code> solo se imprime dos veces, lo cual está en línea con las expectativas. Los lectores pueden intentar imprimir el valor de la variable <code class="docutils literal notranslate"><span class="pre">i</span></code> antes de la instrucción <code class="docutils literal notranslate"><span class="pre">continue</span></code>. Encontrará que la declaración <code class="docutils literal notranslate"><span class="pre">for</span></code> itera 6 veces, lo que indica que la declaración <code class="docutils literal notranslate"><span class="pre">continue</span></code> no finaliza la iteración.</p>
</section>
</section>
<section id="declaracion-import">
<h2>Declaración <code class="docutils literal notranslate"><span class="pre">import</span></code><a class="headerlink" href="#declaracion-import" title="Permalink to this headline"></a></h2>
<p>Berry tiene algunos módulos predefinidos, como el módulo <code class="docutils literal notranslate"><span class="pre">math</span></code> para cálculos matemáticos. Estos módulos no se pueden usar directamente, sino que se deben importar con la instrucción <code class="docutils literal notranslate"><span class="pre">import</span></code>. Hay dos formas de importar un módulo:</p>
<p><code class="docutils literal notranslate"><span class="pre">import</span></code> <strong>nombre</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">import</span></code> <strong>nombre</strong> <code class="docutils literal notranslate"><span class="pre">as</span></code> <strong>variable</strong></p>
<p><strong>nombre</strong> Para importar el nombre del módulo, al usar el primer método de escritura para importar el módulo, el módulo importado se puede llamar directamente usando el nombre del módulo. La segunda forma de escribir es importar un módulo llamado <strong>nombre</strong> y modificar el nombre del módulo al llamarlo a <strong>variable</strong>.
Por ejemplo, un módulo llamado <code class="docutils literal notranslate"><span class="pre">math</span></code>, usamos el primer método para importar y usar:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>import math
math.sin(0)
</pre></div>
</div>
<p>Aquí usa directamente <code class="docutils literal notranslate"><span class="pre">math</span></code> para llamar al módulo. Si el nombre de un módulo es relativamente largo y no es conveniente escribirlo, puede usar la instrucción <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">as</span></code>. Aquí, asuma un módulo llamado <code class="docutils literal notranslate"><span class="pre">hardware</span></code>. Queremos llamar a la función <code class="docutils literal notranslate"><span class="pre">setled</span></code> del módulo, podemos importar el <code class="docutils literal notranslate"><span class="pre">hardware</span></code> del módulo a la variable llamada <code class="docutils literal notranslate"><span class="pre">hw</span></code> y usar:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>import hardware as hw
hw.setled(true)
</pre></div>
</div>
<p>Para encontrar módulos, todas las rutas en <code class="docutils literal notranslate"><span class="pre">sys.path()</span></code> se exploran secuencialmente.
Si desea agregar una ruta específica antes de la importación (como leer desde la tarjeta SD), puede usar la siguiente función de ayuda:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>def push_path(p)
  import sys
  var path = sys.path()
  if path.find(p) == nil  # agregar solo si aún no está allí
    path.push(p)
  end
end
</pre></div>
</div>
</section>
<section id="manejo-de-excepciones">
<h2>Manejo de excepciones<a class="headerlink" href="#manejo-de-excepciones" title="Permalink to this headline"></a></h2>
<p>El mecanismo permite que el programa capture y maneje las excepciones que ocurren durante el tiempo de ejecución. Berry admite un mecanismo de captura de excepciones que permite separar el proceso de captura y manejo de excepciones. Es decir, parte del programa se usa para detectar y recopilar excepciones, y la otra parte del programa se usa para manejar excepciones.</p>
<p>En primer lugar, el programa problemático necesita lanzar primero una excepción.
Cuando estos programas están en un bloque de manejo de excepciones, un programa específico atrapará y manejará la excepción.</p>
<section id="generar-una-excepcion">
<h3>Generar una excepción<a class="headerlink" href="#generar-una-excepcion" title="Permalink to this headline"></a></h3>
<p>El uso de la instrucción <code class="docutils literal notranslate"><span class="pre">raise</span></code> genera una excepción <code class="docutils literal notranslate"><span class="pre">raise</span></code>. La declaración pasará un valor para indicar el tipo de excepción para que pueda ser identificada por un manejador de excepciones específico. A continuación se explica cómo utilizar la sentencia <code class="docutils literal notranslate"><span class="pre">raise</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">raise</span></code> <strong>excepción</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">raise</span></code> <strong>excepción</strong><code class="docutils literal notranslate"><span class="pre">,</span> </code><strong>mensaje</strong></p>
<p>El valor de la expresión <strong>excepción</strong> son los <strong>valores atípicos</strong> arrojados; la expresión de <strong>mensaje</strong> opcional suele ser una cadena que describe la información de la excepción, y esta expresión se denomina <strong>parámetro anómalo</strong>. Berry permite que cualquier valor se use como un valor anormal, por ejemplo, una cadena se puede usar como un valor anormal:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>raise &#39;mi_error&#39;,&#39;un ejemplo de subida&#39;
</pre></div>
</div>
<p>Después de que el programa se ejecute en la declaración <code class="docutils literal notranslate"><span class="pre">raise</span></code>, no continuará ejecutando las declaraciones que le siguen, sino que saltará al bloque de manejo de excepciones más cercano. Si el bloque de manejo de excepciones más reciente está en otras funciones, las funciones a lo largo de la cadena de llamadas se cerrarán antes. Si no hay un bloque de manejo de excepciones, se producirá una <strong>salida anormal</strong> y el intérprete imprimirá el mensaje de error de la excepción y la pila de llamadas de la ubicación del error. Cuando la instrucción <code class="docutils literal notranslate"><span class="pre">raise</span></code> está en el bloque de instrucciones <code class="docutils literal notranslate"><span class="pre">try</span></code>, la excepción será capturada por este último. La excepción capturada será manejada por el bloque <code class="docutils literal notranslate"><span class="pre">except</span></code> asociado con el bloque <code class="docutils literal notranslate"><span class="pre">try</span></code>. Si la excepción lanzada puede ser manejada por el bloque ‘except’, la ejecución de este bloque continuará desde la declaración después del último bloque <code class="docutils literal notranslate"><span class="pre">except</span></code>. Si ninguna de las sentencias <code class="docutils literal notranslate"><span class="pre">except</span></code> pueden manejar la excepción, la excepción se volverá a generar hasta que se pueda manejar o la excepción finalice.</p>
<section id="valores-atipicos">
<h4>Valores atípicos<a class="headerlink" href="#valores-atipicos" title="Permalink to this headline"></a></h4>
<p>En Berry, puede usar cualquier valor como valor atípico, pero generalmente usamos cadenas cortas. Berry también puede lanzar algunas excepciones internamente. Llamamos a estas excepciones <strong>Excepción estándar</strong>. Todos los valores de excepción estándar son de tipo cadena.</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><strong>Valores atípicos</strong></p></th>
<th class="text-center head"><p><strong>Descripción</strong></p></th>
<th class="text-center head"><p><strong>Descripción del parámetro</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">assert_failed</span></code></p></td>
<td class="text-center"><p>Afirmación fallida</p></td>
<td class="text-center"><p>Información sobre excepciones específicas</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">index_error</span></code></p></td>
<td class="text-center"><p>(generalmente fuera de los límites)</p></td>
<td class="text-center"><p>Información sobre excepciones específicas</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">io_error</span></code></p></td>
<td class="text-center"><p>Mal funcionamiento de E/S</p></td>
<td class="text-center"><p>Información sobre excepciones específicas</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">key_error</span></code></p></td>
<td class="text-center"><p>Error clave</p></td>
<td class="text-center"><p>Información sobre excepciones específicas</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">runtime_error</span></code></p></td>
<td class="text-center"><p>Excepción de tiempo de ejecución de máquina virtual</p></td>
<td class="text-center"><p>Información sobre excepciones específicas</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">stop_iteration</span></code></p></td>
<td class="text-center"><p>Fin del iterador</p></td>
<td class="text-center"><p>no</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">syntax_error</span></code></p></td>
<td class="text-center"><p>Error de sintaxis</p></td>
<td class="text-center"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>por el compilador</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">unrealized_error</span></code></p></td>
<td class="text-center"><p>Función no realizada</p></td>
<td class="text-center"><p>Información sobre excepciones específicas</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">tipe_error</span></code></p></td>
<td class="text-center"><p>Error de tipo</p></td>
<td class="text-center"><p>Información sobre excepciones específicas</p></td>
</tr>
</tbody>
</table>
<p><em>Tabla 8: Lista de excepciones estándar</em></p>
</section>
</section>
<section id="capturar-excepciones">
<h3>Capturar excepciones<a class="headerlink" href="#capturar-excepciones" title="Permalink to this headline"></a></h3>
<p>Utilice la instrucción <code class="docutils literal notranslate"><span class="pre">except</span></code> para detectar excepciones. Debe estar emparejado con la sentencia <code class="docutils literal notranslate"><span class="pre">try</span></code>, es decir, un bloque de sentencia <code class="docutils literal notranslate"><span class="pre">try</span></code> debe ir seguido de uno o más bloques de sentencia <code class="docutils literal notranslate"><span class="pre">except</span></code>. La forma básica de la oración <code class="docutils literal notranslate"><span class="pre">try-except</span></code> es</p>
<p>``try<code class="docutils literal notranslate"><span class="pre">**bloque**</span></code>except<code class="docutils literal notranslate"> <span class="pre">**...**</span> <span class="pre">**bloque**</span> &#160; </code>end`</p>
<p>La rama <code class="docutils literal notranslate"><span class="pre">except</span></code> puede tener las siguientes formas</p>
<p><code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">..</span></code>
<code class="docutils literal notranslate"><span class="pre">except</span> </code> <strong>excepciones</strong>
<code class="docutils literal notranslate"><span class="pre">except</span> </code> <strong>excepciones</strong><code class="docutils literal notranslate"><span class="pre">as</span></code> <strong>variable</strong>
<code class="docutils literal notranslate"><span class="pre">except</span> </code> <strong>excepciones</strong><code class="docutils literal notranslate"><span class="pre">as</span></code> <strong>variable</strong> <code class="docutils literal notranslate"><span class="pre">,</span> </code> ** mensaje**
<code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">..</span> <span class="pre">as</span> </code> <strong>variable</strong>
<code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">..</span> <span class="pre">as</span> </code> <strong>variable</strong> <code class="docutils literal notranslate"><span class="pre">,</span> </code> <strong>mensaje</strong></p>
<p>La instrucción <code class="docutils literal notranslate"><span class="pre">except</span></code> más básica no usa parámetros, esta rama <code class="docutils literal notranslate"><span class="pre">except</span></code> capturará todas las excepciones; <strong>Lista de excepciones de captura</strong>:  <strong>excepciones</strong> es una lista de valores atípicos que pueden coincidir con la correspondiente rama <code class="docutils literal notranslate"><span class="pre">except</span></code>, que se utiliza entre varios valores de la lista Separados por comas; <strong>variable</strong> es <strong>variable anormal</strong>, si la rama detecta una excepción, el valor atípico se vinculará a la variable; <strong>mensaje</strong> es <strong>Variable de parámetro anómalo</strong>, si la rama detecta una excepción, el valor del parámetro anómalo se vinculará a la variable.</p>
<p>Cuando se detecta una excepción en el bloque de instrucciones <code class="docutils literal notranslate"><span class="pre">try</span></code>, el intérprete verificará la rama <code class="docutils literal notranslate"><span class="pre">except</span></code> una por una. Si el valor de la excepción existe en la lista de captura de una rama, se llamará al bloque de código debajo de la rama para manejar la excepción, y la declaración <code class="docutils literal notranslate"><span class="pre">try-except</span></code> completa se cerrará después de que se ejecute el bloque de código. Si ninguna de las ramas <code class="docutils literal notranslate"><span class="pre">except</span></code> coinciden, el controlador de excepciones externo volverá a lanzar y capturar y manejar la excepción.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Guan Wenliang &amp; Stephan Hadinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
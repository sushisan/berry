<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9. FFI &mdash; berry 1.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> berry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../en/Home.html">Welcome to the berry wiki!</a></li>
<li class="toctree-l1"><a class="reference internal" href="Home.html">Bienvenido a la wiki de Berry!</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">berry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>9. FFI</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/es/Capitulo-9.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <!-- Spanish Translation: Emiliano Gonzalez (egonzalez . hiperion @ gmail . com) -->
<section id="ffi">
<h1>9. FFI<a class="headerlink" href="#ffi" title="Permalink to this headline">¶</a></h1>
<p>La <strong>Interfaz de Función Externa</strong> (FFI) es una interfaz para la interacción entre diferentes lenguajes. Berry proporciona un conjunto de FFI para realizar la interacción con el lenguaje C, este conjunto de interfaces también es muy fácil de usar en C++. La mayoría de las interfaces FFI son funciones y sus declaraciones se colocan en el archivo <em>berry.h</em>. Para reducir la cantidad de RAM utilizada, FFI también proporciona un mecanismo para generar una tabla hash fija durante la compilación de C. Este mecanismo debe utilizar herramientas externas para generar código C.</p>
<section id="conceptos-basicos">
<h2>9.1 Conceptos básicos<a class="headerlink" href="#conceptos-basicos" title="Permalink to this headline">¶</a></h2>
<p>La función interactiva más importante en FFI debería ser la función de llamar al código Berry y la función C mutuamente. Para darnos cuenta de cómo dos lenguajes llaman a las funciones del otro, primero debemos entender el mecanismo de paso de parámetros de la función de Berry.</p>
<section id="maquina-virtual">
<h3>9.1.1 Máquina virtual<a class="headerlink" href="#maquina-virtual" title="Permalink to this headline">¶</a></h3>
<p>A diferencia de los lenguajes compilados, el lenguaje Berry no puede ejecutarse directamente en una máquina física, sino en un entorno de software específico, que es <strong>Máquina virtual</strong> (VM). Similar a una computadora real, el código fuente en forma de texto no se puede ejecutar en una máquina virtual, sino que un compilador debe convertirlo en “código de bytes”. La máquina virtual Berry se define como una estructura C <code class="docutils literal notranslate"><span class="pre">bvm</span></code>, el contenido de esta estructura es invisible para FFI.
A través de algunas funciones de FFI, podemos crear e inicializar una máquina virtual. Introduciremos el uso de máquinas virtuales a través de un ejemplo sencillo:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">berry_test</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_vm_new</span><span class="p">();</span><span class="w"> </span><span class="c1">// Construir una VM</span>
<span class="w">    </span><span class="n">be_loadstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;print(&#39;Hola Berry&#39;)&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Compilar código de prueba</span>
<span class="w">    </span><span class="n">be_pcall</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Función de llamada</span>
<span class="w">    </span><span class="n">be_vm_delete</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Destruir la VM</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Este código da un ejemplo completo del uso de una máquina virtual. Primero, se llama a la función <code class="docutils literal notranslate"><span class="pre">be_vm_new</span></code> para construir una nueva máquina virtual, y luego todas las operaciones se completan en este objeto de máquina virtual.
La función <code class="docutils literal notranslate"><span class="pre">be_vm_new</span></code> vinculará automáticamente la biblioteca estándar al crear una máquina virtual. La función de las líneas 4 a 5 es compilar el código fuente de una cadena en una función Berry y luego llamarla. Finalmente, se llama a la función <code class="docutils literal notranslate"><span class="pre">be_vm_delete</span></code> en la línea 6 para destruir la máquina virtual. Al ejecutar esta función obtendrá una línea de salida en la terminal:</p>
<p><code class="docutils literal notranslate"><span class="pre">Hola</span> <span class="pre">Berry</span></code></p>
<p>En todos los escenarios, la construcción de la máquina virtual, la carga de la biblioteca y el proceso de destrucción son los mismos que en las líneas 3, 4 y 6 del ejemplo anterior. Si es necesario, la forma de compilar o cargar el código fuente puede ser diferente. Por ejemplo, para el código fuente en forma de archivo, se puede compilar a través de la función <code class="docutils literal notranslate"><span class="pre">be_loadfile</span></code>. El código fuente se compilará en una función Berry y la función se almacenará en la parte superior de la pila. La función Berry se puede ejecutar llamando a la función FFI <code class="docutils literal notranslate"><span class="pre">be_pcall</span></code> o <code class="docutils literal notranslate"><span class="pre">be_call</span></code>. También puede usar REPL a través de la función <code class="docutils literal notranslate"><span class="pre">be_repl</span></code>. La interfaz del REPL se describirá en los capítulos correspondientes.</p>
</section>
<section id="pila-virtual">
<h3>9.1.2 Pila virtual<a class="headerlink" href="#pila-virtual" title="Permalink to this headline">¶</a></h3>
<p>Berry usa una pila virtual y funciones nativas escritas en C para pasar valores. Cada elemento de la pila es un valor Berry. Cuando el código Berry llama a una función nativa, siempre crea una nueva pila y empuja todos los parámetros a la pila. Esta pila virtual también se puede usar en código C para almacenar datos, y el recolector de elementos no utilizados no reclamará el valor almacenado en la pila.</p>
<p><img alt="Virtual_Stack" src="https://user-images.githubusercontent.com/49731213/135971121-059e665c-7f65-4a6a-bbe4-da9acf4cf8b5.png" /></p>
<p>La pila virtual utilizada por Berry se muestra en la figura anterior.</p>
<p>La pila virtual crece de izquierda a derecha. Cuando el código Berry llama a una función nativa, obtendrá una pila inicial. La posición del primer valor de la pila se llama <strong>base</strong>, y la última posición se llama <strong>superior</strong> (top), en la función nativa solo el valor desde la parte inferior de la pila hasta la posición anterior a la parte superior de la pila puede ser accesible. La posición de la parte inferior de la pila es fija, mientras que la posición de la parte superior de la pila se puede mover y la parte superior de la pila siempre está vacía.
El motivo de esta propiedad es que después de insertar el nuevo valor en la pila virtual, en la posición original de la parte superior de la pila se escribirá el nuevo valor, el puntero superior de la pila avanzará a la siguiente posición; por el contrario, si se extrae el valor en la parte superior de la pila virtual, el puntero superior de la pila disminuirá de 1. En este momento, aunque la posición del puntero superior de la pila es objetivamente un valor, este no es válido y se puede borrar en cualquier momento, por lo que la posición del puntero en la parte superior de la pila aún está vacía.
Cuando la pila virtual está vacía, el puntero inferior <code class="docutils literal notranslate"><span class="pre">base</span></code> es igual al puntero superior <code class="docutils literal notranslate"><span class="pre">top</span></code>. La pila virtual no sigue estrictamente las reglas de funcionamiento de la pila: además de empujar y sacar, también se puede acceder a la pila virtual por índice, e incluso insertar o eliminar valores en cualquier posición. Hay dos formas de indexar elementos en la pila: una se basa en la parte inferior de la pila <strong>Índice absoluto</strong>, el valor del índice absoluto es un número entero positivo a partir de 1; el otro se basa en la parte superior de la pila <strong>Índice relativo</strong>, el valor del índice relativo es un número entero negativo a partir de − 1. Tome la Figura anterior como ejemplo, el valor de índice 1, 2…8 es un índice absoluto, y el índice absoluto de un elemento es la distancia desde el elemento hasta el final de la pila. El valor de índice − 1, − 2… − 8 es un índice relativo, y el valor de índice relativo de un elemento es el número negativo de la distancia desde el elemento hasta la parte superior de la pila. Si un valor de índice <em>index</em> es válido, entonces el elemento al que se refiere debe estar entre la parte inferior de la pila y la parte superior de la pila, lo que significa se cumple  que la expresión:</p>
<p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">≤</span> <span class="pre">abs(*index*)</span> <span class="pre">≤</span> <span class="pre">*top*</span> <span class="pre">−</span> <span class="pre">*base*</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
<p>Por conveniencia, estipulamos que el puntero inferior de la pila ‘base’ se usa como referencia, y su índice absoluto 1, y el valor anterior de ‘base’ no se considera (por lo general, ‘base’ no es la posición inferior de todo el pila). Por ejemplo, cuando regresa una función nativa, la ubicación donde se almacena el valor de retorno está justo antes de <code class="docutils literal notranslate"><span class="pre">base</span></code>, y la función nativa no suele acceder a estas ubicaciones.</p>
</section>
<section id="operar-con-pila-virtual">
<h3>Operar con pila virtual<a class="headerlink" href="#operar-con-pila-virtual" title="Permalink to this headline">¶</a></h3>
<section id="indice-y-tamano-de-pila">
<h4>Índice y tamaño de pila<a class="headerlink" href="#indice-y-tamano-de-pila" title="Permalink to this headline">¶</a></h4>
<p>Como se mencionó anteriormente, se pueden usar dos métodos de indexación para acceder a la pila virtual y el valor del índice debe ser válido. Al mismo tiempo, en muchos casos también es necesario introducir nuevos valores en la pila. En este caso, el programador debe asegurarse de que la pila no se desborde.
Por defecto, Berry garantiza el espacio <code class="docutils literal notranslate"><span class="pre">BE_STACK_FREE_MIN</span></code> para que lo usen las funciones nativas. Este valor se puede modificar en el archivo <em>berry.h</em>. Su valor por defecto suele ser 10, que debería ser suficiente en la mayoría de los casos.
Si realmente necesita expandir la pila, puede llamar a la función FFI <code class="docutils literal notranslate"><span class="pre">be_stack_require</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_stack_require</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">count</span></code> es la cantidad de espacio necesario. Cuando el espacio restante en la pila virtual sea insuficiente, la capacidad de la pila se expandirá; de lo contrario, esta función no hará nada.</p>
<p><strong>Advertencia</strong>: si se produce un desbordamiento de la pila, o si se utiliza un índice no válido para acceder a la pila, el programa fallará. Puede activar el interruptor de depuración <code class="docutils literal notranslate"><span class="pre">BE_DEBUG</span></code> (sección <a href="#section::BE_DEBUG" data-reference-type="ref" data-reference="section::BE_DEBUG">[sección::BE_DEBUG]</a> ), que activará la función de aserción, y puede obtener información de depuración en tiempo de ejecución para detectar errores como desbordamiento de pila o índice no válido.</p>
</section>
<section id="obtener-valor-de-la-pila">
<h4>Obtener valor de la pila<a class="headerlink" href="#obtener-valor-de-la-pila" title="Permalink to this headline">¶</a></h4>
<p>Hay un conjunto de funciones en FFI para obtener valores de la pila virtual.
Estas funciones generalmente convierten los valores en la pila en valores simples compatibles con el lenguaje C y luego regresan. Los siguientes son FFI de uso común para obtener valores de la pila:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bint</span><span class="w"> </span><span class="nf">be_toint</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="n">breal</span><span class="w"> </span><span class="nf">be_toreal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">be_tobool</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tostring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tocomptr</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>La forma de parámetro de estas funciones es la misma, pero el valor de retorno es diferente. Las primeras cuatro funciones son fáciles de entender. Al igual que sus nombres, la función de <code class="docutils literal notranslate"><span class="pre">be_toint</span></code> es convertir los valores en la pila virtual a valores enteros de C (<code class="docutils literal notranslate"><span class="pre">bint</span></code> suele ser un alias de tipo <code class="docutils literal notranslate"><span class="pre">int</span></code>) y devolverlos. La función de la última función <code class="docutils literal notranslate"><span class="pre">be_tocomptr</span></code> es sacar un valor de puntero de tipo general de la pila virtual. El significado específico de este puntero se explica por el propio programa C.</p>
<p>Estas funciones utilizan la misma forma de interpretar los parámetros: el parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del elemento a recuperar, que puede ser un índice relativo o un índice absoluto. No puede usar FFI para eliminar los tipos de datos complejos de Berry de la pila virtual, por lo que no puede eliminar un tipo de “map” o un tipo de “class” de la pila. Uno de los beneficios de este diseño es que no es necesario considerar la recolección de elementos no utilizados en las funciones nativas.</p>
</section>
</section>
<section id="funcion-nativa">
<h3>Función nativa<a class="headerlink" href="#funcion-nativa" title="Permalink to this headline">¶</a></h3>
<p>Una <strong>Función nativa</strong> está implementada por lenguaje C y puede ser llamada por código Berry. La función nativa puede ser una función ordinaria. En este caso, llamar a la función nativa no generará ningún espacio asignado dinámicamente, al igual que una llamada de función C normal. Las funciones nativas también pueden ser cierres, y se debe asignar espacio para variables libres al crear cierres nativos. En circunstancias normales, las funciones nativas simples son suficientes para satisfacer las necesidades. Ahorran más recursos que los cierres nativos y son más fáciles de usar.</p>
<section id="definir-una-funcion-nativa">
<h4>Definir una función nativa<a class="headerlink" href="#definir-una-funcion-nativa" title="Permalink to this headline">¶</a></h4>
<p>La función nativa en sí es una función C, pero todas tienen una forma específica. La definición de la función nativa es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">a_native_function</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// hacer algo ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>La función nativa debe ser una función C cuyo parámetro sea un puntero a <code class="docutils literal notranslate"><span class="pre">bvm</span></code> y el valor de retorno sea <code class="docutils literal notranslate"><span class="pre">int</span></code>. Las funciones de Berry deben devolver un valor y las funciones nativas no son una excepción. A diferencia del valor de retorno del lenguaje C, el valor de retorno de la función nativa no es el valor transportado por la instrucción C <code class="docutils literal notranslate"><span class="pre">return</span></code>. Puede usar estos FFI para devolver el valor de la función nativa, y también hacen que la función C devuelva:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_return</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
<span class="n">be_return_nil</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Estos FFI son en realidad dos macros, y no es necesario usar la instrucción C <code class="docutils literal notranslate"><span class="pre">return</span></code> al usarlos. <code class="docutils literal notranslate"><span class="pre">be_return</span></code> pondrá la parte superior de la pila virtual</p>
</section>
<section id="usar-una-funcion-nativa">
<h4>Usar una función nativa<a class="headerlink" href="#usar-una-funcion-nativa" title="Permalink to this headline">¶</a></h4>
<p>Después de definir la función nativa, debe agregarse al intérprete de alguna manera antes de que pueda llamarse en código Berry. Una de las formas más sencillas es agregar funciones nativas a la tabla de objetos integrada de Berry. El proceso de configuración de objetos nativos como objetos incorporados de Berry se denomina <strong>registración</strong>. El FFI de la función nativa registrada es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_regfunc</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">nombre</span><span class="p">,</span><span class="w"> </span><span class="n">bntvfunc</span><span class="w"> </span><span class="n">f</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">vm</span></code> es la instancia actual de la máquina virtual, <code class="docutils literal notranslate"><span class="pre">nombre</span></code> es el nombre de la función nativa y <code class="docutils literal notranslate"><span class="pre">f</span></code> es el puntero de la función nativa. El comportamiento específico de esta función está relacionado con el valor de la macro <code class="docutils literal notranslate"><span class="pre">BE_USE_PRECOMPILED_OBJECT</span></code> (aunque el FFI todavía está disponible cuando se utiliza la técnica de construcción en tiempo de compilación, no puede registrar dinámicamente las variables integradas. En este caso, consulte el método de registro de los objetos integrados.
<a href="#section::precompiled_build" data-reference-type="ref" data-reference="section::precompiled_build">1.3</a> ).
La definición del tipo de función nativa <code class="docutils literal notranslate"><span class="pre">bntvfunc</span></code> es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">bntvfunc</span><span class="p">)(</span><span class="n">bvm</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>De hecho, el tipo <code class="docutils literal notranslate"><span class="pre">bntvfunc</span></code> es el tipo de puntero de función con el parámetro <code class="docutils literal notranslate"><span class="pre">bvm</span></code> y el tipo de valor devuelto <code class="docutils literal notranslate"><span class="pre">int</span></code>. La función <code class="docutils literal notranslate"><span class="pre">be_regfunc</span></code> debe llamarse antes de analizar el código fuente de Berry.</p>
<p>También puede insertar la función nativa en la pila virtual y luego usar una función FFI <code class="docutils literal notranslate"><span class="pre">be_call</span></code> para llamarla. Un uso más común es usar el objeto de función nativa en la pila virtual como valor de retorno.</p>
</section>
<section id="ejemplo-completo">
<h4>Ejemplo completo<a class="headerlink" href="#ejemplo-completo" title="Permalink to this headline">¶</a></h4>
<p>Finalizamos esta sección con un ejemplo sencillo. Aquí, vamos a implementar una función <code class="docutils literal notranslate"><span class="pre">add</span></code> que suma dos números y devuelve el resultado del cálculo. Primero, definimos una función nativa para implementar esta función:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">l_add</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_top</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Obtener el número de argumentos</span>
<span class="w">    </span><span class="cm">/* Verificar el número y tipo de argumentos */</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">be_isnumber</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">be_isnumber</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">breal</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_toreal</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Obtener el primer argumento</span>
<span class="w">        </span><span class="n">breal</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_toreal</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// Obtener el segundo argumento</span>
<span class="w">        </span><span class="n">be_pushreal</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// Empuje el resultado a la pila</span>
<span class="w">        </span><span class="n">be_return</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Devuelve el valor en la parte superior de la pila</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">be_return_nil</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Devuelve nil cuando algo sale mal</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Por lo general, las funciones nativas no necesitan usarse fuera del archivo C, por lo que generalmente se declaran como tipos <code class="docutils literal notranslate"><span class="pre">estáticos</span></code>. Utilice la función <code class="docutils literal notranslate"><span class="pre">be_top</span></code> para obtener el índice absoluto de la parte superior de la pila virtual (valor <code class="docutils literal notranslate"><span class="pre">top</span></code>), que es la capacidad de la pila. Podemos llamar a <code class="docutils literal notranslate"><span class="pre">be_top</span></code> antes de que la función nativa realice la operación de pila virtual, en este momento la capacidad de la pila virtual es igual a la cantidad de parámetros reales. Para la función <code class="docutils literal notranslate"><span class="pre">add</span></code>, necesitamos dos parámetros para participar en la operación, así que verifica si el número de parámetros es 2 en la cuarta línea (<code class="docutils literal notranslate"><span class="pre">top</span> <span class="pre">==</span> <span class="pre">2</span></code>). Y necesitamos verificar si los dos parámetros son de tipo numérico, por lo que debemos llamar a la función <code class="docutils literal notranslate"><span class="pre">be_isnumber</span></code> para verificar.
Si todo es correcto, los parámetros se sacarán de la pila virtual, luego el resultado del cálculo se colocará en la pila y finalmente se devolverá usando <code class="docutils literal notranslate"><span class="pre">be_return</span></code>. Si la verificación del parámetro falla, se llamará a <code class="docutils literal notranslate"><span class="pre">be_return_nil</span></code> para devolver el valor de <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>A continuación, registre esta función nativa en la tabla de objetos integrada. Para simplificar, lo registramos después de cargar la biblioteca:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_vm_new</span><span class="p">();</span><span class="w"> </span><span class="c1">// Construir una VM</span>
<span class="n">be_regfunc</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;myadd&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">l_add</span><span class="p">);</span><span class="w"> </span><span class="c1">// Registrar la función nativa &quot;myadd&quot;</span>
</pre></div>
</div>
<p>La segunda línea es donde se registra la función nativa y la llamamos <code class="docutils literal notranslate"><span class="pre">myadd</span></code>. En este punto, la definición y el registro de la función nativa están completos. Como verificación, puede compilar el intérprete, luego ingresar el REPL y ejecutar algunas pruebas. Debería obtener resultados como este:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span>&gt; myadd
&lt;function: 0x562a210f0f90&gt;
&gt; myadd(1.0, 2.5)
3.5
&gt; myadd(2.5, 2)
4.5
&gt; myadd(1, 2)
3
</pre></div>
</div>
</section>
</section>
</section>
<section id="tipos-y-funciones">
<h2>Tipos y Funciones<a class="headerlink" href="#tipos-y-funciones" title="Permalink to this headline">¶</a></h2>
<section id="tipos">
<h3>Tipos<a class="headerlink" href="#tipos" title="Permalink to this headline">¶</a></h3>
<p>Esta sección presentará algunos tipos que deben usarse en FFI y son generalmente utilizados por funciones FFI.
Generalmente, los tipos y declaraciones en FFI se pueden encontrar en el archivo <em>berry.h</em>. A menos que se especifique lo contrario en esta sección, la definición o declaración se proporciona en <em>berry.h</em> de forma predeterminada.</p>
<p>El tipo <code class="docutils literal notranslate"><span class="pre">bvm</span></code> se utiliza para almacenar la información de estado de la máquina virtual Berry. Los detalles de este tipo no son visibles para los programas externos.
Por lo tanto, esta definición solo se puede encontrar en el archivo <em>berry.h</em>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">bvm</span><span class="w"> </span><span class="n">bvm</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>La mayoría de las funciones de FFI usan el tipo <code class="docutils literal notranslate"><span class="pre">bvm</span></code> como primer parámetro, porque todas operan en la máquina virtual internamente. Ocultar la implementación interna de <code class="docutils literal notranslate"><span class="pre">bvm</span></code> ayuda a reducir el acoplamiento entre el estándar FFI y la VM. Fuera del intérprete, normalmente solo se utilizan punteros <code class="docutils literal notranslate"><span class="pre">bvm</span></code>. Para crear un nuevo objeto <code class="docutils literal notranslate"><span class="pre">bvm</span></code>, use la función <code class="docutils literal notranslate"><span class="pre">be_vm_new</span></code> y destruya el objeto <code class="docutils literal notranslate"><span class="pre">bvm</span></code> usando la función <code class="docutils literal notranslate"><span class="pre">be_vm_delete</span></code>.</p>
<p>La definición del tipo de función nativa es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">bntvfunc</span><span class="p">)(</span><span class="n">bvm</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Este tipo es un puntero de función nativo y algunas FFI que registran o agregan funciones nativas a la máquina virtual usan parámetros de este tipo.
Las variables o parámetros de este tipo deben inicializarse con un nombre de función cuyo parámetro sea del tipo <code class="docutils literal notranslate"><span class="pre">bvm</span></code> y cuyo valor de retorno sea del tipo <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<p>Este tipo se usa cuando se registran funciones nativas en lotes o se construyen clases nativas. Se define como:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">nombre</span><span class="p">;</span><span class="w"> </span><span class="c1">// El nombre de la función u objeto</span>
<span class="w">    </span><span class="n">bntvfunc</span><span class="w"> </span><span class="n">funcion</span><span class="p">;</span><span class="w"> </span><span class="c1">// El puntero de función</span>
<span class="p">}</span><span class="w"> </span><span class="n">bnfuncinfo</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>El miembro <code class="docutils literal notranslate"><span class="pre">nombre</span></code> de <code class="docutils literal notranslate"><span class="pre">bnfuncinfo</span></code> representa el nombre de una función u objeto, y el miembro <code class="docutils literal notranslate"><span class="pre">funcion</span></code> es un puntero de función nativo.</p>
<p>Este tipo es un tipo entero integrado de Berry. Se define en el documento <em>berry.h</em>. Por defecto, <code class="docutils literal notranslate"><span class="pre">bint</span></code> se implementa usando el tipo <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>, y la implementación de <code class="docutils literal notranslate"><span class="pre">bint</span></code> se puede modificar cambiando el archivo de configuración.</p>
<p>Este es el tipo de número real incorporado de Berry, que en realidad es el tipo de punto flotante en lenguaje C. <code class="docutils literal notranslate"><span class="pre">breal</span></code> se define como:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#if BE_SINGLE_FLOAT != 0</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">breal</span><span class="p">;</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">breal</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Puede usar la macro <code class="docutils literal notranslate"><span class="pre">BE_SINGLE_FLOAT</span></code> para controlar la implementación específica de <code class="docutils literal notranslate"><span class="pre">breal</span></code>: cuando el valor de <code class="docutils literal notranslate"><span class="pre">BE_SINGLE_FLOAT</span></code> es <code class="docutils literal notranslate"><span class="pre">0</span></code>, se usará la implementación de tipo <code class="docutils literal notranslate"><span class="pre">doble</span></code> <code class="docutils literal notranslate"><span class="pre">breal</span></code>, de lo contrario, la implementación de tipo <code class="docutils literal notranslate"><span class="pre">float</span></code> se utilizará para <code class="docutils literal notranslate"><span class="pre">breal</span></code>.</p>
<p><span id="section::errorcode"
label="section::errorcode">[sección::código de error]</span></p>
<p>Este tipo de enumeración se utiliza en algunos valores de retorno de FFI. La definición de este tipo es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">berrorcode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_OK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_IO_ERROR</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_SYNTAX_ERROR</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_EXEC_ERROR</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_MALLOC_FAIL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BE_EXIT</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>El significado de estos valores de enumeración son:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BE_OK</span></code>: No hay ningún error, la función se ejecuta con éxito.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_IO_ERROR</span></code>: Ocurrió un error de lectura de archivo cuando el intérprete
estaba leyendo el archivo fuente. El error generalmente es causado por el
ausencia del expediente.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_SYNTAX_ERROR</span></code>: Ocurrió un error de sintaxis cuando el intérprete estaba
compilando el código fuente. Después de que ocurre este error, el intérprete
no generará bytecode, por lo que no puede continuar ejecutándose
el código de bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_EXEC_ERROR</span></code>: Error de tiempo de ejecución. Cuando se produce este error, la ejecución de
El código Berry se detiene y el entorno se restaura al máximo
punto de recuperación reciente.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_MALLOC_FAIL</span></code>: Falló la asignación de memoria. Este error es causado por
espacio de pila insuficiente.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BE_EXIT</span></code>: Indica que el programa sale y el valor no es un error. Ejecutar la función <code class="docutils literal notranslate"><span class="pre">exit</span></code> de Berry hace que el
intérprete devuelva este valor.</p></li>
</ul>
<p>Cabe señalar que cuando se produce un error <code class="docutils literal notranslate"><span class="pre">BE_MALLOC_FAIL</span></code>, ya no se puede realizar la asignación de memoria dinámica, lo que significa que ya no se pueden asignar objetos de cadena, por lo que la función que devuelve este error generalmente no brinda información más detallada sobre el error.</p>
</section>
<section id="funciones-y-macros">
<h3>Funciones y Macros<a class="headerlink" href="#funciones-y-macros" title="Permalink to this headline">¶</a></h3>
<p>Esta función se utiliza para crear una nueva instancia de máquina virtual. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bvm</span><span class="o">*</span><span class="w"> </span><span class="nf">be_vm_new</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El valor de retorno de la función es un puntero a la instancia de la máquina virtual. <code class="docutils literal notranslate"><span class="pre">be_vm_new</span></code> es la primera función llamada cuando se crea el intérprete de Berry. Esta función hará mucho trabajo: solicitar memoria para la máquina virtual, inicializar el estado y los atributos de la máquina virtual, inicializar el GC (recolector de basura), la biblioteca estándar se carga en la instancia de la máquina virtual, etc.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_vm_delete</span></code> se usa para destruir una instancia de máquina virtual. El prototipo de la función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_vm_delete</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero del objeto de la máquina virtual que se va a destruir. La destrucción de la máquina virtual liberará todos los objetos de la máquina virtual, incluidos los valores de la pila y los objetos administrados por el GC. El puntero de la máquina virtual después de la destrucción será un valor no válido y ya no se podrá hacer referencia a él.</p>
<p>Esta función se utiliza para cargar un fragmento de código fuente del búfer y compilarlo en un código de bytes. El prototipo de la función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_loadbuffer</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la máquina virtual. <code class="docutils literal notranslate"><span class="pre">name</span></code> es una cadena, que generalmente se usa para marcar la fuente del código fuente. Por ejemplo, la entrada del código fuente del dispositivo de entrada estándar puede pasar la cadena <code class="docutils literal notranslate"><span class="pre">&quot;stdin&quot;</span></code> a este parámetro, y la entrada del código fuente del archivo puede ser el nombre del archivo y se pasa a este parámetro. El parámetro <code class="docutils literal notranslate"><span class="pre">buffer</span></code> es el búfer para almacenar el código fuente. La organización de este búfer es muy similar a la cadena de C. Es una secuencia continua de caracteres, pero el búfer al que apunta <code class="docutils literal notranslate"><span class="pre">buffer</span></code> no requiere caracteres <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> como terminador. El parámetro <code class="docutils literal notranslate"><span class="pre">longitud</span></code> indica la longitud del búfer. Esta longitud se refiere al número de bytes de texto de código fuente en el búfer.</p>
<p>Para dar un ejemplo simple, si queremos usar la función <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> para compilar una cadena, el uso general es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;print(&#39;Hola Berry&#39;)&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">be_loadbuffer</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cadena&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>Aquí usamos la cadena <code class="docutils literal notranslate"><span class="pre">&quot;cadena&quot;</span></code> para representar el código fuente, también puede modificarla a cualquier valor. Tenga en cuenta que la función <code class="docutils literal notranslate"><span class="pre">strlen</span></code> de la función de biblioteca estándar de C se usa aquí para obtener la longitud del búfer de cadena (en realidad, el número de bytes en la cadena).</p>
<p>Si la compilación es exitosa, <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> compilará el código fuente en una función Berry y lo colocará en la parte superior de la pila virtual. Si la compilación encuentra un error, <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> devolverá un valor de error de tipo <code class="docutils literal notranslate"><span class="pre">berrorcode</span></code> [ver Sección código de error] y, si es posible, almacenará la cadena de mensaje de error específica en la parte superior de la pila virtual.</p>
<p><code class="docutils literal notranslate"><span class="pre">be_loadstring</span></code> es una macro definida como:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define be_loadstring(vm, str) be_loadbuffer((vm), &quot;string&quot;, (str), strlen(str))</span>
</pre></div>
</div>
<p>Esta macro es solo un contenedor simple para la función <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code>.
El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es un puntero a la instancia de la máquina virtual, y el parámetro <code class="docutils literal notranslate"><span class="pre">str</span></code> es un puntero a la cadena de código fuente. Es muy conveniente usar <code class="docutils literal notranslate"><span class="pre">be_loadstring</span></code> para compilar cadenas, por ejemplo:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_loadstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;print(&#39;Hola Berry&#39;)&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Esta forma de escribir es más concisa que usar <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code>, pero debe asegurarse de que la cadena termine con un carácter <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>.</p>
<p>Esta función se utiliza para compilar un archivo de código fuente. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_loadfile</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">nombre</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>La funcionalidad de esta función es similar a la función <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code>, excepto que la función se compilará leyendo el archivo de código fuente. El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual y el parámetro <code class="docutils literal notranslate"><span class="pre">nombre</span></code> es el nombre del archivo de origen. Esta función llamará a la interfaz de archivo y, de forma predeterminada, utilizará funciones como <code class="docutils literal notranslate"><span class="pre">fopen</span></code> en la biblioteca estándar de C para manipular archivos.</p>
<p>Si usa la interfaz de archivo de la biblioteca estándar de C, puede usar nombres de archivo de ruta relativa o ruta absoluta. Si el archivo no existe, <code class="docutils literal notranslate"><span class="pre">be_loadfile</span></code> devolverá un error <code class="docutils literal notranslate"><span class="pre">BE_IO_ERROR</span></code> (Ve Seccion de código de error) y colocará el mensaje de error en la parte superior de la pila. Otros mensajes de error son los mismos que los de la función <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code>. Se recomienda usar la función <code class="docutils literal notranslate"><span class="pre">be_loadfile</span></code> para compilar el archivo fuente, en lugar de leer todos los archivos fuente en un búfer, y luego llamar a la función <code class="docutils literal notranslate"><span class="pre">be_loadbuffer</span></code> para compilar el código fuente. El primero leerá el archivo fuente en segmentos y solo creará un pequeño búfer de lectura en la memoria, ahorrando así más memoria.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_top</span></code> devuelve el valor de índice absoluto del elemento superior en la pila virtual. Este valor es también el número de elementos en la pila virtual (la capacidad de la pila virtual). Llame a esta función antes de agregar o quitar elementos en la pila virtual para obtener la cantidad de parámetros de la función nativa. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_top</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Esta función se suele utilizar para obtener el número de parámetros de una función nativa. Cuando se usa para este propósito, se recomienda llamar a <code class="docutils literal notranslate"><span class="pre">be_top</span></code> en la parte superior del cuerpo de la función nativa. P.ej:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">native_function_example</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">be_top</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"> </span><span class="c1">// Obtener el número de argumentos</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_typename</span></code> convierte el tipo del objeto Berry en una cadena y lo devuelve. Por ejemplo, devuelve <code class="docutils literal notranslate"><span class="pre">&quot;int&quot;</span></code> para un objeto entero y <code class="docutils literal notranslate"><span class="pre">&quot;function&quot;</span></code> para un objeto función. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_typename</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto a operar. La función <code class="docutils literal notranslate"><span class="pre">type</span></code> en la biblioteca estándar de Berry se implementa llamando a <code class="docutils literal notranslate"><span class="pre">be_typename</span></code>.
Consulte la sección <code class="docutils literal notranslate"><span class="pre">baselib_type</span></code> para conocer la cadena de retorno correspondiente al tipo de parámetro.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_classname</span></code> se utiliza para obtener el nombre de clase de un objeto o clase. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_classname</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto a operar. Si el valor en <code class="docutils literal notranslate"><span class="pre">index</span></code> es una instancia, la función <code class="docutils literal notranslate"><span class="pre">be_classname</span></code> devolverá la cadena del nombre de la clase a la que pertenece la instancia, y si el valor en <code class="docutils literal notranslate"><span class="pre">index</span></code> es una clase, devolverá directamente la cadena del nombre de la clase. En otros casos <code class="docutils literal notranslate"><span class="pre">be_classname</span></code> devolverá <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_strlen</span></code> devuelve la longitud de la cadena Berry especificada. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_strlen</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto a operar. Esta función devuelve el número de bytes en la cadena en <code class="docutils literal notranslate"><span class="pre">index</span></code> (los caracteres <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> al final de la cadena Berry no se cuentan). Si el valor de la posición <code class="docutils literal notranslate"><span class="pre">index</span></code> no es una cadena, la función <code class="docutils literal notranslate"><span class="pre">be_strlen</span></code> devolverá <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Aunque la cadena <code class="docutils literal notranslate"><span class="pre">Berry</span></code> es compatible con el formato de cadena C, no se recomienda utilizar la función <code class="docutils literal notranslate"><span class="pre">strlen</span></code> de la biblioteca estándar de C para medir la longitud de la cadena Berry. Para cadenas Berry, <code class="docutils literal notranslate"><span class="pre">be_strlen</span></code> es más rápido que <code class="docutils literal notranslate"><span class="pre">strlen</span></code> y tiene mejor compatibilidad.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_strconcat</span></code> se utiliza para empalmar dos cadenas Berry. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_strconcat</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual. Esta función concatenará la cadena en la posición del parámetro de <code class="docutils literal notranslate"><span class="pre">index</span></code> con la cadena en la posición superior de la pila, y luego colocará la cadena resultante en la posición indexada por <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_pop</span></code> extrae el valor en la parte superior de la pila. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pop</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, y el parámetro <code class="docutils literal notranslate"><span class="pre">n</span></code> es la cantidad de valores que se extraerán de la pila.
Tenga en cuenta que el valor de <code class="docutils literal notranslate"><span class="pre">n</span></code> no puede exceder la capacidad de la pila.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_remove</span></code> elimina un valor de la pila. Esta función eliminará un valor de la pila.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_remove</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual y el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto que se eliminará. Después de que el valor en <code class="docutils literal notranslate"><span class="pre">index</span></code> se mueva, los siguientes valores se completarán y la capacidad de la pila se reducirá en uno. El valor de <code class="docutils literal notranslate"><span class="pre">index</span></code> no puede exceder la capacidad de la pila.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_absindex</span></code> devuelve el valor de índice absoluto de un valor de índice dado, y su prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_absindex</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual y el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> es el valor del índice de entrada. Si <code class="docutils literal notranslate"><span class="pre">index</span></code> es positivo, el valor de retorno de <code class="docutils literal notranslate"><span class="pre">be_absindex</span></code> es el valor de <code class="docutils literal notranslate"><span class="pre">index</span></code>. Si <code class="docutils literal notranslate"><span class="pre">index</span></code> es negativo, el valor de retorno de be_absindex es el valor de índice absoluto correspondiente a <code class="docutils literal notranslate"><span class="pre">index</span></code>. Cuando <code class="docutils literal notranslate"><span class="pre">index</span></code> es un valor negativo (índice relativo), su posición de índice no puede ser inferior a la parte inferior de la pila.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_newlist</span></code> crea un nuevo valor de <code class="docutils literal notranslate"><span class="pre">list</span></code>, y su prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_newlist</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual. Después de llamar con éxito a esta función, el nuevo valor de <code class="docutils literal notranslate"><span class="pre">list</span></code> se colocará en la parte superior de la pila. El valor <code class="docutils literal notranslate"><span class="pre">list</span></code> es una representación interna de una lista, que no debe confundirse con una instancia de la clase <code class="docutils literal notranslate"><span class="pre">list</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_newmap</span></code> crea un nuevo valor <code class="docutils literal notranslate"><span class="pre">map</span></code>, y su prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_newmap</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual. Después de llamar con éxito a esta función, el nuevo valor del <code class="docutils literal notranslate"><span class="pre">map</span></code> se colocará en la parte superior de la pila. El valor <code class="docutils literal notranslate"><span class="pre">map</span></code> es una representación interna de una lista, que no debe confundirse con una instancia de la clase <code class="docutils literal notranslate"><span class="pre">map</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_getglobal</span></code> empuja la variable global con el nombre especificado a la pila. Su prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getglobal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual y el parámetro <code class="docutils literal notranslate"><span class="pre">name</span></code> es el nombre de la variable global. Después de llamar a esta función, la variable global llamada <code class="docutils literal notranslate"><span class="pre">name</span></code> se colocará en la parte superior de la pila virtual.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_setmember</span></code> se utiliza para establecer el valor de la variable miembro de la clase de objeto de instancia. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_setmember</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto de la instancia y el parámetro <code class="docutils literal notranslate"><span class="pre">k</span></code> es el nombre del miembro. Esta función copiará el valor en la parte superior de la pila al miembro <code class="docutils literal notranslate"><span class="pre">k</span></code> de la instancia de posición de índice. Tenga en cuenta que el elemento superior de la pila no aparecerá automáticamente.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_getmember</span></code> se utiliza para obtener el valor de la variable miembro de la clase de objeto de instancia. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getmember</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto de la instancia y el parámetro <code class="docutils literal notranslate"><span class="pre">k</span></code> es el nombre del miembro. Esta función coloca el valor del miembro de la instancia de posición de índice <code class="docutils literal notranslate"><span class="pre">k</span></code> en la parte superior de la pila virtual.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_getindex</span></code> se utiliza para obtener el valor de <code class="docutils literal notranslate"><span class="pre">list</span></code> o <code class="docutils literal notranslate"><span class="pre">map</span></code>. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getindex</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, y el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto a operar. Esta función se usa para obtener un elemento del contenedor <code class="docutils literal notranslate"><span class="pre">map</span></code> o <code class="docutils literal notranslate"><span class="pre">list</span></code> (valores internos, no instancias de las clases <code class="docutils literal notranslate"><span class="pre">map</span></code> o <code class="docutils literal notranslate"><span class="pre">list</span></code>), y el índice del elemento se almacena en la parte superior de la pila (el índice relativo es -1). Después de llamar a esta función, el valor obtenido del contenedor se colocará en la parte superior de la pila. Si no hay ningún subíndice señalado por el contenedor, el valor <code class="docutils literal notranslate"><span class="pre">nil</span></code> se colocará en la parte superior de la pila. Por ejemplo, si el elemento con el índice 1 en la pila virtual es una <code class="docutils literal notranslate"><span class="pre">list</span></code> y queremos extraer el elemento con el índice 0, entonces podemos usar el siguiente código:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_pushint</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">//  Inserte el valor de índice 0 en la pila virtual</span>
<span class="n">be_getindex</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">//  Obtener un elemento del contenedor de lista</span>
</pre></div>
</div>
<p>Primero colocamos el valor entero <code class="docutils literal notranslate"><span class="pre">0</span></code> en la pila, y este valor se usará como índice para obtener el elemento del contenedor <code class="docutils literal notranslate"><span class="pre">list</span></code>. La segunda línea de código implementa para obtener elementos del contenedor <code class="docutils literal notranslate"><span class="pre">list</span></code>. El valor de índice del contenedor <code class="docutils literal notranslate"><span class="pre">list</span></code> en el ejemplo es 1 en la pila virtual. El elemento recuperado se almacena en la parte superior de la pila y podemos usar el índice relativo -1 para acceder a él.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_setindex</span></code> se utiliza para establecer un valor en <code class="docutils literal notranslate"><span class="pre">list</span></code> o <code class="docutils literal notranslate"><span class="pre">map</span></code>. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_setindex</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, y el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> es el subíndice del objeto a operar.
Esta función se utiliza para escribir un elemento del contenedor <code class="docutils literal notranslate"><span class="pre">map</span></code> o <code class="docutils literal notranslate"><span class="pre">list</span></code>. El índice del valor que se va a escribir en la pila virtual es -1, y el índice del subíndice de la posición de escritura en la pila virtual es -2. Si el elemento con el subíndice especificado no existe en el contenedor, la operación de escritura fallará.</p>
<p>Suponiendo que la posición con el índice <code class="docutils literal notranslate"><span class="pre">1</span></code> en la pila virtual tiene un valor de <code class="docutils literal notranslate"><span class="pre">map</span></code>, y tiene un elemento con un subíndice de <code class="docutils literal notranslate"><span class="pre">&quot;prueba&quot;</span></code>, un ejemplo de configuración del elemento en el subíndice de <code class="docutils literal notranslate"><span class="pre">&quot;prueba&quot;</span> </code> a <code class="docutils literal notranslate"><span class="pre">100</span></code> es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_pushstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;prueba&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Empuja el índice &quot;índice&quot;</span>
<span class="n">be_pushint</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">         </span><span class="c1">// Empuja el valor 100</span>
<span class="n">be_setindex</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">          </span><span class="c1">// Establece el par clave-valor a map[&quot;prueba&quot;] = 100</span>
</pre></div>
</div>
<p>Primero debemos empujar el subíndice y el valor que se escribirá en la pila en orden. Para <code class="docutils literal notranslate"><span class="pre">map</span></code>, es un par clave-valor. En el ejemplo, las dos primeras líneas de código completan estas tareas. La tercera línea llama a la función <code class="docutils literal notranslate"><span class="pre">be_setindex</span></code> para escribir el valor en el objeto <code class="docutils literal notranslate"><span class="pre">map</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_getupval</span></code> se utiliza para leer un valor ascendente del cierre nativo. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getupval</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el valor de índice de cierre nativo del valor ascendente que se va a leer; <code class="docutils literal notranslate"><span class="pre">pos</span></code> es la posición del upvalue en la tabla upvalue de cierre nativa (la numeración comienza desde 0). El valor leído se colocará en la parte superior de la pila virtual.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_setupval</span></code> se utiliza para establecer un valor superior del cierre nativo. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_setupval</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el valor del índice de cierre nativo que se escribirá en upvalue; <code class="docutils literal notranslate"><span class="pre">pos</span></code> es la posición del upvalue en la tabla upvalue de cierre nativa (la numeración comienza desde 0). Esta función obtiene un valor de la parte superior de la pila virtual y lo escribe en el valor superior de destino.
Una vez completada la operación, el valor superior de la pila no se extraerá de la pila.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_getsuper</span></code> se utiliza para obtener el objeto principal de la clase base o la instancia de la clase. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_getsuper</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es la clase u objeto a operar. Si el valor en <code class="docutils literal notranslate"><span class="pre">index</span></code> es una clase con una clase base, la función colocará su clase base en la parte superior de la pila; si el valor en <code class="docutils literal notranslate"><span class="pre">index</span></code> es un objeto con un objeto padre, la función tomará su padre. El objeto se coloca en la parte superior de la pila; de lo contrario, se coloca un valor de <code class="docutils literal notranslate"><span class="pre">nil</span></code> en la parte superior de la pila.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_data_size</span></code> se utiliza para obtener el número de elementos contenidos en el contenedor. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_data_size</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto contenedor que se va a operar. Si el valor en <code class="docutils literal notranslate"><span class="pre">index</span></code> es un valor Map o List, la función devuelve el número de elementos contenidos en el contenedor; de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_data_push</span></code> se usa para agregar un nuevo elemento al final del contenedor. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_data_push</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto contenedor que se va a operar. El objeto en <code class="docutils literal notranslate"><span class="pre">index</span></code> debe ser un valor de Lista. Esta función obtiene un valor de la parte superior de la pila y lo agrega al final del contenedor. Una vez completada la operación, el valor en la parte superior de la pila no se extraerá de la pila.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_data_insert</span></code> se utiliza para insertar un par de elementos en el contenedor.
El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_data_insert</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto contenedor que se va a operar. El objeto en <code class="docutils literal notranslate"><span class="pre">index</span></code> debe ser un valor de lista o un valor de mapa. El elemento insertado forma un par de pares clave-valor. El valor se almacena en la parte superior de la pila y la clave se almacena en el índice anterior en la parte superior de la pila. Cabe señalar que la clave insertada en el contenedor Mapa no puede ser un valor “nil” y la clave insertada en el contenedor Lista debe ser un valor entero. Si la operación es exitosa, la función devolverá <code class="docutils literal notranslate"><span class="pre">bture</span></code>, de lo contrario devolverá <code class="docutils literal notranslate"><span class="pre">bfalse</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_data_remove</span></code> se utiliza para eliminar un elemento del contenedor. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_data_remove</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto contenedor que se va a operar. El objeto en <code class="docutils literal notranslate"><span class="pre">index</span></code> debe ser un valor de lista o un valor de mapa. Para el contenedor de mapas, la llave para eliminar el elemento se almacena en la parte superior de la pila virtual (debe empujarse antes de llamar a la función); para el contenedor de lista, el índice del elemento que se va a eliminar se almacena en la parte superior de la pila virtual (debe estar antes de la llamada a la función). Si la operación es exitosa, la función devolverá <code class="docutils literal notranslate"><span class="pre">btrue</span></code>, de lo contrario devolverá <code class="docutils literal notranslate"><span class="pre">bfalse</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_data_resize</span></code> se utiliza para restablecer la capacidad del contenedor. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_data_resize</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto contenedor que se va a operar. Esta función solo está disponible para contenedores de lista y la nueva capacidad se almacena en la parte superior de la pila virtual (debe ser un número entero).</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_iter_next</span></code> se utiliza para obtener el siguiente elemento del iterador. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_iter_next</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del iterador a operar. El objeto iterador puede ser un iterador de un contenedor List o un contenedor Map. Para el iterador List, esta función empuja el valor del resultado de la iteración a la parte superior de la pila, mientras que para el iterador Map, empuja el valor clave a la posición anterior y la parte superior de la pila, respectivamente. Llamar a esta función actualizará el iterador. Si la función devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>, la llamada falla, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code> para indicar que el iterador actual es un iterador de lista y devuelve <code class="docutils literal notranslate"><span class="pre">2</span></code> para indicar que el iterador actual es un iterador de mapa.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">map_hasnext</span></code> se usa para probar si hay otro elemento en el iterador. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">map_hasnext</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del iterador a operar. El objeto iterador puede ser un iterador de un contenedor List o un contenedor Map. Si hay más elementos iterables en el iterador, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_refcontains</span></code> se usa para probar si hay una referencia al objeto especificado en la pila de referencia. Debe usarse junto con <code class="docutils literal notranslate"><span class="pre">be_refpush</span></code> y <code class="docutils literal notranslate"><span class="pre">be_refpop</span></code>. Esta API puede evitar la recursividad al atravesar objetos que tienen sus propias referencias. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_refcontains</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto a operar. Esta función se utiliza para el valor de un tipo de instancia. Si hay una referencia al objeto en la pila de referencia, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_refpush</span></code> inserta la referencia del objeto especificado en la pila de referencia. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_refpush</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del objeto a operar. Esta función se utiliza para el valor de un tipo de instancia.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_refpop</span></code> extrae el objeto en la parte superior de la pila de referencia. Esta función eliminará un valor de la pila.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_refpop</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual. Esta función se usa en pares con <code class="docutils literal notranslate"><span class="pre">be_refpush</span></code>. El siguiente es el uso de la API de la pila de referencia para evitar el problema del recorrido recursivo infinito cuando se hace referencia al objeto mismo:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">list_traversal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">be_refcontains</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">be_return</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">be_refpush</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Atravesando el contenedor, puede llamar a list_traversal recursivamente.</span>
<span class="w">    </span><span class="n">be_refpop</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">be_return</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Este es un proceso transversal simplificado del contenedor List. Para obtener el código completo, consulte el código fuente de la función <code class="docutils literal notranslate"><span class="pre">m_tostring</span></code> en <em>be_listlib.c</em>. Asumimos que el índice del objeto List es <code class="docutils literal notranslate"><span class="pre">1</span></code>. Primero, verificamos si la Lista ya existe en la pila de referencia (línea 4), y si la referencia ya existe, regresa directamente, de lo contrario, continúa con el procesamiento posterior. Para hacer utilizable <code class="docutils literal notranslate"><span class="pre">be_refcontains</span></code>, necesitamos usar <code class="docutils literal notranslate"><span class="pre">be_refpush</span></code> y <code class="docutils literal notranslate"><span class="pre">be_refpop</span></code> para procesar la pila de referencia antes y después de la operación transversal real (líneas 7 y 9).</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_stack_require</span></code> prueba la cantidad de espacio libre en la pila y expande el espacio de la pila si es insuficiente. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_stack_require</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">count</span></code> es la capacidad de pila libre requerida. Si la capacidad libre de la pila virtual asignada por la VM a la función nativa es inferior a este valor, se realizará una operación de expansión.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isnil</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es <code class="docutils literal notranslate"><span class="pre">nil</span></code>, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isnil</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isbool</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es de tipo <code class="docutils literal notranslate"><span class="pre">bool</span></code>, si lo es, la función devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isbool</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isint</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es de tipo entero, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isint</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isreal</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es un tipo de número real, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isreal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isnumber</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es un número entero o un tipo de número real, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isnumber</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isstring</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es un tipo de cadena, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isstring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isclosure</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es un tipo de cierre, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isclosure</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isntvclos</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es un tipo de cierre primitivo, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isntvclos</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isfunction</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es un tipo de función, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isfunction</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir. Hay tres tipos de funciones: cierre, función nativa y cierre nativo.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isproto</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es de tipo <code class="docutils literal notranslate"><span class="pre">proto</span></code>, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isproto</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir. El tipo <code class="docutils literal notranslate"><span class="pre">proto</span></code> es el prototipo de función del cierre de Berry.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isclass</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es de tipo <code class="docutils literal notranslate"><span class="pre">class</span></code>, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isclass</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isinstance</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es de tipo <code class="docutils literal notranslate"><span class="pre">instance</span></code>, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isinstance</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_isbytes</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es una instancia o subinstancia de la clase <code class="docutils literal notranslate"><span class="pre">bytes</span></code>; si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>; de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_isbytes</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_islist</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es de tipo <code class="docutils literal notranslate"><span class="pre">list</span></code>, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_islist</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_ismap</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es de tipo <code class="docutils literal notranslate"><span class="pre">map</span></code>, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_ismap</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_iscomptr</span></code> devuelve si el valor indexado por el parámetro <code class="docutils literal notranslate"><span class="pre">index</span></code> en la pila virtual es un tipo de puntero universal, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">1</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">0</span></code>. El prototipo de esta función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">be_iscomptr</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual, e <code class="docutils literal notranslate"><span class="pre">index</span></code> es el índice del valor a medir.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bint</span><span class="w"> </span><span class="nf">be_toint</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Obtiene el valor de la posición de índice de <code class="docutils literal notranslate"><span class="pre">index</span></code> de la pila virtual y devuelve como un tipo entero. Esta función no comprueba la corrección del tipo. Si el valor es una instancia, se llama al método <code class="docutils literal notranslate"><span class="pre">toint()</span></code> si existe.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">breal</span><span class="w"> </span><span class="nf">be_toreal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Obtiene el valor de la posición de índice de <code class="docutils literal notranslate"><span class="pre">index</span></code> de la pila virtual y devuelve como un tipo de número de punto flotante. Esta función no comprueba la exactitud del tipo.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bint</span><span class="w"> </span><span class="nf">be_toindex</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Obtiene el valor de la posición de índice de <code class="docutils literal notranslate"><span class="pre">index</span></code> de la pila virtual y devuelve como un tipo entero. Esta función no comprueba la corrección del tipo. A diferencia de <code class="docutils literal notranslate"><span class="pre">be_toint</span></code>, el tipo de valor de retorno de <code class="docutils literal notranslate"><span class="pre">be_toindex</span></code> es <code class="docutils literal notranslate"><span class="pre">int</span></code>, mientras que el valor de retorno del primero es <code class="docutils literal notranslate"><span class="pre">bint</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bbool</span><span class="w"> </span><span class="nf">be_tobool</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Obtiene el valor de la posición de índice de <code class="docutils literal notranslate"><span class="pre">index</span></code> de la pila virtual y devuelve como un tipo booleano. Si el valor indexado no es de tipo booleano, se convertirá de acuerdo con las reglas de la sección type_bool, y el proceso de conversión no hará que cambie el valor indexado. Si el valor es una instancia, se llama al método <code class="docutils literal notranslate"><span class="pre">tobool()</span></code> si existe.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tostring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Obtiene el valor de la posición de índice de <code class="docutils literal notranslate"><span class="pre">index</span></code> de la pila virtual y devuelve como un tipo de cadena. Si el valor indexado no es un tipo de cadena, el valor indexado se convertirá en una cadena y el proceso de conversión reemplazará el valor en la posición indexada en la pila virtual con la cadena convertida. La cadena devuelta por esta función siempre termina con los caracteres <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>. Si el valor es una instancia, se llama al método <code class="docutils literal notranslate"><span class="pre">tostring()</span></code> si existe.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tocomptr</span><span class="p">(</span><span class="n">bvm</span><span class="o">*</span><span class="w"> </span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Obtiene el valor de la posición de índice de <code class="docutils literal notranslate"><span class="pre">index</span></code> de la pila virtual y devuelve como un tipo de puntero general. Esta función no comprueba la exactitud del tipo.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">be_tobytes</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">len</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Obtiene el valor de la posición de índice de <code class="docutils literal notranslate"><span class="pre">index</span></code> de la pila virtual y devuelve como un búfer de bytes. Se devuelve el puntero del búfer y el tamaño se almacena en <code class="docutils literal notranslate"><span class="pre">*len</span></code> (a menos que <code class="docutils literal notranslate"><span class="pre">len</span></code> sea NULL). Esta función funciona solo para instancias de la clase <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, o devuelve <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushnil</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Inserta un valor <code class="docutils literal notranslate"><span class="pre">nil</span></code> en la pila virtual.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushbool</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Inserta un valor booleano en la pila virtual. El parámetro <code class="docutils literal notranslate"><span class="pre">b</span></code> es el valor booleano que se insertará en la pila. Cuando el valor es <code class="docutils literal notranslate"><span class="pre">0</span></code>, significa falso, de lo contrario es verdadero.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushint</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">bint</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Inserta un valor entero <code class="docutils literal notranslate"><span class="pre">i</span></code> en la pila virtual.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushreal</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">breal</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Inserta un valor de punto flotante <code class="docutils literal notranslate"><span class="pre">r</span></code> en la pila virtual.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">be_pushstring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Empuja la cadena <code class="docutils literal notranslate"><span class="pre">str</span></code> en la pila virtual. El parámetro <code class="docutils literal notranslate"><span class="pre">str</span></code> debe apuntar a una cadena C que termina con un carácter nulo <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>, y no se puede pasar un puntero nulo.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushnstring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Inserta la cadena <code class="docutils literal notranslate"><span class="pre">str</span></code> de longitud <code class="docutils literal notranslate"><span class="pre">n</span></code> en la pila virtual. La longitud de la cadena está sujeta al parámetro <code class="docutils literal notranslate"><span class="pre">n</span></code> y el carácter nulo no se usa como marca final de la cadena.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">be_pushfstring</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">formato</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
</pre></div>
</div>
<p>Empuja la cadena formateada en la pila virtual. El parámetro <code class="docutils literal notranslate"><span class="pre">formato</span></code> es una cadena formateada que contiene el texto que se insertará en la pila, y el parámetro <code class="docutils literal notranslate"><span class="pre">formato</span></code> contiene una etiqueta, que puede ser reemplazada por el valor especificado por el parámetro adicional subsiguiente y formateada según sea necesario. De acuerdo con la etiqueta de la cadena <code class="docutils literal notranslate"><span class="pre">formato</span></code>, se pueden requerir una serie de parámetros adicionales, y cada parámetro adicional reemplazará la etiqueta <code class="docutils literal notranslate"><span class="pre">%</span></code> correspondiente en el parámetro <code class="docutils literal notranslate"><span class="pre">formato</span></code>.</p>
<div id="tab::format_specifier">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><strong><span class="sans-serif">especificador</span></strong></p></th>
<th class="text-left head"><p><strong>Descripción</strong></p></th>
<th class="text-left head"><p></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">d</span></code></p></td>
<td class="text-left"><p>Formato como entero con signo decimal (los números positivos no generan signo)</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">f</span></code></p></td>
<td class="text-left"><p>Número de punto flotante de precisión simple o doble con formato decimal</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">g</span></code></p></td>
<td class="text-left"><p>Número de punto flotante de precisión simple o doble con formato exponencial</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">s</span></code></p></td>
<td class="text-left"><p>Formatear como cadena</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
<td class="text-left"><p>Formatear como un solo carácter</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">p</span></code></p></td>
<td class="text-left"><p>Formatear como dirección de puntero</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td class="text-left"><p>Escapado como carácter <code class="docutils literal notranslate"><span class="pre">%</span></code> (sin parámetro)</p></td>
<td class="text-left"><p></p></td>
</tr>
</tbody>
</table>
<p><em>Tabla 12: Descripción del parámetro de la etiqueta <code class="docutils literal notranslate"><span class="pre">formato</span></code></em></p>
</div>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_pushfstring</span></code> es similar a la función estándar de C <code class="docutils literal notranslate"><span class="pre">printf</span></code>, pero la función de formato de cadenas es relativamente básica y no admite operaciones como personalizar el ancho y los lugares decimales. Un ejemplo típico es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">be_pushfstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s: %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hola&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span><span class="w"> </span><span class="c1">// ¡Bien, funciona!</span>
<span class="n">be_pushfstring</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s: %.5d&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hola&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span><span class="w"> </span><span class="c1">// Error, el ancho especificado no es compatible.</span>
</pre></div>
</div>
<p>Esto significa que <code class="docutils literal notranslate"><span class="pre">be_pushfstring</span></code> solo puede realizar operaciones de formateo simples. Si no se pueden cumplir los requisitos, se recomienda utilizar cadenas con formato <code class="docutils literal notranslate"><span class="pre">sprintf</span></code> para las operaciones.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushvalue</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Empuja el valor con el índice <code class="docutils literal notranslate"><span class="pre">index</span></code> en la parte superior de la pila virtual.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushntvclosure</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">bntvfunc</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nupvals</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Empuja un cierre nativo en la parte superior de la pila virtual. El parámetro <code class="docutils literal notranslate"><span class="pre">f</span></code> es el puntero de función C del cierre nativo, y <code class="docutils literal notranslate"><span class="pre">nupvals</span></code> es el número de valor superior del cierre.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushntvfunction</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="n">bntvfunc</span><span class="w"> </span><span class="n">f</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Empuja una función nativa en la parte superior de la pila virtual y el parámetro <code class="docutils literal notranslate"><span class="pre">f</span></code> es el puntero de la función nativa.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushclass</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">bnfuncinfo</span><span class="w"> </span><span class="o">*</span><span class="n">lib</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Empuja una clase nativa en la parte superior de la pila virtual. El parámetro <code class="docutils literal notranslate"><span class="pre">name</span></code> es el nombre de la clase nativa y el parámetro <code class="docutils literal notranslate"><span class="pre">lib</span></code> es la descripción del atributo de la clase nativa.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pushcomptr</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Empuja un puntero general en la parte superior de la pila virtual. El puntero general <code class="docutils literal notranslate"><span class="pre">ptr</span></code> apunta a una determinada área de datos de C. Dado que el recolector de elementos no utilizados de Berry no mantiene el contenido señalado por este puntero, los usuarios deben mantener el ciclo de vida de los datos ellos mismos.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">be_pushbytes</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Empuja un búfer <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">()</span></code> que comience en la posición <code class="docutils literal notranslate"><span class="pre">buf</span></code> y de tamaño <code class="docutils literal notranslate"><span class="pre">len</span></code>.
El búfer se copia en la memoria asignada de Berry, no necesita mantener el búfer válido después de esta llamada.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bbool</span><span class="w"> </span><span class="nf">be_pushiter</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Empuja un iterador en la parte superior de la pila virtual.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">be_pusherror</span></code> inserta un mensaje de error en la parte superior de la pila. Después de ejecutar el FFI, el intérprete volverá directamente a la posición que puede manejar el error, y el código inmediatamente siguiente no se ejecutará. El prototipo de función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">be_pusherror</span><span class="p">(</span><span class="n">bvm</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">vm</span></code> es el puntero de la instancia de la máquina virtual; <code class="docutils literal notranslate"><span class="pre">msg</span></code> es la cadena que contiene la información del error.</p>
<p>Mueve el valor en el índice <code class="docutils literal notranslate"><span class="pre">desde</span></code> a la posición del índice <code class="docutils literal notranslate"><span class="pre">hasta</span></code>. Esta función no elimina el valor de la posición del índice <code class="docutils literal notranslate"><span class="pre">desde</span></code>, solo modifica el valor de la posición del índice <code class="docutils literal notranslate"><span class="pre">hasta</span></code>.</p>
</section>
</section>
<section id="tecnologia-de-construccion-en-tiempo-de-compilacion">
<h2>Tecnología de construcción en tiempo de compilación<a class="headerlink" href="#tecnologia-de-construccion-en-tiempo-de-compilacion" title="Permalink to this headline">¶</a></h2>
<p>La tecnología de construcción en tiempo de compilación se implementa principalmente mediante <em>coc</em>, que se encuentra en la ruta <em>coc/coc</em> del directorio del código fuente del intérprete. La herramienta <em>coc</em> se usa para generar cadenas constantes y objetos constantes como código C, y se compilará en constantes cuando se compile el intérprete. En principio, la herramienta <em>coc</em> generará código a partir de la información de declaración del objeto constante (de acuerdo con un formato específico). El proceso calculará automáticamente el valor Hash y generará la tabla Hash.</p>
<p>El archivo <em>Makefile</em> en el directorio raíz del proyecto del intérprete compilará automáticamente esta herramienta y la ejecutará antes de compilar el código fuente del intérprete. El contenido de <em>Makefile</em> asegura que cuando se usa el comando <code class="docutils literal notranslate"><span class="pre">make</span></code>, el código para construir el objeto en tiempo de compilación siempre se actualizará a través de la herramienta (si necesita actualizarse). El código para construir objetos en tiempo de compilación se puede generar manualmente a través del comando <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">prebuild</span></code>, que se almacena en la carpeta <em>generate</em>.</p>
<p>La construcción en tiempo de compilación se puede activar o desactivar modificando la macro <code class="docutils literal notranslate"><span class="pre">BE_USE_PRECOMPILED_OBJECT</span></code>. En cualquier caso, se llama a la herramienta <em>coc</em> para generar códigos de objetos constantes (los códigos no se usan cuando la construcción en tiempo de compilación está desactivada).</p>
<section id="usar-el-comando-coc">
<h3>Usar el comando <code class="docutils literal notranslate"><span class="pre">coc</span></code><a class="headerlink" href="#usar-el-comando-coc" title="Permalink to this headline">¶</a></h3>
<p>La herramienta <code class="docutils literal notranslate"><span class="pre">coc</span></code> se utiliza para generar código para objetos constantes. El formato del comando es</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>tools/coc/coc -o &lt;dst_path&gt; &lt;src_path<span class="o">(</span>s<span class="o">)</span>&gt; -c &lt;include_path&gt;
</pre></div>
</div>
<p>La ruta de salida <em>dst_path</em> se utiliza para almacenar el código generado, y la ruta de origen <em>src_path</em> es una lista de rutas que deben escanearse en busca del código fuente (utilice espacios para separar varias rutas).
<code class="docutils literal notranslate"><span class="pre">include_path</span></code> contiene un archivo de encabezado C escaneado para detectar directivas de compilación. <code class="docutils literal notranslate"><span class="pre">coc</span></code> intenta compilar solo las constantes necesarias.
Dado que <em>generate</em> se usa como la ruta del código generado en el código fuente del intérprete, <em>dst_path</em> debe ser <em>generate</em>. Tomando el proyecto de intérprete estándar como ejemplo, el comando para usar la herramienta en <code class="docutils literal notranslate"><span class="pre">map_build</span></code> debe ser</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>tools/coc/coc -o generate default src -c default/berry_conf.h
</pre></div>
</div>
<p>El significado de este comando es: la ruta de salida es <em>generate</em>, y la ruta de origen es <em>src</em> y <em>default</em>.</p>
</section>
<section id="ruta-de-salida">
<h3>Ruta de salida<a class="headerlink" href="#ruta-de-salida" title="Permalink to this headline">¶</a></h3>
<p>Estrictamente hablando, la carpeta <em>generate</em> utilizada como ruta de salida no se puede colocar en ningún lado, debe almacenarse en un directorio principal que contenga la ruta. La ruta de inclusión se refiere a la ruta donde se buscará el archivo de encabezado en el proyecto. Tomando el código fuente del intérprete estándar como ejemplo, la ruta de inclusión es <em>src</em> y <em>default</em>. Por lo tanto, en el proyecto de intérprete estándar, la carpeta <em>generate</em> se almacena en el directorio raíz del código fuente del intérprete (el directorio principal de <em>src</em> y <em>default</em>).</p>
<p>El motivo de las reglas anteriores es que los siguientes códigos se utilizan en el código fuente del intérprete para hacer referencia a objetos constantes:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;../generate/be_fixed_xxx.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>Si los lectores quieren definir objetos constantes por sí mismos, también necesitan usar dicho código para incluir los archivos de encabezado correspondientes. Esta sección presentará cómo usar estas herramientas para definir y usar objetos constantes.</p>
</section>
<section id="tabla-de-cadenas-en-tiempo-de-compilacion">
<h3>Tabla de cadenas en tiempo de compilación<a class="headerlink" href="#tabla-de-cadenas-en-tiempo-de-compilacion" title="Permalink to this headline">¶</a></h3>
<p>La tabla de cadenas en tiempo de compilación se utiliza para almacenar cadenas constantes.
Las cadenas constantes son objetos que son transparentes para el script. No se crean ni destruyen cuando el intérprete se está ejecutando, pero siempre se almacenan como constantes en el segmento de datos del programa del intérprete. Si necesita usar una cadena como cadena constante, puede agregar el prefijo <code class="docutils literal notranslate"><span class="pre">be_const_str_</span></code> delante de la cadena en el código fuente del intérprete, y la declaración se puede colocar en cualquier parte del archivo fuente (incluidos los comentarios). Por ejemplo, para crear una cadena constante con el contenido <code class="docutils literal notranslate"><span class="pre">&quot;cadena&quot;</span></code>, debe declarar el símbolo <code class="docutils literal notranslate"><span class="pre">be_const_str_cadena</span></code> en el archivo fuente, y este símbolo también es el nombre de la variable que hace referencia a la cadena constante en el código C.</p>
<p>Todas las palabras clave crearán cadenas constantes. Si modifica el código relacionado con la palabra clave en el intérprete de Berry, también se debe modificar el código correspondiente en <em>coc</em>.</p>
<p>Si la cadena contiene símbolos especiales, se “escapean” automáticamente como <code class="docutils literal notranslate"><span class="pre">_XHH</span></code>, donde <code class="docutils literal notranslate"><span class="pre">HH</span></code> es la representación hexadecimal (en mayúsculas) del carácter.
Por ejemplo <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> está representado por <code class="docutils literal notranslate"><span class="pre">_X3A</span></code>. Esta representación es biactiva, por lo que es fácil convertirla a la cadena original y desde ella.</p>
<section id="usar-cadena-constante">
<h4>Usar cadena constante<a class="headerlink" href="#usar-cadena-constante" title="Permalink to this headline">¶</a></h4>
<p>Normalmente, no hay necesidad de declarar cadenas constantes manualmente, ni de usarlas manualmente. Si realmente necesita llamar a la cadena constante manualmente, incluya el archivo de encabezado <em>be_constobj.h</em> para usar todas las variables de cadena constante (este archivo de encabezado tiene declaraciones para todas las cadenas constantes). El uso típico de cadenas constantes es construir objetos en tiempo de compilación. La declaración y definición de cadenas constantes en este proceso son manejadas automáticamente por la herramienta.</p>
<p>En cualquier caso, la función FFI <code class="docutils literal notranslate"><span class="pre">be_pushstring</span></code> debe usarse directamente para crear una cadena. Cuando una cadena tiene una cadena constante, no creará repetidamente un nuevo objeto de cadena, sino que usará directamente la cadena constante correspondiente.</p>
<p>De forma predeterminada, todas las cadenas utilizadas se referencian en una tabla hash global <code class="docutils literal notranslate"><span class="pre">m_const_string_table</span></code>. Sin embargo, algunos proyectos pueden tener muchas variantes de compilación para las que no se necesitan algunos conjuntos de cadenas.
Si todas las constantes de cadena se almacenan en todas las variantes, esto crea una pérdida de tamaño de flash. Por esta razón, algunas cadenas pueden declararse como cadenas “débiles” en el sentido de tener una referencia “débil”. En tal caso, la constante de cadena se declara en código C, pero no se incluye en el objeto de mapa global. Esto significa que el enlazador puede optar por no incluir las constantes de cadena si ningún código hace referencia a ellas. La desventaja es que si crea dinámicamente un objeto de cadena con el mismo valor, se crea un nuevo objeto en la memoria (mientras que no lo haría para una constante de cadena normal).
Para indicar cadenas débiles, use el modificador <code class="docutils literal notranslate"><span class="pre">strings:</span> <span class="pre">weak</span></code> (ver más abajo).</p>
</section>
</section>
<section id="construir-objeto-en-tiempo-de-compilacion">
<h3>Construir objeto en tiempo de compilación<a class="headerlink" href="#construir-objeto-en-tiempo-de-compilacion" title="Permalink to this headline">¶</a></h3>
<p>Los objetos construidos en tiempo de compilación también se denominan objetos constantes.
La estructura de datos de estos objetos se construye cuando se compila el intérprete y no se puede modificar en tiempo de ejecución. <code class="docutils literal notranslate"><span class="pre">map_build</span></code> define un conjunto de reglas de declaración en la herramienta para generar código C para objetos constantes. La información de declaración del objeto constante se almacena directamente en el archivo fuente (<em>*.c</em>). Para distinguirlo de otro contenido, se debe incluir una información de declaración completa en el siguiente código de arranque:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@const_object_info_begin</span>
<span class="nd">@const_object_info_end</span>
</pre></div>
</div>
<p>La información de declaración de objeto constante no se ajusta a la sintaxis del lenguaje C, por lo que debe colocarse en un comentario de varias líneas (incluido con <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code>). Todos los objetos constantes tienen la misma forma de declaración. La estructura de declaración de un objeto constante se denomina “bloque de declaración de objeto”, que se compone de</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">object_name</span> <span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">member_fields</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> es el tipo de objeto constante, puede ser <code class="docutils literal notranslate"><span class="pre">map</span></code>, <code class="docutils literal notranslate"><span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">module</span></code> o <code class="docutils literal notranslate"><span class="pre">vartab</span></code>. <code class="docutils literal notranslate"><span class="pre">object_name</span></code> es el nombre de la variable del objeto constante en lenguaje C. <code class="docutils literal notranslate"><span class="pre">attributes</span></code> es la lista de atributos de los objetos constantes. Un atributo se compone de nombre de atributo y valor de atributo.
El nombre del atributo y el valor del atributo están separados por punto y coma, y varios atributos están separados por comas. Por ejemplo, la lista de atributos <code class="docutils literal notranslate"><span class="pre">scope:</span> <span class="pre">global,</span> <span class="pre">name:</span> <span class="pre">map</span></code> significa que el atributo <code class="docutils literal notranslate"><span class="pre">scope</span></code> de un objeto constante es <code class="docutils literal notranslate"><span class="pre">global</span></code>, y el atributo <code class="docutils literal notranslate"><span class="pre">name</span></code> es <code class="docutils literal notranslate"><span class="pre">map</span></code>.
También <code class="docutils literal notranslate"><span class="pre">strings:</span> <span class="pre">weak</span></code> indica que se debe generar constantes de cadena débiles para los nombres de los campos de miembros o cualquier constante de cadena.
<code class="docutils literal notranslate"><span class="pre">member_fields</span></code> es la lista de dominios miembros de objetos constantes. Un miembro se compone de nombre y valor, separados por comas. Cada línea puede declarar un miembro y varios miembros deben declararse en varias líneas.</p>
<p>La herramienta <strong>coc</strong> utiliza expresiones regulares para analizar el bloque de declaración de objetos. En el proceso de análisis, primero se comparará todo el bloque de declaración del objeto y se comparará la información “tipo” y “nombre_del_objeto”. Para la información de <code class="docutils literal notranslate"><span class="pre">atributos</span></code> y <code class="docutils literal notranslate"><span class="pre">member_fields</span></code>, sae hará un análisis adicional. Para facilitar la implementación, la herramienta no tiene requisitos estrictos sobre la sintaxis del bloque de declaración de objetos y carece de un mecanismo completo de manejo de errores, por lo que debe asegurarse de que la sintaxis sea correcta al escribir el bloque de declaración de objetos.</p>
<p>Para facilitar la comprensión, ilustramos con una clase constante simple:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* @const_object_info_begin</span>
<span class="cm">class be_class_map (scope: global, name: map) {</span>
<span class="cm">    .data, var</span>
<span class="cm">    init, func(m_init)</span>
<span class="cm">    tostring, func(m_tostring)</span>
<span class="cm">}</span>
<span class="cm">@const_object_info_end */</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;../generate/be_fixed_be_class_map.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>En este ejemplo, la información de declaración de toda la clase constante está en el comentario del lenguaje C, por lo que no afectará la compilación del código C. El bloque de declaración de objetos se coloca entre <code class="docutils literal notranslate"><span class="pre">&#64;const_object_info_begin</span></code> y <code class="docutils literal notranslate"><span class="pre">&#64;const_object_info_end</span></code> para garantizar que la herramienta <strong>coc</strong> detecte el bloque de declaración de objetos.</p>
<p>Dado que es una declaración de clase constante, el valor de <em>tipo</em> en el bloque de declaración de objeto es <code class="docutils literal notranslate"><span class="pre">class</span></code>, y <code class="docutils literal notranslate"><span class="pre">be_class_map</span></code> es el nombre de variable del objeto constante en el código C. Se declaran dos atributos en la lista de atributos del objeto (la parte encerrada entre paréntesis), y el significado de estos atributos se presentará en la sección “Clase de construcción en tiempo de compilación” de esta sección. Tres miembros están definidos en la lista de miembros entre llaves, varios miembros están separados por saltos de línea y el nombre del miembro y el valor del miembro están separados por una coma. Existen varios formatos legales para los nombres de miembros:</p>
<ul class="simple">
<li><p>Formato de nombre de variable Berry: comienza con una letra o guión bajo,
seguido de varias letras, guiones bajos o números.</p></li>
<li><p>Utilice “<code class="docutils literal notranslate"><span class="pre">.</span></code>” como primer carácter, seguido de letras, guiones bajos
o números.</p></li>
<li><p>Operadores sobrecargables, como “<code class="docutils literal notranslate"><span class="pre">+</span></code>”, “<code class="docutils literal notranslate"><span class="pre">-</span></code>” y “<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>”, etc.</p></li>
</ul>
<p>El valor de un miembro puede ser de los siguientes tipos:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">var</span></code>: Este símbolo se compilará en un objeto entero
(<code class="docutils literal notranslate"><span class="pre">be_const_var</span></code>), y el valor del objeto entero se
incrementa automáticamente desde <code class="docutils literal notranslate"><span class="pre">0</span></code>. <code class="docutils literal notranslate"><span class="pre">var</span></code> está diseñado para la
declaración de variables miembro en la clase, y es automática
La función de numeración se utiliza para realizar el número de serie de las variables miembro.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">func(símbolo)</span></code>: Declara funciones miembro nativas o métodos de
objetos constantes. El símbolo se compilará en una función nativa con el valor (<code class="docutils literal notranslate"><span class="pre">be_const_func</span></code>), <code class="docutils literal notranslate"><span class="pre">symbol</span></code> es el puntero de función nativo
correspondiente al miembro. <code class="docutils literal notranslate"><span class="pre">m_init</span></code> y <code class="docutils literal notranslate"><span class="pre">m_tostring</span></code> en el
ejemplo son dos funciones nativas.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">closure</span> <span class="pre">(símbolo)</span></code>: Declara funciones o métodos miembro de bytecode precompilados
de objetos constantes. El símbolo se compilará en una función nativa con el valor (<code class="docutils literal notranslate"><span class="pre">be_const_closure</span></code>),
<code class="docutils literal notranslate"><span class="pre">símbolo</span></code> es el nombre de la función solidificada.
Ver <code class="docutils literal notranslate"><span class="pre">módulo</span> <span class="pre">solidificar</span></code> para saber cómo solidificar objetos.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nil()</span></code>: este símbolo se compilará en un valor nulo
(<code class="docutils literal notranslate"><span class="pre">be_const_nil</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int(valor)</span></code>: este símbolo se compilará en un objeto entero
(<code class="docutils literal notranslate"><span class="pre">be_const_int</span></code>), el valor del objeto entero es <code class="docutils literal notranslate"><span class="pre">valor</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">real(valor)</span></code>: Este símbolo se compilará en un número real
(<code class="docutils literal notranslate"><span class="pre">be_const_real</span></code>), el valor del objeto de número real es
<code class="docutils literal notranslate"><span class="pre">valor</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">comptr(valor)</span></code>: Este símbolo se compilará en un puntero
objeto (<code class="docutils literal notranslate"><span class="pre">be_const_comptr</span></code>), el valor del puntero es
<code class="docutils literal notranslate"><span class="pre">valor</span></code> y se puede utilizar para pasar la dirección de una estructura global de C.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">(símbolo)</span></code>: este símbolo se compilará en un objeto de clase
(<code class="docutils literal notranslate"><span class="pre">be_const_class</span></code>). <code class="docutils literal notranslate"><span class="pre">símbolo</span></code> es un puntero a este tipo de objeto,
y el puntero debe apuntar a un objeto de tipo constante.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">(símbolo)</span></code>: este símbolo se compilará en un objeto de módulo
(<code class="docutils literal notranslate"><span class="pre">be_const_module</span></code>). <code class="docutils literal notranslate"><span class="pre">símbolo</span></code> es un puntero al objeto del módulo, y
el puntero debe apuntar a un objeto de módulo constante.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ctype_func(símbolo)</span></code>: Este símbolo se compilará en una función nativa
(<code class="docutils literal notranslate"><span class="pre">be_const_ctype_func</span></code>). <code class="docutils literal notranslate"><span class="pre">símbolo</span></code> es un puntero al mapeo C
definición. Esta característica es utilizada por
<a class="reference external" href="https://github.com/berry-lang/berry_mapping">berry_mapping</a></p></li>
</ul>
<p>Para usar el objeto <code class="docutils literal notranslate"><span class="pre">be_class_map</span></code>, debemos incluir el archivo de encabezado correspondiente en el código C para garantizar que el objeto se compilará. La práctica habitual es incluir el archivo de cabecera correspondiente cerca del bloque de declaración del objeto. En el ejemplo, la línea 8 lo contiene. El archivo de encabezado correspondiente se puede usar para construir objetos <code class="docutils literal notranslate"><span class="pre">be_class_map</span></code> en tiempo de compilación.</p>
<p>Después de procesarlo con la herramienta <strong>coc</strong>, cada bloque de declaración de objeto se compilará en un archivo de encabezado llamado <em>be_fixed_be_xxx.h</em>, donde <em>xxx</em> es el nombre de la variable C del objeto. Para compilar objetos constantes en código C, debemos incluir los archivos de encabezado correspondientes. Por lo general, se recomienda incluir los archivos de encabezado correspondientes cerca del bloque de declaración de objetos. La octava línea del ejemplo contiene <em>be_fixed_be_class_map.h</em> para construir el objeto <code class="docutils literal notranslate"><span class="pre">be_class_map</span></code> en tiempo de compilación.</p>
<section id="construir-mapa-en-tiempo-de-compilacion">
<h4>Construir mapa en tiempo de compilación<a class="headerlink" href="#construir-mapa-en-tiempo-de-compilacion" title="Permalink to this headline">¶</a></h4>
<p>Los mapas construidos en tiempo de compilación también son objetos <code class="docutils literal notranslate"><span class="pre">map</span></code> constantes. Por lo general, no se declaran directamente mediante bloques de declaración de objetos, sino que se declaran en otras estructuras de construcción en tiempo de compilación. Al construir el <code class="docutils literal notranslate"><span class="pre">map</span></code> constante, la información del tipo de objeto constante debe ser <code class="docutils literal notranslate"><span class="pre">map</span></code>, que admite un atributo <code class="docutils literal notranslate"><span class="pre">scope</span></code>. Cuando el valor del atributo ‘scope’ es ‘local’, el objeto constante es ‘estático’, cuando el atributo es ‘global’, es ‘externo’, y el valor de este atributo es ‘local’ por defecto. Los <code class="docutils literal notranslate"><span class="pre">member_fields</span></code> del objeto <code class="docutils literal notranslate"><span class="pre">map</span></code> constante admiten especificaciones comunes de nombre de miembro/valo, y los valores de miembro solo se almacenan como datos sin una interpretación especial. El siguiente es un ejemplo del uso del bloque de declaración de objetos para declarar directamente un objeto <code class="docutils literal notranslate"><span class="pre">map</span></code> constante:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>map map_name (scope: local/global) {
    init, func(m_init)
}
</pre></div>
</div>
</section>
<section id="construccion-de-clases-en-tiempo-de-compilacion">
<h4>Construcción de Clases en tiempo de compilación<a class="headerlink" href="#construccion-de-clases-en-tiempo-de-compilacion" title="Permalink to this headline">¶</a></h4>
<p>Para construir una clase en tiempo de compilación, use el bloque de declaración de objetos para declarar, y la información de tipo del objeto es <code class="docutils literal notranslate"><span class="pre">class</span></code>. Las propiedades declaradas de este objeto son <code class="docutils literal notranslate"><span class="pre">scope</span></code> y <code class="docutils literal notranslate"><span class="pre">name</span></code>. <code class="docutils literal notranslate"><span class="pre">scope</span></code> es el alcance de la variable C del objeto de declaración de atributos, cuando el valor es <code class="docutils literal notranslate"><span class="pre">local</span></code> (predeterminado), el alcance es <code class="docutils literal notranslate"><span class="pre">static</span></code>, cuando es <code class="docutils literal notranslate"><span class="pre">global</span></code>, el alcance es <code class="docutils literal notranslate"><span class="pre">extern</span></code>; <code class="docutils literal notranslate"><span class="pre">name</span></code> es el valor del atributo es ese nombre de clase, la clase anónima puede omitir este parámetro. Dado que la lista de atributos de una clase solo almacena métodos e índices de variables miembro, los <code class="docutils literal notranslate"><span class="pre">member_fields</span></code> de la clase construida en tiempo de compilación solo pueden usar los valores <code class="docutils literal notranslate"><span class="pre">var</span></code> y <code class="docutils literal notranslate"><span class="pre">func()</span></code>. Un bloque de declaración de clase de construcción simple en tiempo de compilación es:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class be_class_map (scope: global, name: map) {
    .data, var
    init, func(m_init)
    tostring, func(m_tostring)
}
</pre></div>
</div>
</section>
<section id="construccion-de-modulos-en-tiempo-de-compilacion">
<h4>Construcción de Módulos en tiempo de compilación<a class="headerlink" href="#construccion-de-modulos-en-tiempo-de-compilacion" title="Permalink to this headline">¶</a></h4>
<p>La información de tipo del bloque de declaración del bloque de construcción en tiempo de compilación es <code class="docutils literal notranslate"><span class="pre">module</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">module</span><span class="w"> </span><span class="nf">math</span><span class="w"> </span><span class="p">(</span><span class="n">scope</span><span class="o">:</span><span class="w"> </span><span class="n">global</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">m_sin</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">m_cos</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="n">real</span><span class="p">(</span><span class="n">M_PI</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="construccion-de-un-dominio-integrado-en-tiempo-de-compilacion">
<h4>Construcción de un dominio integrado en tiempo de compilación<a class="headerlink" href="#construccion-de-un-dominio-integrado-en-tiempo-de-compilacion" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">vartab</span><span class="w"> </span><span class="nf">m_builtin</span><span class="w"> </span><span class="p">(</span><span class="n">scope</span><span class="o">:</span><span class="w"> </span><span class="n">local</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">l_assert</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">print</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">l_print</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">class</span><span class="p">(</span><span class="n">be_class_list</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Guan Wenliang &amp; Stephan Hadinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
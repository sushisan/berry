<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Definición de gramática &mdash; berry 1.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> berry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../en/Home.html">Welcome to the berry wiki!</a></li>
<li class="toctree-l1"><a class="reference internal" href="Home.html">Bienvenido a la wiki de Berry!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">berry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Definición de gramática</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/es/Apendice-A.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <!-- Spanish Translation: Emiliano Gonzalez (egonzalez . hiperion @ gmail . com) -->
<section id="definicion-de-gramatica">
<h1>Definición de gramática<a class="headerlink" href="#definicion-de-gramatica" title="Permalink to this headline"></a></h1>
<p>Este capítulo dará algunas definiciones gramaticales relacionadas con Berry. Usamos <strong>Extended Backus Normal Form</strong> (EBNF) para definir o expresar la gramática. No usamos la gramática EBNF estricta para definir, pero hicimos muchas simplificaciones, pero estas simplificaciones no afectarán la comprensión de la gramática por parte de los lectores.</p>
<p>La definición EBNF de la gramática del lenguaje Berry es la siguiente:</p>
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>(* program define *)
program = block;
(* block define *)
block = {statement};
(* statement define *)
statement = class_stmt | func_stmt | var_stmt | if_stmt | while_stmt |
         for_stmt | break_stmt | return_stmt | expr_stmt | import_stmt |
         try_stmt | throw_stmt | &#39;;&#39;;
if_stmt = &#39;if&#39; expr block {&#39;elif&#39; expr block} [&#39;else&#39; block] &#39;end&#39;;
while_stmt = &#39;while&#39; expr block &#39;end&#39;;
for_stmt = &#39;for&#39; ID &#39;:&#39; expr block &#39;end&#39;;
break_stmt = &#39;break&#39; | &#39;continue&#39;;
return_stmt = &#39;return&#39; [expr];
(* function define statement *)
func_stmt = &#39;def&#39; ID func_body;
func_body = &#39;(&#39; [arg_field {&#39;,&#39; arg_field}] &#39;)&#39; block &#39;end&#39;;
arg_field = [&#39;*&#39;] ID;
(* class define statement *)
class_stmt = &#39;class&#39; ID [&#39;:&#39; ID] class_block &#39;end&#39;;
class_block = {&#39;var&#39; ID {&#39;,&#39; ID} | &#39;static&#39; [&#39;var&#39;] ID [&#39;=&#39; expr] {&#39;,&#39; ID [&#39;=&#39; expr] } | &#39;static&#39; func_stmt | func_stmt};
import_stmt = &#39;import&#39; (ID ([&#39;as&#39; ID] | {&#39;,&#39; ID}) | STRING &#39;as&#39; ID);
(* exceptional handling statement *)
try_stmt = &#39;try&#39; block except_block {except_block} &#39;end&#39;;
except_block = except_stmt block;
except_stmt = &#39;except&#39; (expr {&#39;,&#39; expr} | &#39;..&#39;) [&#39;as&#39; ID [&#39;,&#39; ID]];
throw_stmt = &#39;raise&#39; expr [&#39;,&#39; expr];
(* variable define statement *)
var_stmt = &#39;var&#39; ID [&#39;=&#39; expr] {&#39;,&#39; ID [&#39;=&#39; expr]};
(* expression define *)
expr_stmt = expr [assign_op expr];
expr = suffix_expr | unop expr | expr binop expr | range_expr | cond_expr;
cond_expr = expr &#39;?&#39; expr &#39;:&#39; expr; (* conditional expression *)
assign_op = &#39;=&#39; | &#39;+=&#39; | &#39;-=&#39; | &#39;*=&#39; | &#39;/=&#39; |
            &#39;%=&#39; | &#39;&amp;=&#39; | &#39;|=&#39; | &#39;^=&#39; | &#39;&lt;&lt;=&#39; | &#39;&gt;&gt;=&#39;;
binop = &#39;&lt;&#39; | &#39;&lt;=&#39; | &#39;==&#39; | &#39;!=&#39; | &#39;&gt;&#39; | &#39;&gt;=&#39; | &#39;||&#39; | &#39;&amp;&amp;&#39; |
        &#39;&lt;&lt;&#39; | &#39;&gt;&gt;&#39; | &#39;&amp;&#39; | &#39;|&#39; | &#39;^&#39; | &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39; | &#39;%&#39;;
range_expr = expr &#39;..&#39; [expr]
unop = &#39;-&#39; | &#39;!&#39; | &#39;~&#39;;
suffix_expr = primary_expr {call_expr | (&#39;.&#39; ID) | &#39;[&#39; expr &#39;]&#39;};
primary_expr = &#39;(&#39; expr &#39;)&#39; | simple_expr | list_expr | map_expr | anon_func | lambda_expr;
simple_expr =  INTEGER | REAL | STRING | ID | &#39;true&#39; | &#39;false&#39; | &#39;nil&#39;;
call_expr = &#39;(&#39; [expr {&#39;,&#39; expr}] &#39;)&#39;;
list_expr = &#39;[&#39; {expr &#39;,&#39;} [expr] &#39;]&#39;;
map_expr = &#39;{&#39; {expr &#39;:&#39; expr &#39;,&#39;} [expr &#39;:&#39; expr] &#39;}&#39;;
anon_func = &#39;def&#39; func_body; (* anonymous function *)
lambda_expr = &#39;/&#39; [arg_field {&#39;,&#39; arg_field}] | {arg_field}] &#39;-&gt;&#39; expr;
</pre></div>
</div>
<p>El formato EBNF estándar se puede encontrar en materiales relacionados. Aquí hay una explicación de los detalles que necesitan atención al leer la gramática anterior. Los símbolos que han aparecido a la izquierda del signo igual son símbolos no terminales, y los demás son símbolos terminales. El terminador encerrado entre comillas <code class="docutils literal notranslate"><span class="pre">'</span></code> es una cadena fija, que suele ser una palabra clave u operador de idioma. Hay varios terminadores que son inconvenientes para describir directamente en EBNF: <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> representa el valor nominal del entero; <code class="docutils literal notranslate"><span class="pre">REAL</span></code> representa el valor nominal del número real; <code class="docutils literal notranslate"><span class="pre">STRING</span></code> representa el valor literal de cadena; <code class="docutils literal notranslate"><span class="pre">ID</span></code> representa el identificador. Estos terminadores se pueden definir mediante expresiones regulares:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ENTERO</span></code>: <code class="docutils literal notranslate"><span class="pre">0x[a-fA-F0-9]+|\d+</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">REAL</span></code>: <code class="docutils literal notranslate"><span class="pre">(\d+\.?|\.\d)\d*([eE][+-]?\d+)?</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CADENA</span></code>: <code class="docutils literal notranslate"><span class="pre">&quot;(\\.|[^&quot;])*&quot;|'(\\.|[^'])*'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ID</span></code>: <code class="docutils literal notranslate"><span class="pre">[_a-zA-Z]\w*</span></code></p></li>
</ul>
<p>Los símbolos que aparecen secuencialmente en el EBNF estándar están separados por comas. Por intuición, uso espacios para implementar la función de coma. El símbolo de barra vertical “|” se pronuncia como “o”, significa que los patrones izquierdo y derecho solo pueden coincidir con uno de ellos, o tiene la prioridad más baja. Por ejemplo, la gramática <em>a</em> <sub>0</sub> <em>a</em> <sub>1</sub> |<em>a</em> <sub>2</sub> significa la fórmula correspondiente <em>a</em> <sub>0</sub> <em>a</em> <sub>1</sub> o la combinación <em>a</em> <sub>2</sub> . Los corchetes indican que la subexpresión dentro de los paréntesis coincide 0 o 1 veces, las llaves indican que la subexpresión interna coincide 0 o más veces, y los paréntesis solo tienen la función de tomar la subexpresión interna como un todo.</p>
<p>La siguiente es la definición de gramática JSON admitida por el módulo JSON en la biblioteca estándar de Berry. El uso de EBNF aún cumple con las convenciones anteriores:</p>
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span><span class="k">json </span><span class="o">=</span> <span class="k">value</span><span class="p">;</span>
<span class="k">value </span><span class="o">=</span> <span class="k">object </span><span class="p">|</span> <span class="k">array </span><span class="p">|</span>
        <span class="k">string </span><span class="p">|</span> <span class="k">number </span><span class="p">|</span> <span class="s1">&#39;true&#39;</span> <span class="p">|</span> <span class="s1">&#39;false&#39;</span> <span class="p">|</span> <span class="s1">&#39;null&#39;</span><span class="p">;</span>
<span class="k">object </span><span class="o">=</span> <span class="s1">&#39;{&#39;</span> <span class="p">[</span> <span class="k">string </span><span class="s1">&#39;:&#39;</span> <span class="k">value </span><span class="p">]</span> <span class="p">{</span> <span class="s1">&#39;,&#39;</span> <span class="k">string </span><span class="s1">&#39;:&#39;</span> <span class="k">value </span><span class="p">}</span> <span class="s1">&#39;}&#39;</span><span class="p">;</span>
<span class="k">array </span><span class="o">=</span> <span class="s1">&#39;[&#39;</span> <span class="p">[</span><span class="k">json</span><span class="p">]</span> <span class="p">{</span> <span class="s1">&#39;,&#39;</span> <span class="k">json </span><span class="p">}</span> <span class="s1">&#39;]&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Los símbolos no terminales <code class="docutils literal notranslate"><span class="pre">cadena</span></code> y <code class="docutils literal notranslate"><span class="pre">número</span></code> también se pueden definir mediante expresiones regulares. <a class="reference external" href="http://www.json.org">http://www.json.org</a>proporciona la gramática estándar de JSON, que también incluye las definiciones de <code class="docutils literal notranslate"><span class="pre">cadena</span></code> y <code class="docutils literal notranslate"><span class="pre">número</span></code>. El soporte para números de la biblioteca Berry JSON es diferente del estándar.
Los números JSON estándar deben comenzar con “-” o el número “0-9”, mientras que la biblioteca Berry JSON también acepta números que comienzan con un punto decimal.</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Guan Wenliang &amp; Stephan Hadinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3. Expresiones &mdash; berry 1.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. Declaración" href="Capitulo-4.html" />
    <link rel="prev" title="2. Tipos y Variables" href="Capitulo-2.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> berry
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../en/Home.html">English</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Home.html">Spanish</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="Referencia.html">Manual de referencia del lenguaje Berry Script</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="Referencia.html#prefacio">Prefacio</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="Capitulo-1.html">Capítulo 1 - Información básica</a></li>
<li class="toctree-l4"><a class="reference internal" href="Capitulo-2.html">Capítulo 2 - Tipos y variables</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Capítulo 3 - Expresión</a></li>
<li class="toctree-l4"><a class="reference internal" href="Capitulo-4.html">Capítulo 4 - Declaración</a></li>
<li class="toctree-l4"><a class="reference internal" href="Capitulo-5.html">Capítulo 5 - Función</a></li>
<li class="toctree-l4"><a class="reference internal" href="Capitulo-6.html">Capítulo 6 - Función orientada a objetos</a></li>
<li class="toctree-l4"><a class="reference internal" href="Capitulo-7.html">Capítulo 7 - Bibliotecas y módulos</a></li>
<li class="toctree-l4"><a class="reference internal" href="Capitulo-8.html">Capítulo 8 - Funciones avanzadas</a></li>
<li class="toctree-l4"><a class="reference internal" href="Capitulo-9.html">Capítulo 9 - Interfaz interactiva del lenguaje</a></li>
<li class="toctree-l4"><a class="reference internal" href="Apendice-A.html">Apéndice A - Definición de gramática</a></li>
<li class="toctree-l4"><a class="reference internal" href="Apendice-B.html">Apéndice B - Intérprete del compilador</a></li>
<li class="toctree-l4"><a class="reference internal" href="Apendice-C.html">Apéndice C - Guía de Portabilidad</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="FFI-Ejemplo.html">Hacer una función nativa</a></li>
<li class="toctree-l2"><a class="reference internal" href="FFI-Ejemplo.html#crear-una-instancia-de-un-objeto-list-en-una-funcion-nativa">Crear una instancia de un objeto <code class="docutils literal notranslate"><span class="pre">list</span></code> en una función nativa</a></li>
<li class="toctree-l2"><a class="reference internal" href="Hoja-de-ruta.html">Hoja de ruta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Requerimientos-de-Memoria.html">Requerimientos de Memoria</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">Berry API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">berry</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="Home.html">Bienvenido a la wiki de Berry!</a> &raquo;</li>
          <li><a href="Referencia.html">Manual de referencia del lenguaje Berry Script</a> &raquo;</li>
      <li>3. Expresiones</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/es/Capitulo-3.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <!-- Spanish Translation: Emiliano Gonzalez (egonzalez . hiperion @ gmail . com) -->
<section id="expresiones">
<h1>3. Expresiones<a class="headerlink" href="#expresiones" title="Permalink to this headline">¶</a></h1>
<section id="conceptos-basicos">
<h2>3.1 Conceptos básicos<a class="headerlink" href="#conceptos-basicos" title="Permalink to this headline">¶</a></h2>
<p>Una expresión (Declaración) se compone de uno a más operandos y operadores, y se puede obtener un resultado evaluando la expresión.
Este resultado se llama el valor de la expresión. El operando puede ser un valor literal, una variable, una llamada de función o una subexpresión, etc. Las expresiones y operadores simples también se pueden combinar en expresiones más complejas. Similar a las cuatro operaciones aritméticas, la precedencia de los operadores afecta el orden de evaluación de las expresiones. Cuanto mayor sea la precedencia del operador, antes se evaluará la expresión.</p>
<section id="operadores-y-expresiones">
<h3>Operadores y expresiones<a class="headerlink" href="#operadores-y-expresiones" title="Permalink to this headline">¶</a></h3>
<p>Berry proporciona algunos operadores unarios y operadores binarios. Por ejemplo, el operador AND lógico <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> es un operador binario, y el operador de negación lógica <code class="docutils literal notranslate"><span class="pre">!</span></code> es un operador unario. Algunos operadores pueden ser operadores unarios u operadores binarios. El significado específico de tales operadores depende del contexto. Por ejemplo, el operador <code class="docutils literal notranslate"><span class="pre">-</span></code> es un símbolo unario en la expresión <code class="docutils literal notranslate"><span class="pre">-1</span></code>, pero es un signo menos binario en la expresión <code class="docutils literal notranslate"><span class="pre">1-2</span></code>.</p>
<section id="expresion-de-combinacion-de-operadores">
<h4>Expresión de combinación de operadores<a class="headerlink" href="#expresion-de-combinacion-de-operadores" title="Permalink to this headline">¶</a></h4>
<p>Tanto el lado izquierdo como el derecho de un operador binario pueden ser subexpresiones, por lo que puede usar operadores binarios para combinar expresiones.
Una expresión más compleja suele tener varios operadores y operandos. En este momento, el orden de evaluación de cada subexpresión en la expresión puede afectar el valor de la expresión. La precedencia y asociatividad de los operadores garantizan la unicidad del orden de evaluación de la expresión. Por ejemplo, una expresión combinada:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">+</span> <span class="mi">10</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Las cuatro operaciones aritméticas de uso diario calcularán primero la expresión de división <code class="docutils literal notranslate"><span class="pre">10/2</span></code>, luego la expresión de multiplicación y finalmente la expresión de suma. Esto se debe a que la multiplicación y la división tienen mayor prioridad que la suma.</p>
</section>
<section id="tipo-de-operando">
<h4>Tipo de operando<a class="headerlink" href="#tipo-de-operando" title="Permalink to this headline">¶</a></h4>
<p>En la operación de expresiones, los operandos pueden tener tipos que no coincidan con los operadores. Además, los operadores binarios normalmente requieren que los operandos izquierdo y derecho sean del mismo tipo. La expresión <code class="docutils literal notranslate"><span class="pre">'10'+10</span></code> es incorrecta. No puede agregar una cadena a un número entero. El problema con la expresión <code class="docutils literal notranslate"><span class="pre">-'b'</span></code> es que no puedes tomar un valor negativo en una cadena.
A veces, un operador binario tiene diferentes tipos de operandos pero puede realizar operaciones. Por ejemplo, al agregar un número entero a un número real, el objeto entero se convertirá en un número real y se agregará a otro objeto de número real. Los operadores lógicos AND y OR lógicos permiten que los operandos a ambos lados del operador sean de cualquier tipo. En expresiones lógicas, siempre se convertirán al tipo <code class="docutils literal notranslate"><span class="pre">booleano</span></code> de acuerdo con ciertas reglas.</p>
<p>Otra situación es que los operadores pueden sobrecargarse al usar clases personalizadas. En esencia, puede interpretar este operador arbitrariamente y depende de usted decidir qué tipo de operando debe ser.</p>
</section>
</section>
<section id="prioridad-y-asociatividad">
<h3>3.1.1 Prioridad y asociatividad<a class="headerlink" href="#prioridad-y-asociatividad" title="Permalink to this headline">¶</a></h3>
<p>En una expresión compuesta de varios operadores, la precedencia y la asociatividad de los operadores determinan el orden de evaluación de las expresiones. La precedencia y asociatividad de cada operador se dan en la <a href="#tab::operator_list" data-reference-type="ref" data-reference="tab::operator_list">Tabla 2</a> .</p>
<p>La precedencia especifica el orden de evaluación entre diferentes operadores, y las expresiones con operadores de mayor precedencia se evaluarán primero. Por ejemplo, el proceso de evaluar la expresión <code class="docutils literal notranslate"><span class="pre">1+2*3</span></code> calculará primero el resultado de <code class="docutils literal notranslate"><span class="pre">2*3</span></code> y luego el resultado de la expresión de suma. El uso de paréntesis puede mejorar el orden de evaluación de las expresiones de baja prioridad. Por ejemplo, en la evaluación de la expresión <code class="docutils literal notranslate"><span class="pre">(1+2)*3</span></code>, primero se calcula el resultado de la expresión <code class="docutils literal notranslate"><span class="pre">1+2</span></code> entre paréntesis y luego se calcula la expresión de multiplicación fuera de los paréntesis.</p>
<p>La asociatividad se refiere al orden de evaluación de los operandos en ambos lados del operador, donde los operandos pueden ser subexpresiones. Por ejemplo, en la expresión de suma <code class="docutils literal notranslate"><span class="pre">expr1</span> <span class="pre">+</span> <span class="pre">expr2</span></code>, el valor de <code class="docutils literal notranslate"><span class="pre">expr1</span></code> se calcula primero y luego el valor de <code class="docutils literal notranslate"><span class="pre">expr2</span></code>, porque el operador de suma es asociativo por la izquierda.</p>
<div id="tab::operator_list">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><strong>prioridad</strong></p></th>
<th class="text-center head"><p><strong>Operador</strong></p></th>
<th class="text-left head"><p><strong>Descripción</strong></p></th>
<th class="text-center head"><p><strong>Asociatividad</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>1</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">()</span></code></p></td>
<td class="text-left"><p>Símbolo de agrupación</p></td>
<td class="text-center"><p>-</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>2</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">[]</span> <span class="pre">.</span></code></p></td>
<td class="text-left"><p>Operación de campo</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>3</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">-!</span> <span class="pre">~</span></code></p></td>
<td class="text-left"><p>Signo negativo, negación lógica, cambio de bit</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>4</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">/</span> <span class="pre">%</span></code></p></td>
<td class="text-left"><p>Multiplicación, división y resto</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>5</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">+</span> <span class="pre">-</span></code></p></td>
<td class="text-left"><p>Suma, resta</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>6</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span> <span class="pre">&gt;&gt;</span></code></p></td>
<td class="text-left"><p>Mover a la izquierda, mover a la derecha</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>7</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td class="text-left"><p>Bit a bit Y</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>8</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td class="text-left"><p>XOR bit a bit</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>9</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
<td class="text-left"><p>Bit a bit O</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>10</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">..</span></code></p></td>
<td class="text-left"><p>Operador de concatenación</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>11</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">&lt;=</span> <span class="pre">&gt;</span> <span class="pre">&gt;=</span></code></p></td>
<td class="text-left"><p>Mayor que, mayor que o igual a</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>12</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">!=</span></code></p></td>
<td class="text-left"><p>Igual a, no igual a</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>13</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code></p></td>
<td class="text-left"><p>Y lógico</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>14</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">||</span></code></p></td>
<td class="text-left"><p>O lógico</p></td>
<td class="text-center"><p>izquierda</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>15</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code></p></td>
<td class="text-left"><p>Operador condicional</p></td>
<td class="text-center"><p>derecha</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>16</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&amp;=</span> <span class="pre">|=</span> <span class="pre">^=</span> <span class="pre">&lt;&lt;=</span> <span class="pre">&gt;&gt;=</span></code></p></td>
<td class="text-left"><p>Asignación</p></td>
<td class="text-center"><p>derecha</p></td>
</tr>
</tbody>
</table>
<p><em>Tabla 2: Lista de operadores</em></p>
</div>
<section id="utilice-corchetes-para-aumentar-la-prioridad">
<h4>Utilice corchetes para aumentar la prioridad<a class="headerlink" href="#utilice-corchetes-para-aumentar-la-prioridad" title="Permalink to this headline">¶</a></h4>
<p>Los paréntesis se pueden usar cuando necesitamos que los operadores con menor precedencia se evalúen primero. Durante la evaluación de expresiones, primero se calcula el valor de la expresión entre paréntesis. En otras palabras, para toda la expresión, la expresión entre paréntesis es equivalente a un operando, independientemente de la composición de la expresión entre paréntesis.</p>
</section>
</section>
</section>
<section id="operador">
<h2>3.2 Operador<a class="headerlink" href="#operador" title="Permalink to this headline">¶</a></h2>
<section id="operadores-aritmeticos">
<h3>3.2.1 Operadores aritméticos<a class="headerlink" href="#operadores-aritmeticos" title="Permalink to this headline">¶</a></h3>
<p>Los operadores aritméticos se utilizan para implementar operaciones aritméticas. Estos operadores son similares a los símbolos matemáticos que solemos usar. Los operadores aritméticos provistos por Berry se muestran en la <a href="#tab::arthmetic_operator" data-reference-type="ref" data-reference="tab::arthmetic_operator">Tabla 3</a> .</p>
<div id="tab::arthmetic_operator">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><strong>Operador</strong></p></th>
<th class="text-center head"><p><strong>Descripción</strong></p></th>
<th class="text-center head"><p><strong>Ejemplo</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td class="text-center"><p>menos unario</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">+</span></code></p></td>
<td class="text-center"><p>Concatenación más/cadena</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">+</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td class="text-center"><p>signo menos</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr-expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td class="text-center"><p>Signo de multiplicación</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">*</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">/</span></code></p></td>
<td class="text-center"><p>Signo de división</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">/</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td class="text-center"><p>Toma el resto</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr%expr</span></code></p></td>
</tr>
</tbody>
</table>
<p><em>Tabla 3: Operador aritmético</em></p>
</div>
<p>Operador binario <code class="docutils literal notranslate"><span class="pre">+</span></code> Además de ser un signo más, también es una concatenación de cadenas. Cuando el operando de este operador es una cadena, la concatenación de cadenas se realizará para concatenar dos cadenas en una cadena más larga. Para ser precisos, <code class="docutils literal notranslate"><span class="pre">+</span></code> como concatenación de cadenas ya no está en la categoría de operadores aritméticos.</p>
<p>El operador binario <code class="docutils literal notranslate"><span class="pre">%</span></code> es el símbolo de resto. Sus operandos deben ser números enteros. El resultado de la operación de resto es el resto después de dividir el operando izquierdo por el operando derecho. Por ejemplo, el resultado de <code class="docutils literal notranslate"><span class="pre">11%4</span></code> es <code class="docutils literal notranslate"><span class="pre">3</span></code>. El tipo de número real no puede ser divisible, por lo que no se admite el resto.</p>
<p>En general, los operadores aritméticos no cumplen la ley conmutativa. Por ejemplo, los valores de las expresiones <code class="docutils literal notranslate"><span class="pre">2/4</span></code> y <code class="docutils literal notranslate"><span class="pre">4/2</span></code> no son iguales.</p>
<p>Todos los operadores aritméticos se pueden sobrecargar en la clase. Los operadores sobrecargados no están necesariamente limitados a su diseño funcional original, sino que son determinados por el programador.</p>
</section>
<section id="operadores-relacionales">
<h3>3.2.2 Operadores relacionales<a class="headerlink" href="#operadores-relacionales" title="Permalink to this headline">¶</a></h3>
<p>Los operadores relacionales se utilizan para comparar la magnitud de los operandos.
Los seis operadores relacionales soportados por Berry se dan en la <a href="#tab::relop_operator" data-reference-type="ref" data-reference="tab::relop_operator">Tabla 4</a> .</p>
<div id="tab::relop_operator">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><strong>Operador</strong></p></th>
<th class="text-center head"><p><strong>Descripción</strong></p></th>
<th class="text-center head"><p><strong>Ejemplo</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
<td class="text-center"><p>Menor que</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">&lt;</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></p></td>
<td class="text-center"><p>Menor o igual que</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">&lt;=</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td class="text-center"><p>Igual</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">==</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
<td class="text-center"><p>No es igual a</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">!=</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
<td class="text-center"><p>Mayor o igual a</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">&gt;=</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
<td class="text-center"><p>Mayor qu e</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">-expr</span></code></p></td>
</tr>
</tbody>
</table>
<p><em>Tabla 4: Operador relacional</em></p>
</div>
<p>Al comparar la relación de magnitud de los operandos o juzgar si los operandos son iguales, la evaluación de la expresión relacional producirá un resultado booleano. Cuando se cumple la relación, el valor de la expresión de la relación es “verdadero”, de lo contrario, es “falso”.
Los operadores relacionales <code class="docutils literal notranslate"><span class="pre">==</span></code> y <code class="docutils literal notranslate"><span class="pre">!=</span></code> pueden usar cualquier tipo de operando y permiten que los operandos izquierdo y derecho tengan diferentes tipos. Otros operadores relacionales permiten el uso de las siguientes combinaciones de operandos:</p>
<blockquote>
<div><p><strong>integer</strong> relop <strong>integer</strong><br>
<strong>real</strong> relop <strong>real</strong><br>
<strong>integer</strong> relop <strong>real</strong><br>
<strong>real</strong> relop <strong>integer</strong><br>
<strong>string</strong> relop <strong>string</strong></p>
</div></blockquote>
<p>En operaciones relacionales, el signo igual <code class="docutils literal notranslate"><span class="pre">==</span></code> y el signo de desigualdad <code class="docutils literal notranslate"><span class="pre">!=</span></code> satisfacen la ley conmutativa. Si los operandos izquierdo y derecho son del mismo tipo o ambos son de tipo numérico (número entero y número real), los operandos se consideran iguales según el valor de los operandos; de lo contrario, los operandos se consideran desiguales. La igualdad y la desigualdad son operaciones recíprocas: si <code class="docutils literal notranslate"><span class="pre">a==b</span></code> es verdadero, entonces <code class="docutils literal notranslate"><span class="pre">a!=b</span></code> es falso, y viceversa. Otros operadores relacionales no satisfacen la ley conmutativa, pero tienen las siguientes propiedades: <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> y <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> son operaciones recíprocas, y <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> y <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> son operaciones recíprocas. Las operaciones relacionales requieren que los operandos sean del mismo tipo, de lo contrario es una expresión incorrecta.</p>
<p>Las instancias pueden sobrecargar a los operadores como métodos. Si el operador relacional está sobrecargado, el programa debe garantizar las propiedades anteriores.</p>
<p>Entre los operadores relacionales, los operadores <code class="docutils literal notranslate"><span class="pre">==</span></code> y <code class="docutils literal notranslate"><span class="pre">!=</span></code> tienen requisitos más relajados que <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> y <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, que solo permiten comparaciones entre los mismos tipos. En el desarrollo de un programa real, el juicio de igualdad o desigualdad suele ser más simple que el juicio de tamaño. Es posible que algunos objetos de operación no puedan juzgar el tamaño, pero solo pueden juzgar la igualdad o desigualdad. Este es el caso del tipo booleano.</p>
</section>
<section id="operadores-logicos">
<h3>Operadores logicos<a class="headerlink" href="#operadores-logicos" title="Permalink to this headline">¶</a></h3>
<p>Los operadores lógicos se dividen en tres tipos: AND lógico, OR lógico y NOT lógico. Como se muestra en la <a href="#tab::logic_operator" data-reference-type="ref" data-reference="tab::logic_operator">Tabla 5</a> .</p>
<div id="tab::logic_operator">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><strong>Operador</strong></p></th>
<th class="text-center head"><p><strong>Descripción</strong></p></th>
<th class="text-center head"><p><strong>Ejemplo</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code></p></td>
<td class="text-center"><p>Y lógico</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">&amp;&amp;</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">||</span></code></p></td>
<td class="text-center"><p>O lógico</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr||</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">!</span></code></p></td>
<td class="text-center"><p>Negación lógica</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">!expr</span></code></p></td>
</tr>
</tbody>
</table>
<p><em>Tabla 5: Operadores logicos</em></p>
</div>
<p>Para el operador lógico AND, cuando los valores de ambos operandos son “verdaderos”, el valor de la expresión lógica es “verdadero”, de lo contrario, es “falso”.</p>
<p>Para el operador lógico OR, cuando los valores de ambos operandos son <code class="docutils literal notranslate"><span class="pre">falso</span></code>, el valor de la expresión lógica es <code class="docutils literal notranslate"><span class="pre">falso</span></code>, de lo contrario es <code class="docutils literal notranslate"><span class="pre">verdadero</span></code>.</p>
<p>El papel del operador de negación lógica es cambiar el estado lógico del operando. Cuando el valor del operando es “verdadero”, el valor de la expresión lógica es “falso”, de lo contrario, el valor es “verdadero”.</p>
<p>Los operadores lógicos requieren que el operando sea de tipo booleano, y si el operando no es de tipo booleano, se convertirá. Consulte la sección [Capitulo-2: Tipo booleano] para conocer las reglas de conversión.</p>
<p>Las operaciones lógicas utilizan una estrategia de evaluación llamada <strong>Evaluación de cortocircuito</strong>. Esta estrategia de evaluación es: para el operador lógico AND, el segundo operando se evaluará si y solo si el operando de la izquierda es verdadero; para el operador lógico OR, si y solo si el operando izquierdo es falso evaluará el operando derecho.
La naturaleza de la evaluación de cortocircuito hace que no se ejecute todo el código de la expresión lógica.</p>
</section>
<section id="operador-bit-a-bit">
<h3>Operador bit a bit<a class="headerlink" href="#operador-bit-a-bit" title="Permalink to this headline">¶</a></h3>
<p>Los operadores de bits pueden implementar algunas operaciones de bits binarios, y las operaciones de bits solo se pueden usar en tipos enteros. La información detallada de los operadores de bit se muestra en la <a href="#tab::bitwise_operator" data-reference-type="ref" data-reference="tab::bitwise_operator">Tabla 6</a> .
La operación de bits se refiere a la operación de bits binarios directamente en números enteros. Las operaciones lógicas se pueden extender a operaciones de bits. Tomando AND lógico como ejemplo, podemos realizar esta operación en cada bit binario para lograr AND bit a bit, como $110_b\ {\rm AND}\ 011_b = 010_b$. Las operaciones de bits también admiten operaciones de cambio, que mueven números de forma binaria.</p>
<div id="tab::bitwise_operator">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><strong>Operador</strong></p></th>
<th class="text-left head"><p></p></th>
<th class="text-center head"><p><strong>Ejemplo</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">~</span></code></p></td>
<td class="text-left"><p>Negar</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">~expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td class="text-left"><p>Bit a bit y</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">&amp;</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
<td class="text-left"><p>Bit a bit o</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr|</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td class="text-left"><p>O exclusivo bit a bit</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr^expr</span></code></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code></p></td>
<td class="text-left"><p>Desplazar a la izquierda</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">&lt;&lt;</span> <span class="pre">expr</span></code></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
<td class="text-left"><p>Desplazar a la derecha</p></td>
<td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">&gt;&gt;</span> <span class="pre">expr</span></code></p></td>
</tr>
</tbody>
</table>
<p><em>Tabla 6: Operador bit a bit</em></p>
</div>
<p>Aunque solo se puede usar para números enteros, las operaciones con bits siguen siendo versátiles. Las operaciones de bits pueden implementar muchas técnicas de optimización. En muchos algoritmos, el uso de operaciones de bits puede ahorrar mucho código. Por ejemplo, para determinar si un número <code class="docutils literal notranslate"><span class="pre">n</span></code> es una potencia de 2, podemos juzgar si el resultado de <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&amp;</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1)</span></code> es <code class="docutils literal notranslate"><span class="pre">0</span></code>. En algunos lenguajes con alta eficiencia de ejecución, las operaciones de cambio también se pueden usar para optimizar la multiplicación y la división (por lo general, no hay un efecto obvio en los lenguajes de secuencias de comandos).</p>
<p>El operador AND bit a bit “<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>” es un operador binario, que realiza la operación AND binaria de dos operandos enteros: solo cuando los bits binarios correspondientes a los operandos son todos <code class="docutils literal notranslate"><span class="pre">1</span></code>, el resultado es <code class="docutils literal notranslate"><span class="pre">1</span></code>. Por ejemplo, 1110 <sub><em>b</em></sub> &amp; 0111 <sub><em>b</em></sub> = 0110 <sub><em>b</em></sub> .</p>
<p>El operador OR bit a bit “<code class="docutils literal notranslate"><span class="pre">|</span></code>” es un operador binario, que realiza una operación OR de bits binarios en dos operandos enteros: solo cuando los bits binarios correspondientes a los operandos son ambos <code class="docutils literal notranslate"><span class="pre">0</span></code>, el bit del resultado es <code class="docutils literal notranslate"> <span class="pre">0</span></code>. Por ejemplo, 1000 <sub><em>b</em></sub> | 0001 <sub><em>b</em></sub> = 1001 <sub><em>b</em></sub> .</p>
<p>El operador OR exclusivo bit a bit “<code class="docutils literal notranslate"><span class="pre">^</span></code>” es un operador binario, que realiza una operación OR exclusiva binaria en dos operandos enteros: cuando los bits binarios correspondientes a los operandos son diferentes, el valor de bit del resultado es <code class="docutils literal notranslate"><span class="pre">1</span></code>. Por ejemplo, $1100_b\ \hat{}\ 0101_b = 1001_b$.</p>
<p>El operador de desplazamiento a la izquierda “<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>” es un operador binario, que mueve el operando izquierdo hacia la izquierda el número de bits especificado por el operando derecho sobre una base binaria. Por ejemplo, 00001010 <sub><em>b</em></sub> ≪ 3 = 01010000 <sub><em>b</em></sub> . El operador de desplazamiento a la derecha “<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>” es un operador binario, que desplaza el operando izquierdo hacia la derecha el número de bits especificado por el operando derecho en un binario. base. Por ejemplo, 10100000 <sub><em>b</em></sub> ≫ 3 = 00010100 <sub><em>b</em></sub> .</p>
<p>El operador de inversión bit a bit “~” es un operador unario, y el resultado de la expresión es invertir el valor de cada bit binario del operando.
Por ejemplo, <code class="docutils literal notranslate"><span class="pre">∼</span></code>10100011 <sub><em>b</em></sub> = 01011100 <sub><em>b</em></sub> .</p>
<p>Los siguientes son algunos ejemplos del uso de operaciones con bits. Por lo general, no usamos binario directamente. Los resultados de los ejemplos se han convertido en bases comunes.</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1"># 2</span>
<span class="mi">168</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1"># 10</span>
<span class="mi">456</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">127</span><span class="w"> </span><span class="c1"># 72</span>
<span class="mi">456</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">127</span><span class="w"> </span><span class="c1"># 511</span>
<span class="mh">0xA5</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mh">0x5A</span><span class="w"> </span><span class="c1"># 255</span>
<span class="o">~</span><span class="mi">2</span><span class="w"> </span><span class="c1"># -3</span>
</pre></div>
</div>
</section>
<section id="operador-de-asignacion">
<h3>Operador de asignación<a class="headerlink" href="#operador-de-asignacion" title="Permalink to this headline">¶</a></h3>
<p>El operador de asignación solo aparece en la expresión de asignación y el operando del operador debe ser un objeto de escritura. La expresión de asignación no tiene resultado, por lo que no se pueden utilizar operaciones de asignación continua.</p>
<section id="operador-de-asignacion-simple">
<h4>Operador de asignación simple<a class="headerlink" href="#operador-de-asignacion-simple" title="Permalink to this headline">¶</a></h4>
<p>El operador de asignación simple <code class="docutils literal notranslate"><span class="pre">=</span></code> se puede utilizar para la asignación de variables.
Si la variable de operando de la izquierda no está definida, se definirá la variable. El operador de asignación se utiliza para vincular el valor del operando derecho con el operando izquierdo. Este proceso también se llama “asignación”.
Por lo tanto, el operando izquierdo no puede ser una constante, ni puede ser ningún objeto que no se pueda escribir. Estas son algunas expresiones legales de asignación:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">45</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>Y la siguiente expresión de asignación es incorrecta:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1"># Tratando de asignar una constante 1</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">#  Asignación continua</span>
</pre></div>
</div>
<p>Al asignar tipos <code class="docutils literal notranslate"><span class="pre">nil</span></code>, enteros, reales y booleanos a variables, el valor del objeto se pasará al operando izquierdo, pero para otros tipos, la operación de asignación simplemente pasa la referencia del objeto al operando izquierdo. Dado que las cadenas, las funciones y los tipos de clase son de solo lectura, todas las referencias que pasan no tendrán efectos secundarios, pero debe tener mucho cuidado con los tipos de instancia.</p>
</section>
<section id="operador-de-asignacion-compuesto">
<h4>Operador de asignación compuesto<a class="headerlink" href="#operador-de-asignacion-compuesto" title="Permalink to this headline">¶</a></h4>
<p>Los operadores de asignación compuestos son operadores que combinan operadores binarios y operadores de asignación. Son extensiones prácticas de operadores de asignación simples. Los operadores de asignación compuestos pueden simplificar la escritura de algunas expresiones. La <a href="#tab::compound_assign" data-reference-type="ref" data-reference="tab::compound_assign">Tabla 7</a> enumera todos los operadores de asignación compuestos</p>
<div id="tab::compound_assign">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><strong>Operador</strong></p></th>
<th class="text-left head"><p><strong>Descripción</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">+=</span></code></p></td>
<td class="text-left"><p>Asignación de adición</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">-=</span></code></p></td>
<td class="text-left"><p>Asignación de resta</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">*=</span></code></p></td>
<td class="text-left"><p>Asignación de multiplicación</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">/=</span></code></p></td>
<td class="text-left"><p>Asignación de división</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">%=</span></code></p></td>
<td class="text-left"><p>Asignación de resto</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&amp;=</span></code></p></td>
<td class="text-left"><p>Asignación AND bit a bit</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">|=</span></code></p></td>
<td class="text-left"><p>Asignación OR bit a bit</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">^=</span></code></p></td>
<td class="text-left"><p>Asignación XOR bit a bit</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code></p></td>
<td class="text-left"><p>Asignación de desplazamiento a la izquierda</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code></p></td>
<td class="text-left"><p>Asignación de desplazamiento a la derecha</p></td>
</tr>
</tbody>
</table>
<p><em>Tabla 7: Operador de bits</em></p>
</div>
<p>La expresión de asignación compuesta realiza la operación binaria correspondiente al operador de asignación compuesta en el operando izquierdo y el operando derecho, y luego asigna el resultado al operando izquierdo.
Tomando <code class="docutils literal notranslate"><span class="pre">+=</span></code> como ejemplo, la expresión <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">b</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>. El operador de asignación compuesto también es un operador de asignación, por lo que tiene una prioridad más baja. El operador binario correspondiente al operador de asignación compuesto siempre se evalúa después del operando derecho, por lo que una expresión como <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code> debería ser equivalente a <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">2)</span></code>.</p>
<p>A diferencia del operador de asignación simple, el operando izquierdo del operador de asignación compuesto debe participar en la evaluación, por lo que la expresión de asignación compuesta no tiene la función de definir variables.
El operador de asignación en sí no se puede sobrecargar en la clase. Los usuarios solo pueden sobrecargar el operador binario correspondiente al operador de asignación compuesto. Esto también asegura que el operador de asignación compuesto siempre se ajustará a las características básicas de las operaciones de asignación.</p>
<p>Operador de dominio y operador de subíndice</p>
<p>El operador de dominio <code class="docutils literal notranslate"><span class="pre">.</span></code> se utiliza para acceder a un atributo o miembro de un objeto. Puede utilizar operadores de dominio para ambos tipos de módulos e instancias:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">list</span><span class="p">[]</span><span class="w"></span>
<span class="n">l</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="s1">&#39;item 0&#39;</span><span class="p">)</span><span class="w"></span>
<span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1"># &#39;item 0&#39;</span>
</pre></div>
</div>
<p>El operador de subíndice <code class="docutils literal notranslate"><span class="pre">[]</span></code> se utiliza para acceder a los elementos de un objeto, por ejemplo</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1"># Read by index</span>
<span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="c1"># Write by index</span>
</pre></div>
</div>
<p>Las clases que admiten la lectura de subíndices deben implementar el método <code class="docutils literal notranslate"><span class="pre">item</span></code> y las clases que admiten la escritura de subíndices deben implementar el método <code class="docutils literal notranslate"><span class="pre">setitem</span></code>. El mapa y la lista en el contenedor estándar implementan estos dos métodos, por lo que admiten la lectura y escritura mediante el operador de subíndice. La cadena admite la lectura de subíndices, pero no admite la escritura de subíndices (las cadenas son valores de solo lectura):</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;string&#39;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="c1">#&#39;r&#39;</span>
<span class="s1">&#39;string&#39;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="c1"># error:  valor &#39;string&#39; no admite asignación de índice</span>
</pre></div>
</div>
<p>Actualmente, las cadenas admiten subíndices enteros y el rango de subíndices no puede exceder la longitud de la cadena.</p>
</section>
</section>
<section id="operador-condicional">
<h3>Operador condicional<a class="headerlink" href="#operador-condicional" title="Permalink to this headline">¶</a></h3>
<p>El operador condicional (<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code>) es similar a la declaración <strong>if else</strong>, pero la primera puede usarse en expresiones. La forma de uso del operador condicional es:
$$\begin{gathered}
cond\ \bm{?}\ expr1\ \bm{:}\ expr2\end{gathered}$$</p>
<p><em><strong>cond</strong></em> es la expresión utilizada para juzgar la condición. El proceso de evaluación del operador condicional es: primero encuentra el valor de <em><strong>cond</strong></em>, si la condición es verdadera, evalúa <em><strong>expr1</strong></em> y devuelve el valor, de lo contrario, el valor de <em>**expr2 **</em> ] Evalúa y devuelve el valor.
<em><strong>expr1</strong></em> y <em><strong>expr2</strong></em> pueden tener diferentes tipos, por lo que lo siguiente es correcto:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alcance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;malo&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">alcance</span><span class="w"></span>
</pre></div>
</div>
<p>Esta expresión primero determina si <code class="docutils literal notranslate"><span class="pre">alcance</span></code> es menor que <code class="docutils literal notranslate"><span class="pre">6</span></code>, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">malo</span></code>, de lo contrario, devuelve el valor de <code class="docutils literal notranslate"><span class="pre">alcance</span></code>.
Independientemente de la condición de la expresión condicional, solo se ejecutará uno de <em><strong>expr1</strong></em> o <em><strong>expr2</strong></em>, similar a la característica de cortocircuito de las operaciones lógicas AND y lógicas OR.</p>
<section id="operadores-de-condiciones-anidadas">
<h4>Operadores de condiciones anidadas<a class="headerlink" href="#operadores-de-condiciones-anidadas" title="Permalink to this headline">¶</a></h4>
<p>Un operador condicional se puede anidar en otro operador condicional, es decir, la expresión condicional se puede usar como <em><strong>cond</strong></em> o <em><strong>expr</strong></em> de otra expresión condicional. Por ejemplo, use expresiones condicionales para dividir puntajes en tres niveles: excelente, bueno y malo:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alcance</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;excelente&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">alcance</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;bueno&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;malo&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>La primera condición comprueba si la puntuación no es inferior a <code class="docutils literal notranslate"><span class="pre">9</span></code> puntos. Si es así, ejecute la rama después de <code class="docutils literal notranslate"><span class="pre">?</span></code> y devuelva <code class="docutils literal notranslate"><span class="pre">'excelente'</span></code>; de lo contrario, ejecute la rama después de <code class="docutils literal notranslate"><span class="pre">:</span></code>, que también es una expresión condicional. La condición comprueba si la puntuación no es inferior a <code class="docutils literal notranslate"><span class="pre">6</span></code>, si lo es, devuelve <code class="docutils literal notranslate"><span class="pre">'bueno'</span></code>, de lo contrario, devuelve <code class="docutils literal notranslate"><span class="pre">'malo'</span></code>.</p>
<p>El operador condicional satisface la asociatividad correcta, por lo que el valor de la expresión de bifurcación debe evaluarse primero para obtener el valor de la expresión condicional. Por lo tanto, en una expresión condicional anidada, la expresión condicional anidada se evalúa primero y luego se evalúa la expresión condicional externa.</p>
</section>
<section id="prioridad-de-los-operadores-condicionales">
<h4>Prioridad de los operadores condicionales<a class="headerlink" href="#prioridad-de-los-operadores-condicionales" title="Permalink to this headline">¶</a></h4>
<p>Dado que la precedencia de las expresiones condicionales es muy baja (sólo superada por los operadores de asignación), a menudo es necesario agregar paréntesis fuera de las expresiones condicionales. Por ejemplo, cuando se usa una expresión condicional como operando de una expresión aritmética, los paréntesis tendrán diferentes efectos en el resultado:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">signo</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1"># el resultado es -10 ó 10</span>
<span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">signo</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1"># el resultado es -1 ó 1</span>
</pre></div>
</div>
<p>El resultado de la primera expresión es correcto, y la segunda expresión toma <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">*</span> <span class="pre">signo</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> como condición a juzgar, lo que no cumple con la expectativa de la expresión condicional como el operando derecho de la multiplicación.</p>
</section>
</section>
<section id="operador-de-concatenacion">
<h3>Operador de concatenación<a class="headerlink" href="#operador-de-concatenacion" title="Permalink to this headline">¶</a></h3>
<section id="id1">
<h4>Operador <code class="docutils literal notranslate"><span class="pre">+</span></code><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Cuando los operandos izquierdo y derecho son cadenas, el operador <code class="docutils literal notranslate"><span class="pre">+</span></code> se usa para conectar las dos cadenas, y la nueva cadena obtenida es el valor de la expresión. Por lo tanto, este operador se usa a menudo para la concatenación de cadenas:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;abc&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;123&#39;</span><span class="w"> </span><span class="c1"># el resultado es &#39;abc123&#39;</span>
</pre></div>
</div>
<p>Los operadores <code class="docutils literal notranslate"><span class="pre">+</span></code> también se pueden usar para conectar dos instancias de lista:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="c1"># el resultado es [1, 2, 3, 4]</span>
</pre></div>
</div>
<p>A diferencia del método <code class="docutils literal notranslate"><span class="pre">list.push</span></code>, el operador <code class="docutils literal notranslate"><span class="pre">+</span></code> fusiona dos listas en un objeto de lista más grande, con los elementos del operando izquierdo al principio de la lista de resultados y los elementos del operando derecho al final de la lista de resultados</p>
</section>
<section id="id2">
<h4>Operador <code class="docutils literal notranslate"><span class="pre">..</span></code><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">..</span></code> es un operador especial. Si el operando izquierdo es una cadena, el comportamiento de la expresión es concatenar los operandos izquierdo y derecho en una nueva cadena (conversión automática si el operando derecho no es una cadena):</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;abc&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">123</span><span class="w"> </span><span class="c1"># el resultado es &#39;abc123&#39;</span>
</pre></div>
</div>
<p>El operador <code class="docutils literal notranslate"><span class="pre">..</span></code> se usa a menudo cuando se concatena una cadena y un valor que no es una cadena. Si el operando izquierdo es una instancia de lista, el operador <code class="docutils literal notranslate"><span class="pre">..</span></code> agregará el operando derecho al final de la lista y luego usará esta lista como el valor de la expresión:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="s1">&#39;abc&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">123</span><span class="w"> </span><span class="c1"># el resultado es &#39;abc123&#39;</span>
</pre></div>
</div>
<p>Este proceso modificará directamente el operando izquierdo, que es muy similar al método <code class="docutils literal notranslate"><span class="pre">push</span></code> de <code class="docutils literal notranslate"><span class="pre">list</span></code> (excepto las cadenas que son objetos inmutables).
La operación de unión de la lista se puede ejecutar en cadena:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1"># el resultado es [1, 2, 3, 4]</span>
</pre></div>
</div>
<p>Todos los valores en este proceso se agregarán al objeto de lista más a la izquierda.</p>
<p>Si los operandos izquierdo y derecho son enteros, utilice el operador <code class="docutils literal notranslate"><span class="pre">..</span></code> para obtener un objeto de rango de enteros:</p>
<div class="highlight-berry notranslate"><div class="highlight"><pre><span></span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1"># el resultado es (1..10)</span>
</pre></div>
</div>
<p>Este objeto se utiliza para representar un intervalo cerrado de enteros, donde el operando izquierdo es el límite inferior y el operando derecho es el límite superior. Dichos objetos de rango de enteros se utilizan a menudo para la iteración.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Capitulo-2.html" class="btn btn-neutral float-left" title="2. Tipos y Variables" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Capitulo-4.html" class="btn btn-neutral float-right" title="4. Declaración" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Guan Wenliang &amp; Stephan Hadinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>